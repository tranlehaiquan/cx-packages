/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/config/regions": {
    get: operations["configRegions"];
  };
  "/config/team/web": {
    /** Return server base URLs and web authentication configuration. These server URLs depend on the deployment region of the team and must be used for API requests. */
    get: operations["configTeamWeb"];
  };
  "/config/team/mobile": {
    get: operations["configTeamMobile"];
  };
  "/config/team/mobile/v3": {
    get: operations["configTeamMobileV3"];
  };
  "/config/team/web/user": {
    get: operations["configTeamWebUser"];
  };
  "/config/team/mobile/user": {
    get: operations["configTeamMobileUser"];
  };
  "/config/team/mobile/v3/user": {
    get: operations["configTeamMobileV3User"];
  };
  "/config": {
    /** Uses the current url domain or the domain query string if provided. This endpoint is deprecated, use /config/team/web instead. */
    get: operations["config"];
  };
  "/auth_config": {
    /** Return config for a given domain, as well as all the necessary configurations to establish an Auth0 authentication session. This endpoint is deprecated, use /config/team/mobile or /config/team/web instead. */
    get: operations["authConfig"];
  };
  "/delegate": {
    /** Return the access information for a storage provider. */
    post: operations["delegate"];
  };
  "/whoami": {
    /** Return the current user's authentication information */
    get: operations["whoami"];
  };
  "/rules/resolve": {
    /** Resolves the supplied rule definitions into valid EQL filters (combining rules by object type, and returning errors for any invalid filter definitions). Requires the useRecordAccessPolicies feature flag. */
    post: operations["rules_resolve"];
  };
  "/rules/user": {
    /** Return the current user's data access rules. Requires the useRecordAccessPolicies feature flag. */
    get: operations["rules_user"];
  };
  "/api_user": {
    /**
     * The user assigning the API user must be an administrator.
     *
     * >NOTE:
     * >If you make any modifications to the user assigned as the API User, you need to set the user as the API User again to ensure the data stored for the user is up to date. Otherwise, some claims in the access token will be outdated.
     */
    post: operations["setApiUser"];
    /** Removes the API User for this tenant if they have one. If the tenant is on Standalone this will reset their API user to the system user. The caller must be an administrator. */
    delete: operations["removeApiUser"];
  };
  "/api_user/client_credentials": {
    /** The user requesting this information must be an administrator for their organization. */
    get: operations["getApiUserClientCredentials"];
  };
  "/api_user/candidates": {
    /** List candidates that can be set as the API user and the current API user. Only users with role `administrator` are returned. */
    get: operations["listApiUserCandidates"];
  };
  "/api_user/verify": {
    get: operations["verifyApiUser"];
  };
  "/metadata/user": {
    /** Fetch metadata about the current user. */
    get: operations["metadataUser"];
  };
  "/forgot_team_name": {
    /** Find all team names for all users with a provided email, and sends the team names to the email */
    post: operations["forgotTeamName"];
  };
  "/link_resource": {
    /** Links (assigns) a resource to a user by their respective Ids. */
    post: operations["linkResource"];
    /** Unlinked a resource to a user by their respective Ids. */
    delete: operations["unlinkResource"];
  };
  "/tokens": {
    /** List all the available and revoked API tokens. */
    get: operations["fetchAll"];
  };
  "/token/{jti}": {
    /** Get an API token by specifying its JTI. */
    get: operations["fetchAllApiTokens"];
  };
  "/token": {
    /** Create an API token with an optional expiry. This token can be used to authenticate as the same user that created it (with the same claims) for as long as the token is valid. Tokens may be revoked. */
    post: operations["createApiToken"];
  };
  "/token/revoke": {
    /** Revoke an API token so it can no longer be used. The token will be returned but marked as revoked. It cannot be used to authenticate once revoked. */
    post: operations["revokeToken"];
  };
}

export interface components {
  schemas: {
    AuthConfigResponse: {
      /** @description Configurations specific to this Skedulo API Server */
      authConfig: {
        /** @description The client ID of the client application the authentication will be performed on */
        clientId: string;
        /** @description The audience field of the Skedulo API server */
        audience: string;
        /** @description The domain the client should initiate authentication with */
        authDomain: string;
      };
      /** @description Configuration specific to the tenant (the tenant is determined through the provided domain). This field is null if no tenant is found for the given domain, otherwise it's an object containing all the tenant configurations that's set. (which can be empty object, if nothing is set) */
      tenantConfig?: {
        auth0LockConfig?: components["schemas"]["Auth0LockConfig"];
      };
    };
    DelegationParams: {
      /** @description The client ID requesting this delegation. This should match the 'azp' (Authorized Party) field in the JWT */
      clientId: string;
      /**
       * @description The target to acquire delegation for
       * @enum {string}
       */
      target: "salesforce" | "salesforce-sandbox";
      /** @description The ID Token representing the identity of the user */
      idToken: string;
    };
    AccessToken: {
      value: string;
    };
    UserInfo: {
      username: string;
      userId: string;
      tenantId: string;
      roles: components["schemas"]["Roles"];
      resourceId?: string;
      vendorInfo: components["schemas"]["VendorInfo"];
      permissions?: components["schemas"]["Permissions"];
    };
    Roles: ("administrator" | "scheduler" | "resource")[];
    VendorInfo:
      | {
          /** @example salesforce */
          vendor: string;
          /** @enum {string} */
          env: "salesforce" | "salesforce-sandbox";
          /** @description community ID for this user if this user belongs to one */
          communityId?: string;
          /** @description Salesforce user ID of this user */
          vendorUserId?: string;
        }
      | {
          /** @example skedulo */
          vendor: string;
          /** @description Skedulo user ID of this user */
          vendorUserId?: string;
        };
    /** @description The permissions for the user. Only present if the useNewPermissions feature flag is enabled. */
    Permissions: string[];
    RecordAccessRule: {
      /** @description The type of object that the rule applies to */
      objectType: string;
      /** @description EQL filter that is applied when accessing records of the object type */
      filter: string;
      /**
       * @description Whether the rule allows or denies access
       * @enum {string}
       */
      accessType: "allow" | "deny";
    };
    ResolvedAccessRule: {
      /** @description The type of object that the rule applies to */
      objectType: string;
      /** @description EQL filter that is applied when accessing records of the object type */
      filter: string;
    };
    /** @description Error details when resolving access rules for an object type */
    ResolvedAccessRuleError: {
      /** @description The object type of the rule in error */
      objectType: string;
      /** @description The error message */
      message: string;
    };
    ResultOKTeamConfig: {
      result?: components["schemas"]["TeamConfig"];
    };
    RegionConfig: {
      /** @enum {string} */
      region: "au" | "eu" | "us";
      name: string;
      auth0: components["schemas"]["RegionConfigAuth0"];
      server: {
        api: string;
      };
    };
    RegionConfigAuth0: {
      clientId: string;
      audience: string;
      domain: string;
    };
    TeamConfig: {
      region: string;
      team: {
        name: string;
        /** @description The tenant id that belongs to the team. Only returned for a Skedulo cloned team. */
        tenantId?: string;
      };
      auth0: components["schemas"]["TeamConfigAuth0"];
      server: {
        api: string;
        uiPlatform: string;
      };
      newCustomerModel: boolean;
    };
    TeamConfigAuth0: {
      clientId: string;
      audience: string;
      domain: string;
      lock: components["schemas"]["TeamConfigAuth0Lock"];
    };
    TeamConfigAuth0Lock: {
      allowedConnections: string[];
      theme: {
        authButtons: {
          [key: string]: {
            displayName?: string;
          } & {
            authButtons: unknown;
          };
        };
      };
    };
    ResultOKConfig: {
      result?: components["schemas"]["Config"];
    };
    Config: {
      auth0LockConfig: components["schemas"]["Auth0LockConfig"];
      env: components["schemas"]["EnvConfig"];
    };
    Auth0LockConfig: {
      allowedConnections?: string[];
    };
    EnvConfig: {
      apiServer: string;
      auth0ClientId: components["schemas"]["Auth0ClientIdEnv"];
      auth0ClientDomain: string;
      auth0Audience: string;
    };
    Auth0ClientIdEnv: {
      web: string;
      mobile: string;
    };
    ResultOKUserInfo: {
      result?: components["schemas"]["UserInfo"];
    };
    ResultOKAccessRules: {
      result?: components["schemas"]["ResolvedAccessRule"][];
    };
    ResultOKResolvedAccessRules: {
      /** @description Whether all of the supplied rules resolved successfully (i.e. are valid) */
      valid?: boolean;
      /** @description The resolved access rules (one for each object type) */
      accessRules?: components["schemas"]["ResolvedAccessRule"][];
      /** @description Any errors for rules that couldn't be resolved */
      errors?: components["schemas"]["ResolvedAccessRuleError"][];
    };
    ResultOKSFDCOAuthSession: {
      result?: components["schemas"]["SFDCOAuthSession"];
    };
    SFDCOAuthSession: {
      access_token: string;
      instance_url: string;
    };
    UserMetadata: {
      id: string;
      email: string;
      username: string;
      fullName: string;
      firstName?: string;
      lastName: string;
      team: components["schemas"]["TeamMetadata"];
      resource?: components["schemas"]["ResourceMetadata"];
    };
    TeamMetadata: {
      id: string;
      /** @description A valid DNS sub domain */
      name: string;
      /** @description A human friendly name */
      description: string;
      /**
       * @description The vendor associated with this organization
       * @enum {string}
       */
      vendor: "salesforce" | "servicenow" | "skedulo";
      /** @description The vendor specific organization ID */
      orgId: string;
      /** @description The customer name. */
      customer?: string;
    };
    ResourceMetadata: {
      id: string;
      category?: string;
      employmentType?: string;
      address?: string;
      latitude?: number;
      longitude?: number;
      mobilePhone?: string;
      timezone: string;
    };
    ClientCredentialsInstructions: {
      result: {
        /** @description The endpoint to obtain the Skedulo API access token using the body given in authBody. The authorization flow is called client credentials flow. */
        authEndpoint: string;
        /** @description The content of this object should be sent verbatim to the authEndpoint (POST) to obtain a Skedulo API access token. */
        authBody: {
          /** @example client_credentials */
          grant_type: string;
          client_id: string;
          client_secret: string;
          audience: string;
        };
      };
    };
    /** @description Selection of the user claims from the JWT */
    JwtClaims: { [key: string]: unknown };
    ApiTokenInfo: {
      /** @example sk_e0bb1f8aa1924a00b77a9c1f43b09e41 */
      tenantId: string;
      /** @example BM10SHoI4Z4nmhtElInXuJWLkeeqqyzy */
      jti: string;
      claims: components["schemas"]["JwtClaims"];
      /** Format: date-time */
      createdDate: string;
      createdBy: string;
      /** Format: date-time */
      revokedDate?: string;
      revokedBy?: string;
      /** Format: date-time */
      lastUpdated?: string;
    };
  };
}

export interface operations {
  configRegions: {
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": {
            result?: components["schemas"]["RegionConfig"][];
          };
        };
      };
    };
  };
  /** Return server base URLs and web authentication configuration. These server URLs depend on the deployment region of the team and must be used for API requests. */
  configTeamWeb: {
    parameters: {
      query: {
        /** The name of the team */
        name: string;
      };
    };
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKTeamConfig"];
        };
      };
      /** If no team with the given name exists */
      400: unknown;
    };
  };
  configTeamMobile: {
    parameters: {
      query: {
        /** Lookup a specific mobile config for a team given its name */
        name: string;
      };
    };
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKTeamConfig"];
        };
      };
      /** If no team with the given name exists */
      400: unknown;
    };
  };
  configTeamMobileV3: {
    parameters: {
      query: {
        /** Lookup a specific mobile v3 config for a team given its name */
        name: string;
      };
    };
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKTeamConfig"];
        };
      };
      /** If no team with the given name exists */
      400: unknown;
    };
  };
  configTeamWebUser: {
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKTeamConfig"];
        };
      };
      /** If the current user's token is not valid */
      401: unknown;
      /** If the current user does not belong to a team */
      412: unknown;
    };
  };
  configTeamMobileUser: {
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKTeamConfig"];
        };
      };
      /** If the current user's token is not valid */
      401: unknown;
      /** If the current user does not belong to a team */
      412: unknown;
    };
  };
  configTeamMobileV3User: {
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKTeamConfig"];
        };
      };
      /** If the current user's token is not valid */
      401: unknown;
      /** If the current user does not belong to a team */
      412: unknown;
    };
  };
  /** Uses the current url domain or the domain query string if provided. This endpoint is deprecated, use /config/team/web instead. */
  config: {
    parameters: {
      query: {
        /** Lookup a specific domain */
        domain?: string;
      };
    };
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKConfig"];
        };
      };
    };
  };
  /** Return config for a given domain, as well as all the necessary configurations to establish an Auth0 authentication session. This endpoint is deprecated, use /config/team/mobile or /config/team/web instead. */
  authConfig: {
    parameters: {
      query: {
        /** The type of the client e.g. Xamarin mobile app or Phoenix webapp */
        client_type: "xamarin" | "phoenix";
        /** Lookup a specific domain. If not provided, the domain is parsed from Host HTTP header */
        domain?: string;
      };
    };
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": components["schemas"]["AuthConfigResponse"];
        };
      };
    };
  };
  /** Return the access information for a storage provider. */
  delegate: {
    responses: {
      /** The access information was returned */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKSFDCOAuthSession"];
        };
      };
    };
    /** Parameters containing information about the delegation request. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["DelegationParams"];
      };
    };
  };
  /** Return the current user's authentication information */
  whoami: {
    parameters: {
      query: {
        /** Access token. This is an alternative to passing the Authorization: `Bearer` header */
        access_token?: string;
      };
    };
    responses: {
      /** The current users authentication information was returned */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKUserInfo"];
        };
      };
    };
  };
  /** Resolves the supplied rule definitions into valid EQL filters (combining rules by object type, and returning errors for any invalid filter definitions). Requires the useRecordAccessPolicies feature flag. */
  rules_resolve: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKResolvedAccessRules"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          accessRules: components["schemas"]["RecordAccessRule"][];
        };
      };
    };
  };
  /** Return the current user's data access rules. Requires the useRecordAccessPolicies feature flag. */
  rules_user: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResultOKAccessRules"];
        };
      };
    };
  };
  /**
   * The user assigning the API user must be an administrator.
   *
   * >NOTE:
   * >If you make any modifications to the user assigned as the API User, you need to set the user as the API User again to ensure the data stored for the user is up to date. Otherwise, some claims in the access token will be outdated.
   */
  setApiUser: {
    responses: {
      /** The user was successfully setup as the API User. */
      200: {
        content: {
          "*/*": components["schemas"]["ClientCredentialsInstructions"];
        };
      };
      /** If the user is not an administrator */
      403: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Skedulo User ID of the user to be setup as the API User */
          userId: string;
        };
      };
    };
  };
  /** Removes the API User for this tenant if they have one. If the tenant is on Standalone this will reset their API user to the system user. The caller must be an administrator. */
  removeApiUser: {
    responses: {
      /** successful result */
      200: unknown;
      /** If the user is not an administrator */
      403: unknown;
    };
  };
  /** The user requesting this information must be an administrator for their organization. */
  getApiUserClientCredentials: {
    responses: {
      /** Client credentials information of the API user */
      200: {
        content: {
          "*/*": components["schemas"]["ClientCredentialsInstructions"];
        };
      };
      /** User is not an administrator */
      403: unknown;
      /** API user is not setup */
      404: unknown;
    };
  };
  /** List candidates that can be set as the API user and the current API user. Only users with role `administrator` are returned. */
  listApiUserCandidates: {
    responses: {
      /** List of candidates that can be assigned as the API User */
      200: {
        content: {
          "application/json": {
            result: {
              /** @description User ID of the current API User */
              currentApiUserId?: string;
              /** @description True if only a subset of all available candidates is being returned */
              moreCandidatesExist?: boolean;
              candidates: {
                userId: string;
                vendorUserId: string;
                firstName?: string;
                lastName: string;
                username: string;
                resourceId?: string;
                roles: components["schemas"]["Roles"];
                /** Format: email */
                email: string;
                emailVerified: boolean;
              }[];
            };
          };
        };
      };
    };
  };
  verifyApiUser: {
    responses: {
      /** If the result contains success equal to true the API user is verified, otherwise it is not. */
      200: {
        content: {
          "application/json": {
            result: {
              success: boolean;
              code?: string;
              message?: boolean;
              /** @description Additional information about the error */
              extraFields?: { [key: string]: unknown };
            };
          };
        };
      };
    };
  };
  /** Fetch metadata about the current user. */
  metadataUser: {
    responses: {
      /** The current users metadata */
      200: {
        content: {
          "application/json": {
            created?: components["schemas"]["UserMetadata"];
          };
        };
      };
      /** The user belongs to a tenant that is not associated with a team */
      412: unknown;
    };
  };
  /** Find all team names for all users with a provided email, and sends the team names to the email */
  forgotTeamName: {
    responses: {
      /** Some users have been found for the given email, and the team names have been sent to the email */
      200: unknown;
      /** No user found for the given email */
      409: {
        content: {
          "*/*": { [key: string]: unknown };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: email
           * @description The email to search all users by
           */
          email: string;
        };
      };
    };
  };
  /** Links (assigns) a resource to a user by their respective Ids. */
  linkResource: {
    responses: {
      /** User and resource were successfully linked. */
      200: unknown;
      /** The user does not have permission to perform this action. */
      403: unknown;
      /** No user found for the given id. */
      404: {
        content: {
          "*/*": { [key: string]: unknown };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The user id of the user to be linked to given resource */
          userId: string;
          /** @description The resource id of the resource to be linked to given user */
          resourceId: string;
        };
      };
    };
  };
  /** Unlinked a resource to a user by their respective Ids. */
  unlinkResource: {
    responses: {
      /** successful result */
      200: unknown;
      /** The user does not have permission to perform this action. */
      403: unknown;
      /** No user found for the given id. */
      404: {
        content: {
          "*/*": { [key: string]: unknown };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The user id of the user to be linked to given resource */
          user_id: string;
          /** @description The resource id of the resource to be linked to given user */
          resource_id: string;
        };
      };
    };
  };
  /** List all the available and revoked API tokens. */
  fetchAll: {
    responses: {
      /** Return information about all the available and revoked API tokens. */
      200: {
        content: {
          "application/json": {
            result?: components["schemas"]["ApiTokenInfo"][];
          };
        };
      };
    };
  };
  /** Get an API token by specifying its JTI. */
  fetchAllApiTokens: {
    parameters: {
      path: {
        /** The JWT Identifier for the API token */
        jti: string;
      };
    };
    responses: {
      /** Return information about the requested API token */
      200: {
        content: {
          "application/json": {
            result?: components["schemas"]["ApiTokenInfo"];
          };
        };
      };
    };
  };
  /** Create an API token with an optional expiry. This token can be used to authenticate as the same user that created it (with the same claims) for as long as the token is valid. Tokens may be revoked. */
  createApiToken: {
    responses: {
      /** Return the API token */
      200: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: base64
               * @example 5l8l/TyAG+282cBi0JoAp8Gj2WtnXjhxkHKu5J+ytWJcp5kHG9I7k...A==
               */
              token: string;
              /** @example x62ThdBIqHVmILpLKdHbZctTaEzySGGc */
              jti: string;
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: date-time
           * @description Optional expiry. If omitted the token is valid forever.
           */
          expiry?: string;
        };
      };
    };
  };
  /** Revoke an API token so it can no longer be used. The token will be returned but marked as revoked. It cannot be used to authenticate once revoked. */
  revokeToken: {
    responses: {
      /** The token was revoked */
      200: {
        content: {
          "application/json": {
            result: { [key: string]: unknown };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description JWT Identfier of token to revoke */
          jti?: string;
        };
      };
    };
  };
}

export interface external {}

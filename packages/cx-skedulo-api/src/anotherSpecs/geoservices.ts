/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/distanceMatrix": {
    /**
     * The Distance Matrix endpoint computes travel distance and time for all combinations of origin and destination locations, based on the recommended route between start and end points.
     * It should be noted that there are limits on the total number elements that can be requested and that large requests (where origins * destinations > 1000) may take several seconds to satisfy. These limits may vary depending on your underlying configuration.
     */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": components["schemas"]["DistanceMatrixResponse"];
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["DistanceMatrixRequest"];
        };
      };
    };
  };
  "/directions": {
    /** The Directions endpoint calculates directions between source and destination addresses, possibly including multiple waypoints enroute. It returns the recommended travel route (if one can be found), along with estimated travel time and distance. */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": components["schemas"]["DirectionsResponse"];
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["DirectionsRequest"];
        };
      };
    };
  };
  "/geocode": {
    /** For a given list of addreseses, returns a list of geocoded `LatLng`, or errors. */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": components["schemas"]["GeocodeResponse"];
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["GeocodeRequest"];
        };
      };
    };
  };
  "/autocomplete": {
    /** For a given input string, return a list of address suggestions, or error. */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": components["schemas"]["AutoCompleteResponse"];
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AutoCompleteRequest"];
        };
      };
    };
  };
  "/place": {
    /** For a given place Id, return the detailed information for that place. */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": components["schemas"]["PlaceDetail"];
          };
        };
        /** invalid request */
        400: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["PlaceDetailRequest"];
        };
      };
    };
  };
  "/timezone": {
    /** Given a location and timestamp return the timezone name, the offset and Daylight Savings offset. */
    get: {
      parameters: {
        query: {
          /** Latitude and Longitude of the location to find the timezone for */
          location: number[];
          /** Seconds since 1970 for the timezone to return (used to compute DST offset) */
          timestamp: number;
        };
      };
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": components["schemas"]["TimezoneResponse"];
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
  "/invalidate": {
    /** Invalidate the 1 hour TTL cache for distance matrix vendor used for distance matrix requests.  In the instance that the distance matrix vendor is changed via Org Preferences, this endpoint will make that change effective immediately. */
    post: {
      parameters: {};
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": {
              result?: { [key: string]: unknown };
            };
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
}

export interface components {
  schemas: {
    ResultOkDistanceMatrixResponse: {
      result: components["schemas"]["ResultOkDistanceMatrixResponse"];
    };
    ResultOkDirectionsResponse: {
      result: components["schemas"]["ResultOkDirectionsResponse"];
    };
    /**
     * @example [
     *   {
     *     "origins": [
     *       {
     *         "lat": -26.635265,
     *         "lng": 153.067972
     *       }
     *     ],
     *     "destinations": [
     *       {
     *         "lat": -27.457768,
     *         "lng": 153.03583
     *       }
     *     ]
     *   }
     * ]
     */
    DistanceMatrixRequest: {
      /** @description must be non-empty */
      origins: components["schemas"]["LatLng"][];
      /** @description must be non-empty */
      destinations: components["schemas"]["LatLng"][];
    };
    DistanceMatrixResponse: {
      matrix: components["schemas"]["TravelLegResult"][][];
      vendor: components["schemas"]["MapVendor"];
    };
    /** @enum {string} */
    MapVendor: "GOOGLE" | "GRAPHHOPPER" | "LINEOFSIGHT";
    LatLng: {
      /** @description -90 <= y <= 90 */
      lat: number;
      /** @description -180 <= x <= 180 */
      lng: number;
    };
    /** @enum {string} */
    Avoid: "ferry" | "highway" | "toll";
    DirectionsRequest: {
      requests: components["schemas"]["Route"][];
      avoid?: components["schemas"]["Avoid"][];
    };
    DirectionsResponse: {
      routes: components["schemas"]["TravelRoute"][][];
    };
    Route: {
      origin: components["schemas"]["LatLng"];
      destination: components["schemas"]["LatLng"];
      waypoints?: components["schemas"]["LatLng"][];
    };
    TravelRoute: {
      leg: components["schemas"]["Leg"];
      travelInfo: components["schemas"]["TravelLegResult"];
    };
    Leg: {
      origin: components["schemas"]["LatLng"];
      destination: components["schemas"]["LatLng"];
      avoid: components["schemas"]["Avoid"][];
    };
    Duration: {
      durationInSeconds: number;
    };
    Distance: {
      distanceInMeters: number;
    };
    TravelLegResult: {
      /** @enum {string} */
      status: "OK" | "NO_ROUTE";
      duration?: components["schemas"]["Duration"];
      distance?: components["schemas"]["Distance"];
    };
    Error: {
      errorType: string;
      message: string;
    };
    GeocodeRequest: {
      addresses: string[];
      /** @description Return addresses in the given language. Must be a language code. */
      language?: string;
    };
    GeocodeResponse: {
      result?: components["schemas"]["GeocodeResult"][];
    };
    /** @description Either the 'GeocodeSuccess' key or the 'GeocodeFailure' key will be present */
    GeocodeResult: {
      GeocodeSuccess?: components["schemas"]["GeocodeSuccess"];
      GeocodeFailure?: components["schemas"]["GeocodeFailure"];
    };
    GeocodeSuccess: {
      address: string;
      latlng: components["schemas"]["LatLng"];
    };
    GeocodeFailure: {
      address: string;
      reason: components["schemas"]["GeocodeError"];
    };
    GeocodeError: {
      msg: string;
    };
    AutoCompleteRequest: {
      input: string;
      /**
       * Format: uuid
       * @description A caller-generated uuid to signify a session, which consists of multiple autocomplete requests and ends with a place fetch request. A different session should use a different sessionId
       */
      sessionId: string;
      location?: components["schemas"]["LatLng"];
      /** @description A two character, ISO 3166-1 Alpha-2 compatible country code */
      country?: string;
    };
    AutoCompleteResponse: {
      result?: components["schemas"]["AutoCompleteResult"][];
    };
    AutoCompleteResult: {
      predictions: components["schemas"]["AutoCompletePrediction"];
      /** @enum {string} */
      status: "OK" | "ZERO_RESULTS";
      errorMessage?: string;
    };
    AutoCompletePrediction: {
      description: string;
      /** @description Unique id for the suggested place, to be used with fetch place endpoint. */
      placeId: string;
    };
    PlaceDetailRequest: {
      /** @description Unique id for a place in Google system, obtained from autocomplete endpoint. */
      placeId: string;
      /**
       * Format: uuid
       * @description A caller-generated uuid that may have been used in an autocomplete session.
       */
      sessionId: string;
    };
    PlaceDetail: {
      addressComponents: components["schemas"]["AddressComponents"];
      formattedAddress: string;
      geometry: components["schemas"]["LatLng"];
    };
    AddressComponents: {
      streetNumber?: string;
      route?: string;
      locality?: string;
      area2?: string;
      area1?: string;
      country?: string;
      postalCode?: string;
    };
    /**
     * @example {
     *   "dstOffset": 0,
     *   "rawOffset": 36000,
     *   "timeZoneId": "Australia/Brisbane"
     * }
     */
    TimezoneResponse: {
      /** @description The Daylight Savings time offset in seconds or 0 if no Daylight Savings time is in effect. */
      dstOffset?: number;
      /** @description The offset in seconds from UTC for the given location. */
      rawOffset?: number;
      /** @description The id of the time zone, (e.g "Australia/Brisbane" as defined by the Unicode Common Locale Data Repository (CLDR) project. */
      timeZoneId?: string;
    };
  };
}

export interface operations {}

export interface external {}

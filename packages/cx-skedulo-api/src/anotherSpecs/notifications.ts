/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/dispatch": {
    /** This endpoint will dispatch the resources and notify them. */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["DispatchResponse"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: components["requestBodies"]["NotifyRequest"];
    };
  };
  "/notify": {
    /** This endpoint ONLY notifies. */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["DispatchResponse"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: components["requestBodies"]["NotifyRequest"];
    };
  };
  "/notify_cancel": {
    /** This endpoint notifies of cancellations of a job. Does not cause any side affects. */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["DispatchResponse"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["CancelRequest"];
        };
      };
    };
  };
  "/oneoff": {
    post: {
      responses: {
        /** Message sent */
        200: {
          content: {
            "application/json": {
              /**
               * @description protocol the messsage was sent with
               * @enum {string}
               */
              protocol: "push" | "sms";
            };
          };
        };
        /** Message too long or invalid request body */
        400: unknown;
      };
      requestBody: {
        content: {
          "application/json": {
            resourceId: string;
            /** @description Message to send to the resource. Message length is limited to 500 characters */
            message: string;
            /**
             * @description The notification method to use to send the message. If not provided, the resource's default notification method
             * @enum {string}
             */
            protocol?: "push" | "sms";
          };
        };
      };
    };
  };
  "/oneoff/email": {
    post: {
      responses: {
        /** Email sent */
        200: unknown;
        /** Invalid request body */
        400: unknown;
      };
      requestBody: {
        content: {
          "application/json": {
            sender: components["schemas"]["EmailRecipient"] & {
              [key: string]: unknown;
            };
            /** @description The subject/title of the email */
            subject: string;
            /** @description the message body of the email. You can pass a valid HTML and the email will be rendered as such. */
            message: string;
            /** @description List of recipients of the email */
            recipients: components["schemas"]["EmailRecipient"][];
          };
        };
      };
    };
  };
  "/sms": {
    /** Messages are sorted by when they were created in descending order. */
    get: {
      parameters: {
        query: {
          /** Returns messages sent after the message with this cursor */
          cursor?: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: components["schemas"]["SMSSentForTenant"][];
            };
          };
        };
        /** If the user is not an administrator */
        403: unknown;
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /**
     * Send an SMS message to any phone number, such as a customer.
     *
     * For example 'Thanks for confirming your booking'. Replies from the recipient will not be tracked back to a job.
     */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Phone number or country code was invalid, or message was too long */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description The phone number of the recipient. */
            phoneNumber: string;
            /** @description The two character country code of the phone number. */
            countryCode: string;
            /** @description Message to send to the resource. Message length is limited to 500 characters. */
            message: string;
            /**
             * @description Set to true if a reply is expected. The reply should be handled by an external process such as a webhook. If this flag is false or absent and the recipient sends a reply to the message, an error message will be sent back to them.
             * @default false
             */
            expectsReply?: boolean;
          };
        };
      };
    };
  };
  "/sms/confirmation_request": {
    /**
     * Send an SMS message to any phone number, such as a customer, to request confirmation that a job should proceed. This will set the job's confirmation status to `Pending`. Upon receiving a Y/YES or N/NO SMS message from the recipient, the job's confirmation status will be updated accordingly.
     *
     * Note that while a job's confirmation status is `Pending`, SMS confirmation requests cannot be sent to the recipient for that job.
     *
     * Note that a job's confirmation status is for use by custom workflows. It does not affect the normal workflow of the job.
     */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Phone number or country code was invalid, message was too long, phone number already has a request outstanding, job has been completed or cancelled. */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description The phone number of the recipient */
            phoneNumber: string;
            /** @description The two character country code of the phone number */
            countryCode: string;
            /** @description The UID of the job that this message relates to */
            jobId: string;
            /** @description Message to send to the resource. Message length is limited to 500 characters */
            message: string;
          };
        };
      };
    };
  };
  "/confirm/job_id/{job_id}/resource_id/{resource_id}": {
    /** Confirm an allocation given a job/resource */
    put: {
      parameters: {
        path: {
          job_id: string;
          resource_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /** Confirm an allocation given a job/resource. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          job_id: string;
          resource_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AllocationActionTimestamp"];
        };
      };
    };
  };
  "/confirm/allocation_id/{allocation_id}": {
    /** Confirm an allocation given an allocation */
    put: {
      parameters: {
        path: {
          allocation_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /** Confirm an allocation given an allocation ID. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          allocation_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AllocationActionTimestamp"];
        };
      };
    };
  };
  "/decline/job_id/{job_id}/resource_id/{resource_id}": {
    /** Decline a allocation given a job/resource */
    put: {
      parameters: {
        path: {
          job_id: string;
          resource_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /** Decline an allocation given a job/resource. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          job_id: string;
          resource_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AllocationActionTimestamp"];
        };
      };
    };
  };
  "/decline/allocation_id/{allocation_id}": {
    /** Decline an allocation given an allocation */
    put: {
      parameters: {
        path: {
          allocation_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /** Decline an allocation. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          allocation_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["Success"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AllocationActionTimestamp"];
        };
      };
    };
  };
  "/offer/job/resource/{resource_job_offer_id}/accept": {
    /** The offered job will be automatically allocated if the 'autoAllocateJobOffers' org preference is enabled. Schedulers and Admins can accept any offer. Resources can only accept an offer that is assigned to them. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          resource_job_offer_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["SuccessAndStatus"];
          };
        };
        /** Error. */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AllocationActionTimestamp"];
        };
      };
    };
  };
  "/offer/job/resource/{resource_job_offer_id}/decline": {
    /** Closes the offer: after an offer is declined, it cannot be subsequently accepted. Schedulers and Admins can decline any offer. Resources can only decline an offer that is assigned to them. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          resource_job_offer_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["SuccessAndStatus"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AllocationActionTimestamp"];
        };
      };
    };
  };
  "/offer/job/{job_offer_id}/notify": {
    /** Send a notification to some or all resources who have an open offer on the given job. Resources who have declined will not be notified. Each resource's preferred notification method (push or SMS) will be used, if set. If job offer notifications are disabled then no notifications will be sent and an appropriate message will be returned in the response. */
    post: {
      parameters: {
        path: {
          job_offer_id: string;
        };
      };
      responses: {
        /** The results of notifying each resource */
        200: {
          content: {
            "application/json": components["schemas"]["NotifyResponse"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      /** List of Resource Job Offer IDs to notify. This is optional: if not present, all resources will be notified. */
      requestBody: {
        content: {
          "application/json": components["schemas"]["NotifyResources"];
        };
      };
    };
  };
  "/offer/shift/resource/{resource_shift_offer_id}/accept": {
    /** The offered shift will be automatically allocated if the 'autoAllocateShiftOffers' org preference is enabled. Schedulers and Admins can accept any offer. Resources can only accept an offer that is assigned to them. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          resource_shift_offer_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["SuccessAndStatus"];
          };
        };
        /** Error. */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AllocationActionTimestamp"];
        };
      };
    };
  };
  "/offer/shift/resource/{resource_shift_offer_id}/decline": {
    /** Closes the offer: after an offer is declined, it cannot be subsequently accepted. Schedulers and Admins can decline any offer. Resources can only decline an offer that is assigned to them. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          resource_shift_offer_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["SuccessAndStatus"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["AllocationActionTimestamp"];
        };
      };
    };
  };
  "/offer/shift/{shift_offer_id}/notify": {
    /** Send a notification to some or all resources who have an open offer on the given shift. Resources who have declined will not be notified. Each resource's preferred notification method (push or SMS) will be used, if set. */
    post: {
      parameters: {
        path: {
          shift_offer_id: string;
        };
      };
      responses: {
        /** The results of notifying each resource */
        200: {
          content: {
            "application/json": components["schemas"]["NotifyResponse"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      /** List of Resource Shift Offer IDs to notify. This is optional: if not present, all resources will be notified. */
      requestBody: {
        content: {
          "application/json": components["schemas"]["NotifyResources"];
        };
      };
    };
  };
  "/device_id": {
    /** Register a device ID. */
    post: {
      responses: {
        /** Result */
        200: unknown;
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["DeviceIDRequest"];
        };
      };
    };
    /** Delete device ID. */
    delete: {
      responses: {
        /** Result */
        200: unknown;
        /** Device info for this user cannot be found */
        404: unknown;
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
  "/device_info": {
    /** Given a list of resource IDs, retrieves info associated with their ability to be notified via Push or SMS. */
    get: {
      parameters: {
        query: {
          /** IDs of resources to retrieve info on, separated by commas */
          resource_ids: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["DevicesInfo"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
  "/templates": {
    get: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["GetNotificationTemplatesResponse"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
  "/templates/{msgType}": {
    get: {
      parameters: {
        path: {
          msgType: components["parameters"]["MsgType"];
        };
      };
      responses: {
        /** Notification template found */
        200: {
          content: {
            "application/json": {
              result: components["schemas"]["NotificationTemplate"];
            };
          };
        };
        /** Notification template for the given protocol cannot be found */
        404: unknown;
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    post: {
      parameters: {
        path: {
          msgType: components["parameters"]["MsgType"];
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": components["schemas"]["UpsertNotificationTemplateResponse"];
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description New notification template to use for this protocol */
            template?: string;
          };
        };
      };
    };
    /** Delete the notification template associated with a message protocol. Any future messages sent through this protocol will use the default template. */
    delete: {
      parameters: {
        path: {
          msgType: components["parameters"]["MsgType"];
        };
      };
      responses: {
        /** Successfully deleted */
        200: unknown;
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    parameters: {
      path: {
        msgType: components["parameters"]["MsgType"];
      };
    };
  };
  "/v2/templates/defaults": {
    /** Fetch the default values for notification templates. */
    get: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result: components["schemas"]["NotificationTemplateV2Defaults"][];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
  "/v2/templates": {
    get: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result: components["schemas"]["NotificationTemplateV2"][];
              error: components["schemas"]["NotificationTemplateV2Error"][];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
  "/v2/template/{type}/{protocol}": {
    post: operations["templateV2Upsert"];
    /** Delete the notification template associated with a message protocol. Any future messages sent through this protocol will use the default template. */
    delete: {
      parameters: {
        path: {
          type: components["parameters"]["NotificationTemplateType"];
          protocol: components["parameters"]["NotificationTemplateProtocol"];
        };
      };
      responses: {
        /** Successfully deleted */
        200: unknown;
        /** If the user is not an administrator */
        403: unknown;
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    parameters: {
      path: {
        type: components["parameters"]["NotificationTemplateType"];
        protocol: components["parameters"]["NotificationTemplateProtocol"];
      };
    };
  };
  "/logs": {
    /**
     * Fetch the latest 100 notification log entries for the current resource.
     *
     * This endpoint is deprecated; please use the `notifications` GraphQL query instead.
     */
    get: {
      parameters: {
        query: {
          page?: number;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: components["schemas"]["NotificationLogEntry"][];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
}

export interface components {
  schemas: {
    DeviceIDRequest: {
      deviceId: string;
      /** @enum {string} */
      platform: "Skedulo-X-iOS" | "Skedulo-X-Android";
      /** @description This field is optional for backwards compatibility reasons (all features defaults to false if not provided) */
      features?: {
        /** @description Whether this device can has team chat functionality (e.g. can understand push notifications for chat) */
        chat?: boolean;
      };
    };
    DestinationInfo: {
      sms: components["schemas"]["Destination"];
      push: components["schemas"]["Destination"];
    };
    /** @description A mapping from resource ID to device info */
    DevicesInfo: { [key: string]: components["schemas"]["DestinationInfo"] };
    Destination: {
      isValid: boolean;
      errorMsg?: string;
      /** @enum {string} */
      errorKey?:
        | "no_protocol"
        | "invalid_protocol"
        | "invalid_country_code"
        | "invalid_number"
        | "no_device"
        | "no_country_code"
        | "no_number";
    };
    NotifyRequest: {
      jobId: string;
      resourceId?: string;
      resourceIds?: string[];
    };
    CancelRequest: {
      jobId: string;
    };
    DispatchResponse: {
      result?: {
        jobId: string;
        results: components["schemas"]["ResourceResult"][];
      };
    };
    NotifyResources: {
      resourceOfferIds?: string[];
    };
    NotifyResponse: {
      results?: components["schemas"]["ResourceResult"][];
    };
    AllocationActionTimestamp: {
      /** Format: date-time */
      timestamp?: string;
    };
    GetNotificationTemplatesResponse: {
      result?: components["schemas"]["NotificationTemplate"][];
    };
    UpsertNotificationTemplateResponse: {
      result?: components["schemas"]["NotificationTemplate"];
    };
    NotificationTemplate: {
      /** @enum {string} */
      msgType: "sms" | "push";
      /** @description The template string used to generate the notification template */
      template: string;
      /**
       * Format: dateTime
       * @description The date / time the template was created
       */
      createDate: string;
      /**
       * Format: dateTime
       * @description The date / time the template was last modified
       */
      modifyDate: string;
    };
    NotificationTemplateV2Defaults: {
      job_dispatch: components["schemas"]["NotificationTemplateV2Template"];
      job_reminder: components["schemas"]["NotificationTemplateV2Template"];
      job_cancelled: components["schemas"]["NotificationTemplateV2Template"];
      job_offer: components["schemas"]["NotificationTemplateV2Template"];
    };
    NotificationTemplateV2: {
      /** @enum {string} */
      type: "job_dispatch" | "job_reminder" | "job_cancelled" | "job_offer";
      /** @enum {string} */
      protocol: "sms" | "push";
      schema: string;
      template: components["schemas"]["NotificationTemplateV2Template"];
    };
    NotificationTemplateV2Template: {
      text: string;
      parts: components["schemas"]["NotificationTemplateV2Part"][];
    };
    NotificationTemplateV2Part: {
      /** @enum {string} */
      type: "text" | "variable" | "function";
    };
    NotificationTemplateV2PartText: components["schemas"]["NotificationTemplateV2Part"] & {
      value: string;
    };
    NotificationTemplateV2PartVariable: components["schemas"]["NotificationTemplateV2Part"] & {
      value: string;
    };
    NotificationTemplateV2PartFunction: components["schemas"]["NotificationTemplateV2Part"] & {
      /** @enum {string} */
      name: "first";
    };
    NotificationTemplateV2PartFunctionFirst: components["schemas"]["NotificationTemplateV2PartFunction"] & {
      /** @description Non-empty array */
      vars: string[];
      default?: string | null;
    };
    NotificationTemplateV2Error: {
      /** @enum {string} */
      type: "job_dispatch" | "job_reminder" | "job_cancelled" | "job_offer";
      /** @enum {string} */
      protocol: "sms" | "push";
      template: string;
      /** @description A description of the error */
      error: string;
    };
    ResourceResult: {
      resourceId?: string;
      protocol?: string;
      /** @description null if the notification was sent successfully */
      error?: components["schemas"]["Error"];
    };
    Success: {
      /** @default true */
      success?: boolean;
    };
    SuccessAndStatus: {
      /** @default true */
      success?: boolean;
      /** @enum {string} */
      status?: "Accepted" | "Declined" | "Allocated";
    };
    Error: {
      errorType: string;
      message: string;
    };
    SMSSentForTenant: {
      key: {
        vendor: string;
        id: string;
      };
      /** @description E164 phone number that the SMS was sent to */
      to: string;
      /** @description Should be one of the following strings: accepted, delivered, failed, queued, sending, sent, undelivered */
      status: string;
      resourceId?: string | null;
      jobId?: string | null;
      /**
       * Format: date-time
       * @description The time when the SMS was created
       */
      created: string;
      /**
       * Format: date-time
       * @description The time when the SMS last had its status updated
       */
      updated: string;
      /** @description A string to pass as the cursor GET parameter to fetch records that occur after this one */
      cursor: string;
    };
    /**
     * @example {
     *   "name": "John Doe",
     *   "email": "john.doe@company.com"
     * }
     */
    EmailRecipient: {
      /** @description Name of this recipient */
      name?: string;
      /** Format: email */
      email: string;
    };
    NotificationLogEntry: {
      /** Format: date-time */
      timestamp: string;
      /** @description The identifier of the object that the notification was for */
      referenceId: string;
      /** @enum {string} */
      type: "job" | "shift";
    };
    JobNotificationLogEntry: components["schemas"]["NotificationLogEntry"] & {
      /** @enum {string} */
      action: "new" | "cancelled";
      /** Format: date-time */
      start?: string;
      /** Format: date-time */
      end?: string;
      description?: string;
    };
    ShiftNotificationLogEntry: components["schemas"]["NotificationLogEntry"] & {
      /** @enum {string} */
      action: "new" | "changed" | "cancelled";
      /** Format: date-time */
      start: string;
      /** Format: date-time */
      end: string;
    };
  };
  parameters: {
    MsgType: "sms" | "push";
    NotificationTemplateType:
      | "job_dispatch"
      | "job_reminder"
      | "job_cancelled"
      | "job_offer";
    NotificationTemplateProtocol: "sms" | "push";
  };
  requestBodies: {
    NotifyRequest: {
      content: {
        "application/json": components["schemas"]["NotifyRequest"];
      };
    };
  };
}

export interface operations {
  templateV2Upsert: {
    parameters: {
      path: {
        type: components["parameters"]["NotificationTemplateType"];
        protocol: components["parameters"]["NotificationTemplateProtocol"];
      };
    };
    responses: {
      /** Successfully created or updated */
      200: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** Error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description A notification template to use for this protocol. Accepts Mustache style variables that point at schema fields and a small number of Handlebar handlers.
           * @example New {{ Name }}. {{ Start }}. {{first Address "Unknown Address" }}. For {{first Account.Name Contact.FullName "Unknown Customer" }}, {{ Duration }}.
           */
          template?: string;
        };
      };
    };
  };
}

export interface external {}

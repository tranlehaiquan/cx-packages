/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/schedules": {
    /** Get a list of recurring schedules summaries */
    get: operations["listRecurringSchedules"];
  };
  "/schedules/jobs/existing": {
    /** Fields and Child relationships can be specified (e.g. Giving created jobs the same job tags or allocations). By default, required Job fields like Region ID and duration will be propagated even if not specified */
    post: operations["createRecurringScheduleFromExistingJob"];
  };
  "/schedules/{id}": {
    /** Get summary of a recurring schedule */
    get: operations["getSingleRecurringSchedules"];
  };
  "/schedules/jobs/preview": {
    /** Preview the intervals that will be generated for a given recurrence pattern and job details */
    post: operations["preview"];
  };
  "/schedules/jobs": {
    /** Updates the fields and attached objects of jobs in a recurring schedule, where the jobs start at or after the provided timestamp. Arrays of attached 'HasMany' objects can be provided along with the fields to be updated. In this case, all existing attached objects of the same type on future jobs will be deleted and replaced with the provided objects. Job IDs may be explicitly excluded - this allows the caller to prevent modifying the job that they are currently displaying. Jobs that are Locked, In Progress, Completed or Cancelled will not be updated. */
    put: operations["updateJobs"];
    /** Create a recurring schedule from a base job and pattern */
    post: operations["createRecurringSchedule"];
  };
  "/schedules/job_allocations": {
    /** Create or update job allocations for certain resources */
    post: operations["upsertJobAllocations"];
  };
  "/schedules/job_allocations/delete": {
    /** Delete job allocations for certain resources */
    post: operations["deleteJobAllocations"];
  };
}

export interface components {
  schemas: {
    RecurringScheduleSummary: {
      id: string;
      name: string;
      description?: string;
      /** @description Number of jobs in this recurring schedule that have been completed */
      completedJobCount: number;
      /** @description total number of jobs in this recurring schedule (excluding cancelled jobs) */
      allJobCount: number;
      summary?: string;
      /** @description Account ID assigned to jobs of this recurring schedule. Note that this is obtained from the first job that has an Account ID */
      accountId?: string;
      /** @description Contact ID assigned to jobs of this recurring schedule. Note that this is obtained from the first job that has a Contact ID */
      contactId?: string;
      /**
       * Format: date-time
       * @description First occurence of this recurring schedule (first job)
       */
      start?: string;
      /**
       * Format: date-time
       * @description Last occurence of this recurring schedule (last job)
       */
      end?: string;
    };
    /** @description Detailed summary of a recurring schedule, containing information about the jobs in this schedule. Cancelled job are excluded. */
    DetailedRecurringSchedulesSummary: components["schemas"]["RecurringScheduleSummary"] & {
      jobs: components["schemas"]["DetailedJob"][];
      /** @description ID of the next job */
      nextJob?: string;
    };
    DetailedJob: {
      UID: string;
      /** @enum {string} */
      status:
        | "Queued"
        | "Pending Allocation"
        | "Pending Dispatch"
        | "Dispatched"
        | "Ready"
        | "En Route"
        | "On Site"
        | "In Progress"
        | "Complete";
      /** Format: date-time */
      start?: string;
      /** Format: date-time */
      end?: string;
      account?: {
        UID: string;
        name: string;
      };
      contact?: {
        UID: string;
        fullName: string;
        phone?: string;
        email?: string;
      };
      region: {
        UID: string;
        name: string;
      };
    };
    RecurrencePattern: {
      /**
       * @description If the type is 'dates_only', Only 'includeDates' will be used to generate job times
       * @enum {string}
       */
      type: "dates_only" | "rule";
      /**
       * Format: date
       * @description Date the pattern should end on. If using this, do not provide endAfterNumberOccurrences
       * @example 2020-05-13
       */
      endOn?: string;
      /**
       * @description Number of occurrence to generate. If using this, do not provide endOn.
       * Note: when repeatMode is 'weekly', this value means the number of week periods to generate the intervals from,
       * So when endAfterNumberOccurrences = 4, only the next 4 weeks will be checked (some weeks may not generated an interval due
       * to other rules, leading to less than 4 intervals being generated in total)
       *
       * @example 5
       */
      endAfterNumberOccurrences?: number;
      /**
       * @description How occurences are repeated
       * @enum {string}
       */
      repeatMode?: "daily" | "weekly" | "monthly_nth_day" | "yearly";
      /** @description How many days/months/years between each generated interval. For example, with repeatMode = 'daily' and step = 1, an interval will be generated every day */
      step: number;
      /**
       * @description days of the week to skip. If an interval falls on this day of the week, it will be skipped
       * @example [
       *   "mon",
       *   "tue"
       * ]
       */
      skipOnWeekDays?: (
        | "mon"
        | "tue"
        | "wed"
        | "thu"
        | "fri"
        | "sat"
        | "sun"
      )[];
      /** @description The days of week intervals can occur on. Only applies when repeatMode = 'weekly'. */
      repeatOnWeekDays?: (
        | "mon"
        | "tue"
        | "wed"
        | "thu"
        | "fri"
        | "sat"
        | "sun"
      )[];
      /**
       * @description Whether to skip holidays when generating future jobs (Considers both regional and global holidays)
       * @default false
       */
      skipHolidays?: boolean;
      /** @description If true, job allocations for each job will need to be acknowledged by the resource */
      ackAllJobs: boolean;
      /** @description A list of dates a recurring job cannot occur on */
      excludeDates?: string[];
      /** @description A list of dates the job will occur on. This is in addition to all dates generated by the rule and ignores any dates listed in excludeDates */
      includeDates?: string[];
    };
    FieldSpec: {
      /**
       * @example [
       *   "Description",
       *   "RegionId",
       *   "Duration",
       *   "Address",
       *   "AccountId",
       *   "ContactId",
       *   "CanBeDeclined"
       * ]
       */
      fields: string[];
      children?: components["schemas"]["FieldSpec"][];
    };
    /**
     * @description The base job field that will be used to create the recurring schedule. Child objects (e.g. has-many relationship such as JobTags) can also be included -- they will be create and linked with their parent job.
     * Only certain default job fields (see example) are be replicated across the created jobs.
     * To replicate a custom field, lookup or child objects, they need to specified in the baseJob object too (see example).
     *
     * @example {
     *   "Start": "2017-12-23T00:00:00Z",
     *   "RegionId": "a0J28000000TXd3EAG",
     *   "Duration": 30,
     *   "AccountId": "0051I000000hycRQAQ",
     *   "Address": "170 Smith Road",
     *   "CanBeDeclined": true,
     *   "ContactId": "0051I000000hhcRQAQ",
     *   "Description": "description of the job",
     *   "GeoLatitude": 100,
     *   "GeoLongitude": 100,
     *   "LocationId": "0051I000000hycRQAQ",
     *   "Locked": false,
     *   "NotesComments": "a comment on the job",
     *   "Type": "Installation",
     *   "Urgency": "Urgent",
     *   "Quantity": 2,
     *   "MyCustomText": "hello world",
     *   "JobTags": [
     *     {
     *       "TagId": "a0B0K00000XR5bPUAT",
     *       "Required": true
     *     }
     *   ]
     * }
     */
    BaseJob: {
      /**
       * Format: date-time
       * @description Start time of the job which is also the base time / date where the pattern starts generating new jobs from. All generated jobs will have the same clock time as the base job (For example if the first job is at 3pm, all future jobs will occur at 3pm as well)
       */
      Start: string;
      Duration: number;
      /** @description RegionId is used to obtain holidays associated with the region, which are used to avoid creating jobs on regional or global holidays */
      RegionId: string;
    };
  };
}

export interface operations {
  /** Get a list of recurring schedules summaries */
  listRecurringSchedules: {
    parameters: {
      query: {
        /** page number to fetch. Defaults to 1 if not provided. */
        page?: number;
        /** number of items to fetch per page. Defaults to 20 if not provided. Maximum allowed is 50. */
        per_page?: number;
      };
    };
    responses: {
      /** Successful */
      200: {
        content: {
          "application/json": {
            /** @description List of recurring schedule summaries */
            result: {
              /** @description current page. Starts from 1 */
              currentPage: number;
              /** @description total number of pages */
              numPages: number;
              /** @description total number of recurring schedules */
              totalCount: number;
              scheduleSummaries: components["schemas"]["RecurringScheduleSummary"][];
            };
          };
        };
      };
    };
  };
  /** Fields and Child relationships can be specified (e.g. Giving created jobs the same job tags or allocations). By default, required Job fields like Region ID and duration will be propagated even if not specified */
  createRecurringScheduleFromExistingJob: {
    responses: {
      /** Recurring jobs created */
      200: {
        content: {
          "application/json": {
            /** @description ID of the created Recurring Schedule */
            result: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          jobId: string;
          pattern: components["schemas"]["RecurrencePattern"];
          fieldsToPropagate: components["schemas"]["FieldSpec"];
          /**
           * Format: date-time
           * @description Overrides the start time used to generate the jobs. This value is required if the base job does not have a start/end time, and the base job will be updated to have start/end of the first generated interval. If the base job already has a start/end time, its start/end will not be modified.
           * @example 2017-05-17T03:30:00Z
           */
          recurFrom?: string;
        };
      };
    };
  };
  /** Get summary of a recurring schedule */
  getSingleRecurringSchedules: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** Successful */
      200: {
        content: {
          "application/json": {
            result: components["schemas"]["DetailedRecurringSchedulesSummary"];
          };
        };
      };
      /** Recurring schedule with given ID cannot be found */
      404: unknown;
    };
  };
  /** Preview the intervals that will be generated for a given recurrence pattern and job details */
  preview: {
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": {
            /** @description An array of intervals (start/end) in ISO-8061 format (without millisecond part) */
            result: {
              /**
               * Format: date-time
               * @example 2017-05-17T03:30:00Z
               */
              start: string;
              /**
               * Format: date-time
               * @example 2017-05-17T04:30:00Z
               */
              end: string;
            }[];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          pattern: components["schemas"]["RecurrencePattern"];
          baseJob: components["schemas"]["BaseJob"];
        };
      };
    };
  };
  /** Updates the fields and attached objects of jobs in a recurring schedule, where the jobs start at or after the provided timestamp. Arrays of attached 'HasMany' objects can be provided along with the fields to be updated. In this case, all existing attached objects of the same type on future jobs will be deleted and replaced with the provided objects. Job IDs may be explicitly excluded - this allows the caller to prevent modifying the job that they are currently displaying. Jobs that are Locked, In Progress, Completed or Cancelled will not be updated. */
  updateJobs: {
    responses: {
      /** jobs successfully updated */
      200: {
        content: {
          "application/json": {
            /** @description A list of the jobs that were updated with their fields and 'HasMany' object lists. May be an empty array if no jobs were updated due to filtering. */
            result: { [key: string]: unknown }[];
          };
        };
      };
    };
    /** Information about how the jobs will be updated. */
    requestBody: {
      content: {
        "application/json": {
          recurringScheduleId: string;
          /**
           * Format: date-time
           * @description Only apply changes to jobs that start at or after this instant in time.
           * @example 2017-05-17T03:30:00Z
           */
          from: string;
          /**
           * Format: time
           * @description Start time for the jobs. For each job the clock time will be adjusted to match this time. The job date will remain the same as before. If this parameter is not provided, job schedules will not be updated.
           * @example 15:00
           */
          start?: string;
          /** @description A list of job IDs that should not be updated. */
          excludeJobIds?: string[];
          /**
           * @description The new duration for each job in minutes. Must be provided along with "start" if updating job schedule.
           * @example 15
           */
          duration?: number;
          /**
           * @description The fields and values that should be updated on the jobs. Lists of attached 'HasMany' objects can be provided as arrays (e.g. 'JobTasks'). All existing attached objects on future jobs will be deleted and replaced with the provided objects. Any unsupported fields provided (e.g. notifyBy) will not be modified. All custom fields given in this object will be updated.
           * @example {
           *   "Description": "new description",
           *   "JobTasks": [
           *     {
           *       "Seq": 1,
           *       "Name": "Task 1",
           *       "Completed": false
           *     },
           *     {
           *       "Seq": 2,
           *       "Name": "Task 2",
           *       "Completed": false
           *     }
           *   ]
           * }
           */
          jobFields: { [key: string]: unknown };
        };
      };
    };
  };
  /** Create a recurring schedule from a base job and pattern */
  createRecurringSchedule: {
    responses: {
      /** Successful */
      200: {
        content: {
          "application/json": {
            /** @description ID of the created recurring schedule */
            result: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          baseJob: components["schemas"]["BaseJob"];
          pattern: components["schemas"]["RecurrencePattern"];
        };
      };
    };
  };
  /** Create or update job allocations for certain resources */
  upsertJobAllocations: {
    responses: {
      /** Jobs allocations has been successfully created or updated. */
      200: {
        content: {
          "application/json": {
            /** @description A list of job allocation IDs that were created or updated. */
            result: {
              inserted: string[];
              updated: string[];
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: date-time
           * @description Only create/update job allocations for jobs that start after this instant in time.
           * @example 2017-05-17T03:30:00Z
           */
          from: string;
          recurringScheduleId: string;
          /** @description Skip updating any job allocations that are attached to these job identifiers. */
          excludeJobIds?: string[];
          /**
           * @description ID of the resources of which job allocations will be created or updated for. Any existing job allocations not belonging to these resources will not be modified.
           * @example [
           *   "res_1",
           *   "res_2"
           * ]
           */
          resourceIds: string[];
          /**
           * @description A JSON object containing fields for the job allocation to create. Existing job allocations will be updated too.
           * @example {
           *   "Hours": 5,
           *   "NotificationType": "push"
           * }
           */
          jobAllocBase: { [key: string]: unknown };
        };
      };
    };
  };
  /** Delete job allocations for certain resources */
  deleteJobAllocations: {
    responses: {
      /** Job allocations deleted */
      200: {
        content: {
          "application/json": {
            /**
             * @description A list of jobs and their job allocations that were deleted
             * @example {
             *   "job_1": [
             *     "job_alloc_1",
             *     "job_alloc_2"
             *   ],
             *   "job_2": [
             *     "job_alloc_3"
             *   ]
             * }
             */
            result: { [key: string]: unknown };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: date-time
           * @description Only delete job allocations for jobs that start after this instant
           * @example 2017-05-17T03:30:00Z
           */
          from: string;
          recurringScheduleId: string;
          /**
           * @description ID of the resources of which job allocations will be deleted.
           * @example [
           *   "res_1",
           *   "res_2"
           * ]
           */
          resourceIds: string[];
        };
      };
    };
  };
}

export interface external {}

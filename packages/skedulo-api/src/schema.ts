/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/auth/whoami": {
    /** Return the current user's authentication information */
    get: operations["whoami"];
  };
  "/auth/access_rules": {
    /** Return the current user's data access rules. Requires the useRecordAccessPolicies feature flag. */
    get: operations["access_rules"];
  };
  "/auth/api_user": {
    /**
     * The user assigning the API user must be an administrator.
     *
     * >NOTE:
     * >If you make any modifications to the user assigned as the API User, you need to set the user as the API User again to ensure the data stored for the user is up to date. Otherwise, some claims in the access token will be outdated.
     */
    post: operations["setApiUser"];
    /** Removes the API User for this tenant if they have one. If the tenant is on Standalone this will reset their API user to the system user. The caller must be an administrator. */
    delete: operations["removeApiUser"];
  };
  "/auth/api_user/client_credentials": {
    /** The user requesting this information must be an administrator for their organization. */
    get: operations["getApiUserClientCredentials"];
  };
  "/auth/api_user/candidates": {
    /** List candidates that can be set as the API user and the current API user. Only users with role `administrator` are returned. */
    get: operations["listApiUserCandidates"];
  };
  "/auth/api_user/verify": {
    get: operations["verifyApiUser"];
  };
  "/auth/metadata/user": {
    /** Fetch metadata about the current user. */
    get: operations["metadataUser"];
  };
  "/auth/link_resource": {
    /** Links (assigns) a resource to a user by their respective Ids. */
    post: operations["linkResource"];
    /** Unlinked a resource to a user by their respective Ids. */
    delete: operations["unlinkResource"];
  };
  "/auth/tokens": {
    /** List all the available and revoked API tokens. */
    get: operations["fetchAll"];
  };
  "/auth/token/{jti}": {
    /** Get an API token by specifying its JTI. */
    get: operations["fetchAllApiTokens"];
  };
  "/auth/token": {
    /** Create an API token with an optional expiry. This token can be used to authenticate as the same user that created it (with the same claims) for as long as the token is valid. Tokens may be revoked. */
    post: operations["createApiToken"];
  };
  "/auth/token/revoke": {
    /** Revoke an API token so it can no longer be used. The token will be returned but marked as revoked. It cannot be used to authenticate once revoked. */
    post: operations["revokeToken"];
  };
  "/custom/permissions": {
    get: operations["fetchPermissions"];
  };
  "/standalone/permissions/role": {
    /** Fetch the default permissions and custom permissions for each role */
    get: operations["rolePermissions"];
  };
  "/standalone/permissions/role/{role}": {
    /** To remove a single object or field override pass `null` as the value. */
    post: operations["rolePermissionsSet"];
    delete: operations["rolePermissionsDelete"];
    parameters: {
      path: {
        /** Name of the role */
        role: string;
      };
    };
  };
  "/notifications/dispatch": {
    /** This endpoint will dispatch the resources and notify them. */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: {
                jobId: string;
                results: {
                  resourceId?: string;
                  protocol?: string;
                  /** @description null if the notification was sent successfully */
                  error?: {
                    errorType: string;
                    message: string;
                  };
                }[];
              };
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            jobId: string;
            resourceId?: string;
            resourceIds?: string[];
          };
        };
      };
    };
  };
  "/notifications/notify": {
    /** This endpoint ONLY notifies. */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: {
                jobId: string;
                results: {
                  resourceId?: string;
                  protocol?: string;
                  /** @description null if the notification was sent successfully */
                  error?: {
                    errorType: string;
                    message: string;
                  };
                }[];
              };
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            jobId: string;
            resourceId?: string;
            resourceIds?: string[];
          };
        };
      };
    };
  };
  "/notifications/notify_cancel": {
    /** This endpoint notifies of cancellations of a job. Does not cause any side affects. */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: {
                jobId: string;
                results: {
                  resourceId?: string;
                  protocol?: string;
                  /** @description null if the notification was sent successfully */
                  error?: {
                    errorType: string;
                    message: string;
                  };
                }[];
              };
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            jobId: string;
          };
        };
      };
    };
  };
  "/notifications/oneoff": {
    post: {
      responses: {
        /** Message sent */
        200: {
          content: {
            "application/json": {
              /**
               * @description protocol the messsage was sent with
               * @enum {string}
               */
              protocol: "push" | "sms";
            };
          };
        };
        /** Message too long or invalid request body */
        400: unknown;
      };
      requestBody: {
        content: {
          "application/json": {
            resourceId: string;
            /** @description Message to send to the resource. Message length is limited to 500 characters */
            message: string;
            /**
             * @description The notification method to use to send the message. If not provided, the resource's default notification method
             * @enum {string}
             */
            protocol?: "push" | "sms";
          };
        };
      };
    };
  };
  "/notifications/sms": {
    /** Messages are sorted by when they were created in descending order. */
    get: {
      parameters: {
        query: {
          /** Returns messages sent after the message with this cursor */
          cursor?: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: {
                key: {
                  vendor: string;
                  id: string;
                };
                /** @description E164 phone number that the SMS was sent to */
                to: string;
                /** @description Should be one of the following strings: accepted, delivered, failed, queued, sending, sent, undelivered */
                status: string;
                resourceId?: string | null;
                jobId?: string | null;
                /**
                 * Format: date-time
                 * @description The time when the SMS was created
                 */
                created: string;
                /**
                 * Format: date-time
                 * @description The time when the SMS last had its status updated
                 */
                updated: string;
                /** @description A string to pass as the cursor GET parameter to fetch records that occur after this one */
                cursor: string;
              }[];
            };
          };
        };
        /** If the user is not an administrator */
        403: unknown;
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
    /**
     * Send an SMS message to any phone number, such as a customer.
     *
     * For example 'Thanks for confirming your booking'. Replies from the recipient will not be tracked back to a job.
     */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Phone number or country code was invalid, or message was too long */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description The phone number of the recipient. */
            phoneNumber: string;
            /** @description The two character country code of the phone number. */
            countryCode: string;
            /** @description Message to send to the resource. Message length is limited to 500 characters. */
            message: string;
            /**
             * @description Set to true if a reply is expected. The reply should be handled by an external process such as a webhook. If this flag is false or absent and the recipient sends a reply to the message, an error message will be sent back to them.
             * @default false
             */
            expectsReply?: boolean;
          };
        };
      };
    };
  };
  "/notifications/sms/confirmation_request": {
    /**
     * Send an SMS message to any phone number, such as a customer, to request confirmation that a job should proceed. This will set the job's confirmation status to `Pending`. Upon receiving a Y/YES or N/NO SMS message from the recipient, the job's confirmation status will be updated accordingly.
     *
     * Note that while a job's confirmation status is `Pending`, SMS confirmation requests cannot be sent to the recipient for that job.
     *
     * Note that a job's confirmation status is for use by custom workflows. It does not affect the normal workflow of the job.
     */
    post: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Phone number or country code was invalid, message was too long, phone number already has a request outstanding, job has been completed or cancelled. */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description The phone number of the recipient */
            phoneNumber: string;
            /** @description The two character country code of the phone number */
            countryCode: string;
            /** @description The UID of the job that this message relates to */
            jobId: string;
            /** @description Message to send to the resource. Message length is limited to 500 characters */
            message: string;
          };
        };
      };
    };
  };
  "/notifications/confirm/job_id/{job_id}/resource_id/{resource_id}": {
    /** Confirm an allocation given a job/resource */
    put: {
      parameters: {
        path: {
          job_id: string;
          resource_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
    /** Confirm an allocation given a job/resource. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          job_id: string;
          resource_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
    };
  };
  "/notifications/confirm/allocation_id/{allocation_id}": {
    /** Confirm an allocation given an allocation */
    put: {
      parameters: {
        path: {
          allocation_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
    /** Confirm an allocation given an allocation ID. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          allocation_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
    };
  };
  "/notifications/decline/job_id/{job_id}/resource_id/{resource_id}": {
    /** Decline a allocation given a job/resource */
    put: {
      parameters: {
        path: {
          job_id: string;
          resource_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
    /** Decline an allocation given a job/resource. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          job_id: string;
          resource_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
    };
  };
  "/notifications/decline/allocation_id/{allocation_id}": {
    /** Decline an allocation given an allocation */
    put: {
      parameters: {
        path: {
          allocation_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
    /** Decline an allocation. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          allocation_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
    };
  };
  "/notifications/offer/job/resource/{resource_job_offer_id}/accept": {
    /** The offered job will be automatically allocated if the 'autoAllocateJobOffers' org preference is enabled. Schedulers and Admins can accept any offer. Resources can only accept an offer that is assigned to them. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          resource_job_offer_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
              /** @enum {string} */
              status?: "Accepted" | "Declined" | "Allocated";
            };
          };
        };
        /** Error. */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
    };
  };
  "/notifications/offer/job/resource/{resource_job_offer_id}/decline": {
    /** Closes the offer: after an offer is declined, it cannot be subsequently accepted. Schedulers and Admins can decline any offer. Resources can only decline an offer that is assigned to them. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          resource_job_offer_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
              /** @enum {string} */
              status?: "Accepted" | "Declined" | "Allocated";
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
    };
  };
  "/notifications/offer/job/{job_offer_id}/notify": {
    /** Send a notification to some or all resources who have an open offer on the given job. Resources who have declined will not be notified. Each resource's preferred notification method (push or SMS) will be used, if set. If job offer notifications are disabled then no notifications will be sent and an appropriate message will be returned in the response. */
    post: {
      parameters: {
        path: {
          job_offer_id: string;
        };
      };
      responses: {
        /** The results of notifying each resource */
        200: {
          content: {
            "application/json": {
              results?: {
                resourceId?: string;
                protocol?: string;
                /** @description null if the notification was sent successfully */
                error?: {
                  errorType: string;
                  message: string;
                };
              }[];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      /** List of Resource Job Offer IDs to notify. This is optional: if not present, all resources will be notified. */
      requestBody: {
        content: {
          "application/json": {
            resourceOfferIds?: string[];
          };
        };
      };
    };
  };
  "/notifications/offer/shift/resource/{resource_shift_offer_id}/accept": {
    /** The offered shift will be automatically allocated if the 'autoAllocateShiftOffers' org preference is enabled. Schedulers and Admins can accept any offer. Resources can only accept an offer that is assigned to them. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          resource_shift_offer_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
              /** @enum {string} */
              status?: "Accepted" | "Declined" | "Allocated";
            };
          };
        };
        /** Error. */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
    };
  };
  "/notifications/offer/shift/resource/{resource_shift_offer_id}/decline": {
    /** Closes the offer: after an offer is declined, it cannot be subsequently accepted. Schedulers and Admins can decline any offer. Resources can only decline an offer that is assigned to them. Stores the time the response was sent as either the given timestamp or the current time if a time is not provided. */
    post: {
      parameters: {
        path: {
          resource_shift_offer_id: string;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              /** @default true */
              success?: boolean;
              /** @enum {string} */
              status?: "Accepted" | "Declined" | "Allocated";
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
    };
  };
  "/notifications/offer/shift/{shift_offer_id}/notify": {
    /** Send a notification to some or all resources who have an open offer on the given shift. Resources who have declined will not be notified. Each resource's preferred notification method (push or SMS) will be used, if set. */
    post: {
      parameters: {
        path: {
          shift_offer_id: string;
        };
      };
      responses: {
        /** The results of notifying each resource */
        200: {
          content: {
            "application/json": {
              results?: {
                resourceId?: string;
                protocol?: string;
                /** @description null if the notification was sent successfully */
                error?: {
                  errorType: string;
                  message: string;
                };
              }[];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      /** List of Resource Shift Offer IDs to notify. This is optional: if not present, all resources will be notified. */
      requestBody: {
        content: {
          "application/json": {
            resourceOfferIds?: string[];
          };
        };
      };
    };
  };
  "/notifications/device_id": {
    /** Register a device ID. */
    post: {
      responses: {
        /** Result */
        200: unknown;
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            deviceId: string;
            /** @enum {string} */
            platform: "Skedulo-X-iOS" | "Skedulo-X-Android";
            /** @description This field is optional for backwards compatibility reasons (all features defaults to false if not provided) */
            features?: {
              /** @description Whether this device can has team chat functionality (e.g. can understand push notifications for chat) */
              chat?: boolean;
            };
          };
        };
      };
    };
    /** Delete device ID. */
    delete: {
      responses: {
        /** Result */
        200: unknown;
        /** Device info for this user cannot be found */
        404: unknown;
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
  };
  "/notifications/templates": {
    get: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: {
                /** @enum {string} */
                msgType: "sms" | "push";
                /** @description The template string used to generate the notification template */
                template: string;
                /**
                 * Format: dateTime
                 * @description The date / time the template was created
                 */
                createDate: string;
                /**
                 * Format: dateTime
                 * @description The date / time the template was last modified
                 */
                modifyDate: string;
              }[];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
  };
  "/notifications/templates/{msgType}": {
    get: {
      parameters: {
        path: {
          msgType: "sms" | "push";
        };
      };
      responses: {
        /** Notification template found */
        200: {
          content: {
            "application/json": {
              result: {
                /** @enum {string} */
                msgType: "sms" | "push";
                /** @description The template string used to generate the notification template */
                template: string;
                /**
                 * Format: dateTime
                 * @description The date / time the template was created
                 */
                createDate: string;
                /**
                 * Format: dateTime
                 * @description The date / time the template was last modified
                 */
                modifyDate: string;
              };
            };
          };
        };
        /** Notification template for the given protocol cannot be found */
        404: unknown;
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
    post: {
      parameters: {
        path: {
          msgType: "sms" | "push";
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: {
                /** @enum {string} */
                msgType: "sms" | "push";
                /** @description The template string used to generate the notification template */
                template: string;
                /**
                 * Format: dateTime
                 * @description The date / time the template was created
                 */
                createDate: string;
                /**
                 * Format: dateTime
                 * @description The date / time the template was last modified
                 */
                modifyDate: string;
              };
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description New notification template to use for this protocol */
            template?: string;
          };
        };
      };
    };
    /** Delete the notification template associated with a message protocol. Any future messages sent through this protocol will use the default template. */
    delete: {
      parameters: {
        path: {
          msgType: "sms" | "push";
        };
      };
      responses: {
        /** Successfully deleted */
        200: unknown;
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
    parameters: {
      path: {
        msgType: "sms" | "push";
      };
    };
  };
  "/notifications/v2/templates/defaults": {
    /** Fetch the default values for notification templates. */
    get: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result: {
                job_dispatch: {
                  text: string;
                  parts: {
                    /** @enum {string} */
                    type: "text" | "variable" | "function";
                  }[];
                };
                job_reminder: {
                  text: string;
                  parts: {
                    /** @enum {string} */
                    type: "text" | "variable" | "function";
                  }[];
                };
                job_cancelled: {
                  text: string;
                  parts: {
                    /** @enum {string} */
                    type: "text" | "variable" | "function";
                  }[];
                };
                job_offer: {
                  text: string;
                  parts: {
                    /** @enum {string} */
                    type: "text" | "variable" | "function";
                  }[];
                };
              }[];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
  };
  "/notifications/v2/templates": {
    get: {
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result: {
                /** @enum {string} */
                type:
                  | "job_dispatch"
                  | "job_reminder"
                  | "job_cancelled"
                  | "job_offer";
                /** @enum {string} */
                protocol: "sms" | "push";
                schema: string;
                template: {
                  text: string;
                  parts: {
                    /** @enum {string} */
                    type: "text" | "variable" | "function";
                  }[];
                };
              }[];
              error: {
                /** @enum {string} */
                type:
                  | "job_dispatch"
                  | "job_reminder"
                  | "job_cancelled"
                  | "job_offer";
                /** @enum {string} */
                protocol: "sms" | "push";
                template: string;
                /** @description A description of the error */
                error: string;
              }[];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
  };
  "/notifications/v2/template/{type}/{protocol}": {
    post: operations["templateV2Upsert"];
    /** Delete the notification template associated with a message protocol. Any future messages sent through this protocol will use the default template. */
    delete: {
      parameters: {
        path: {
          type: "job_dispatch" | "job_reminder" | "job_cancelled" | "job_offer";
          protocol: "sms" | "push";
        };
      };
      responses: {
        /** Successfully deleted */
        200: unknown;
        /** If the user is not an administrator */
        403: unknown;
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
    parameters: {
      path: {
        type: "job_dispatch" | "job_reminder" | "job_cancelled" | "job_offer";
        protocol: "sms" | "push";
      };
    };
  };
  "/notifications/logs": {
    /**
     * Fetch the latest 100 notification log entries for the current resource.
     *
     * This endpoint is deprecated; please use the `notifications` GraphQL query instead.
     */
    get: {
      parameters: {
        query: {
          page?: number;
        };
      };
      responses: {
        /** Result */
        200: {
          content: {
            "application/json": {
              result?: {
                /** Format: date-time */
                timestamp: string;
                /** @description The identifier of the object that the notification was for */
                referenceId: string;
                /** @enum {string} */
                type: "job" | "shift";
              }[];
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
  };
  "/resource_tracking/location/latest": {
    /** The latest locations endpoint returns information about the **resource's** latest location. It is a map from resourceId to latest location. */
    get: operations["locationLatest"];
  };
  "/resource_tracking/location/history": {
    /**
     * The Location history end point allows you to retrieve the location history for a resource.
     * The default limit is 100 results.
     */
    get: operations["locationHistory"];
  };
  "/resource_tracking/location/update": {
    /**
     * The location update endpoint allows one or more position updates to be provided indicating a resource's location.
     *
     * The resource is determined by the Java Web Token provided. It is not possible for users other than the logged in user to update a resources position.
     */
    post: operations["locationUpdate"];
  };
  "/resource_tracking/location/resources_within_distance": {
    /** Locate all resources within a set distance of a specified location. */
    get: operations["locationResourcesWithinDistance"];
  };
  "/resource_tracking/travel/routes": {
    /**
     * Given a comma-separated list of resource Ids and a start and end date, return the route taken by that resource between the start and end time.
     *
     * The maximum amount of time supported is 24 hours.
     *
     * The supported formats are
     * * _polyline_ Uses the Google Maps Polyline encoding (default)
     * * _wkt_ - Well Known Text Strings.  Either a LINESTRING or a POINT is returned
     * * _geojson_ - GeoJSON format. Either a linestring or a point is returned
     */
    get: operations["travelRoutes"];
  };
  "/planr/optimize/suggest": {
    /**
     * Query the `/optimize/suggest` endpoint to find the best time to schedule a single job given a set of resources within a specific time range.
     *
     * For example, if a job must be done on Thursday before noon you can specify the time window of 8AM to 12PM on Thursday and the resources that are available to find the best time to schedule the job that morning.
     */
    post: operations["suggest"];
  };
  "/planr/optimize/resource_suggestions": {
    /**
     * Find the best resources within a given time range, for a given job and resource availabilities.
     *
     * This query provides the amount of time each resource has available during the time period to complete the task.
     */
    post: operations["/optimize/resource_suggestions"];
  };
  "/planr/grid/schedule": {
    /**
     * Splits a given time window into intervals of grid size; then aggregates resource availability into it, against the given job. Availability is determined by working hours, holidays, existing jobs and activities. Resource must be available for the entire duration of the slot to be returned in the list.
     *
     * Use the `/grid/schedule` endpoint to find all of the available time slots for a job to be completed during a specified time window. For example, if a job must be completed by the close of business the following day, you can query the `/grid/schedule` endpoint to obtain an aggregate of resource availability between now and tomorrow afternoon at 5PM.
     *
     * The query splits the time window into intervals to determine which resources are available at different times during the time window for the job.
     *
     * * Resource availability is determined by working hours, holidays, existing jobs, shifts, and activities.
     * * Resources must be available for the entire duration of the job slot to be returned in the list.
     */
    post: operations["/grid/schedule"];
  };
  "/planr/optimize/schedule": {
    /**
     * This API attempts to schedule jobs against a given list of resources and returns a valid schedule. You can use this endpoint to specify availability windows for resources who are available outside the scheduling window for the job/s you want to schedule. This prevents Planr from returning invalid solutions and provides an extra layer of flexibility in optimized job scheduling.
     *
     * `POST` request for `/optimize/schedule` must include either the `resources` or `resourceIds` property in the body.
     *
     * * The `resourceIds` property is an array.
     * * The `resources` property is an object containing the resource ID along with the working hours start and end timestamp.
     */
    post: operations["/optimize/schedule"];
  };
  "/planr/geoservices/travel-time": {
    /** The Travel Time endpoint will approximate how long it takes for a resource to travel between destinations. It will filter down to relevant availability windows (ignoring destinations outside the resource's availability), order the work to be completed, and finally calculate the travel time between each destination. The result will contain only the node identifier and the relevant travel time. */
    post: operations["/geoservices/travel-time"];
  };
  "/optimization/batch/schedule": {
    get: operations["batchSchedulesList"];
    post: operations["batchScheduleCreate"];
  };
  "/optimization/batch/schedule/{schedule_id}": {
    get: operations["batchScheduleGet"];
    put: operations["batchscheduleUpsert"];
    delete: operations["batchScheduleDelete"];
  };
  "/optimization/schedule": {
    /**
     * This API attempts to schedule jobs against a given list of resources and returns a valid schedule.
     * You can use this endpoint to specify availability windows for resources who are available outside the scheduling
     * window for the job/s you want to schedule. This prevents the optimizer from returning invalid solutions and
     * provides an extra layer of flexibility in optimized job scheduling.
     */
    post: operations["schedule"];
  };
  "/optimization/schedule/run/{run_id}/save": {
    get: operations["getRunSave"];
    post: operations["saveRun"];
  };
  "/optimization/schedule/run/{run_id}/save/reject": {
    /** Reject the run save. Saved or failed run cannot be rejected. */
    post: operations["rejectRun"];
  };
  "/optimization/run": {
    get: operations["getRuns"];
  };
  "/optimization/run/{run_id}": {
    get: operations["getOptimizationResult"];
  };
  "/graphql": {
    /**
     * Run queries and mutations against the schema using the `/graphql/graphql` endpoint.
     *
     * Queries and mutations are `POST` operations with a GraphQL payload that defines shape of the query or mutation you want to make against the schema. A mutation with multiple operations is executed as an atomic transaction.
     *
     * The response may include standard Skedulo objects and custom objects and fields you have defined.
     *
     * To improve the performance of query operations on Skedulo Platform, set the header X-Skedulo-Read-Only=true. This will execute against a read replica database and will produce an error if any write operation is attempted. Beware of race conditions - there may be a small delay between a write being executed and the data being available on the read replica.
     */
    post: operations["graphql"];
  };
  "/graphql/batch": {
    /**
     * GraphQL batching involves sending multiple queries or mutations to the server in a single request. This reduces the number of server round trips to fetch data, which makes interaction more efficient.
     *
     * See https://blog.apollographql.com/query-batching-in-apollo-63acfd859862 for more information
     */
    post: operations["graphqlBatch"];
  };
  "/subscriptions": {
    /**
     * GraphQL Subscriptions via Apollo `graphql-ws` protocol.
     *
     * * Your tenant must have an API user.
     *
     * * You must be a 'Scheduler' or 'Administrator'.
     *
     * The `Authorization` header must be passed in the `connection_init` message.
     */
    get: operations["graphqlSubscriptions"];
  };
  "/schema": {
    /** Retrieve the Skedulo GraphQL schema. */
    get: operations["graphqlSchema"];
  };
  "/webhooks/graphql": {
    /** Perform an introspection query against the GraphQL query that is used for webhooks with type `graphql`. */
    post: operations["webhookGraphQLQuery"];
  };
  "/webhooks/deferred/graphql": {
    /** Perform an introspection query against the GraphQL query that is used for webhooks with type `graphql_deferred`. */
    post: operations["webhookDeferredGraphQLQuery"];
  };
  "/webhooks": {
    /** Fetch all existing webhooks. */
    get: operations["webhooksFetch"];
    /** Establish a new webhook. */
    post: operations["webhooksCreate"];
  };
  "/webhooks/{id}": {
    /** Delete a webhook using the webhook ID. */
    delete: operations["webhooksDelete"];
  };
  "/triggered_actions": {
    get: operations["triggeredActionsFetch"];
    post: operations["triggeredActionCreate"];
  };
  "/triggered_actions/{id}": {
    delete: operations["triggeredActionDelete"];
    /** Note that the type of the trigger and the action cannot be changed. */
    patch: operations["triggeredActionUpdate"];
  };
  "/triggered_actions/logs": {
    /** Return the status and details of webhooks and triggered actions. Results are ordered by ascending log ID. */
    get: operations["triggeredActionLogs"];
  };
  "/availability": {
    /** Fetch resource availability between a time period. */
    get: operations["getAvailability"];
  };
  "/availability/simple": {
    /** Fetch resource availability between a time period in a simplified format. */
    get: operations["getAvailabilitySimple"];
  };
  "/availability/resources": {
    /** Fetch available resources for given criteria in a time period. Must specify at least one of `resourceIds` or `regionIds`. Note that the `regionIds` filter only restricts the list of resources to query the availabilities for; resource availability is global, there is no concept of per-region availability in the system. */
    post: operations["postAvailableResources"];
  };
  "/availability/patterns": {
    /**
     * This endpoint will validate then create/update availability patterns and the related resources.
     *
     * If a UID is present on the pattern it will update, otherwise it will create.
     */
    post: {
      responses: {
        /** successful update */
        200: {
          content: {
            "application/json": {
              /** Format: uuid */
              result?: string;
            };
          };
        };
        /** successful insert */
        201: {
          content: {
            "application/json": {
              /** Format: uuid */
              created?: string;
            };
          };
        };
        /** Error */
        default: {
          content: {
            "application/json":
              | {
                  /** @description The type of the error. */
                  error_type: unknown;
                  /** @description A brief about the error result. */
                  message: unknown;
                  /** @description A detailed error of what is wrong with the pattern. */
                  pattern: (
                    | {
                        /** @description The UID of the missing pattern. */
                        "pattern-not-found"?: string;
                      }
                    | {
                        /** @description A list of errors */
                        "insert-failed"?: {
                          /** @description The error code. */
                          code: string;
                          /** @description The error message. */
                          message: string;
                        }[];
                      }
                    | {
                        "update-failed"?: {
                          /** @description A list of errors encountered when updating. */
                          errors?: {
                            /** @description The error code. */
                            code: string;
                            /** @description The error message. */
                            message: string;
                          }[];
                          /** @description The UID of the pattern. */
                          UID?: string;
                        };
                      }
                    | {
                        /** @description Contains the message of the error. */
                        "too-many-update-results"?: string;
                      }
                  )[];
                  resources: (
                    | {
                        /** @description The UID of the pattern-resource relationship. */
                        "pattern-resource-not-found"?: string;
                      }
                    | {
                        "insert-failed"?: {
                          /** @description A list of errors. */
                          errors?: {
                            /** @description The error code. */
                            code: string;
                            /** @description The error message. */
                            message: string;
                          }[];
                          /** @description The list or resource UIDs the errors relate to. */
                          resources?: string[];
                        };
                      }
                    | {
                        "update-failed"?: {
                          /** @description A list of errors encountered when updating. */
                          errors?: {
                            /** @description The error code. */
                            code: string;
                            /** @description The error message. */
                            message: string;
                          }[];
                          /** @description The UID of the pattern. */
                          UID?: string;
                        };
                      }
                    | {
                        "insert-failed"?: {
                          /** @description The lis of errors received when attempt to update pattern resources. */
                          errors?: string[];
                          /** @description A list of IDs for the related pattern resources. */
                          UIDs?: string[];
                          /** @description A list of resource IDs that were used during the update. */
                          resources?: string[];
                        };
                      }
                  )[];
                }
              | {
                  /**
                   * @description A consistent string that contains the type of error.
                   * @example pattern_error
                   */
                  errorType?: string;
                  /**
                   * @description Further details about the error that occurred.
                   * @example Invalid availability pattern JSON:
                   *   - Monday: Intervals must be provided.
                   */
                  message?: string;
                  /**
                   * @description When the error is with the parsing the JSON, path is returned with the errored path.
                   * @example .pattern
                   */
                  path?: string;
                }[];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description The pattern of availabilities to determine availability. */
            pattern?: {
              /** Format: uuid */
              UID?: string;
              name?: string;
              description?: string;
              pattern?:
                | ({
                    /** @enum {string} */
                    type: "custom" | "weekly";
                  } & {
                    /**
                     * @description The length of the pattern in days, must be a positive integer.
                     * @example 5
                     */
                    lengthDays: number;
                    /** @description Days that make up the pattern. Days can be specified in any order. A day with the same index cannot appear more than once. It is allowed to have holes in the pattern. The number of days specified must be less than or equal to the lengthDays property. */
                    days: {
                      /**
                       * @description The N-th number of day in the pattern. The index is 1-based (the first day of the pattern is day 1).
                       * @example 1
                       */
                      day?: number;
                      /** @description A list of time intervals that determine when a resource is available on the day. At least one time interval must be specified for a day; if more intervals are specified, they must be non-overlapping. Intervals are half-open (the start time is included in the interval but the end time is excluded). */
                      intervals?: {
                        /**
                         * Format: HH:mm
                         * @description Start time of the interval in local time (24-hour ISO format).
                         * @example 08:10
                         */
                        startTime: string;
                        /**
                         * Format: HH:mm
                         * @description End time of the interval in local time (24-hour ISO format). Start time must be before end time, except for full days are which are represented as 00:00-00:00, and intervals that extend until the end of the day (e.g. 13:00-00:00).
                         * @example 15:00
                         */
                        endTime: string;
                      }[];
                    }[];
                  })
                | ({
                    /** @enum {string} */
                    type: "custom" | "weekly";
                  } & {
                    /**
                     * @description The repeat frequency of a single week pattern, must be a positive integer. The single weekly pattern is applied from the start time (which can be a non-complete week if the start time doesn't fall on a Monday), followed by `repeatWeeks - 1` number of "empty padding weeks" (unavailable all week).
                     * @example 3
                     */
                    repeatWeeks: number;
                    /** @description Weekdays that make up the pattern. Weekdays can be specified in any order. Not all weekdays must be specified (there can be holes in the pattern). Each weekday must appear only once in the pattern. */
                    days: {
                      /**
                       * @description The days of the week
                       * @enum {string}
                       */
                      weekday?:
                        | "MON"
                        | "TUE"
                        | "WED"
                        | "THU"
                        | "FRI"
                        | "SAT"
                        | "SUN";
                      /** @description A list of time intervals that determine when a resource is available on the day. At least one time interval must be specified for a day; if more intervals are specified, they must be non-overlapping. Intervals are half-open (the start time is included in the interval but the end time is excluded). */
                      intervals?: {
                        /**
                         * Format: HH:mm
                         * @description Start time of the interval in local time (24-hour ISO format).
                         * @example 08:10
                         */
                        startTime: string;
                        /**
                         * Format: HH:mm
                         * @description End time of the interval in local time (24-hour ISO format). Start time must be before end time, except for full days are which are represented as 00:00-00:00, and intervals that extend until the end of the day (e.g. 13:00-00:00).
                         * @example 15:00
                         */
                        endTime: string;
                      }[];
                    }[];
                  });
            };
            resources?: {
              /** @description The ID of the Pattern Resource that is to be updated. */
              UID?: string;
              /** @description The ID of the resource to assign to this pattern. */
              resourceId: string;
              /**
               * Format: date-time
               * @description The UTC datetime at which the pattern begins applying to the resource.
               */
              start: string;
              /**
               * Format: date-time
               * @description The UTC datetime at which the pattern stops applying to the resource where the pattern stops before this UTC datetime. If not provided, the pattern applies indefinitely.
               */
              end?: string;
            }[];
          };
        };
      };
    };
  };
  "/availability/migrate_to_patterns/status": {
    /** Retrieve information about the status of the Availability Template to Pattern migration. The Availability Patterns feature flag must be enabled in the org before calling this endpoint. */
    get: operations["availabilityMigrationStatus"];
  };
  "/availability/migrate_to_patterns/migrate": {
    /**
     * Migrate all Availability Template and Availability Template Resource objects in the org to Availability Pattern and Availability Pattern Resource objects, respectively.
     *
     * The Availability Patterns feature flag must be enabled in the org before calling this endpoint. No data is deleted by the migration process. The operation is idempotent, meaning that calling the endpoint multiple times will migrate every object only once. If the operation was interrupted or not all objects could be migrated due to some errors, the endpoint should be called again to migrate the rest of the data (perhaps after fixing some problems manually first).
     */
    post: operations["availabilityMigrationMigrate"];
  };
  "/onboarding/provision/standalone/users": {
    /**
     * Allows a Skedulo Platform Administrator to create users (and their associated resource).
     *
     * Each new user created can be sent an invitation email right after they are created, which contains a link allowing them to set a password.
     */
    post: operations["standaloneUsers"];
  };
  "/onboarding/provision/standalone/users/bulk": {
    /**
     * This endpoint is deprecated, use the Data Loader in the Skedulo web app instead.
     *
     * This is run as a background task.
     *
     * Each new user created can be sent an invitation email right after they are created, which contains a link allowing them to set a password.
     */
    post: operations["standaloneUsersBulk"];
  };
  "/onboarding/provision/standalone/users/file": {
    /**
     * This endpoint is deprecated, use the Data Loader in the Skedulo web app instead.
     *
     * Import CSV or JSON data that is embedded in a multipart/form-data document. Accepts one file at a time.
     */
    post: operations["standaloneUsersBulkFromFile"];
  };
  "/onboarding/provision/standalone/users/local": {
    /**
     * Creates users (and their associated resources) in the tenant database but does not create corresponding Auth0 user accounts.
     *
     * This allows the users to log in using linked SSO accounts with the corresponding email addresses. The email addresses can be used in multiple tenants when logging in with SSO.
     */
    post: operations["standaloneUsersLocal"];
  };
  "/onboarding/provision/standalone/users/local/file": {
    /** See /provision/standalone/users/local. Imports CSV or JSON data that is embedded in a multipart/form-data document. Accepts one file at a time. Import is run as a background task. */
    post: operations["standaloneUsersBulkFromFileLocal"];
  };
  "/onboarding/provision/standalone/users/bulk/{taskId}": {
    /**
     * This endpoint is deprecated, use the Data Loader in the Skedulo web app instead.
     *
     * Allows a Skedulo Platform Administrator to query the status of a background task that has been submitted earlier.
     */
    get: operations["getProcessedUsers"];
  };
  "/onboarding/internal/check_tenant_initialized": {
    /** Internal endpoint used to check if a tenant has been initialized. */
    post: operations["internalCheckTenantInitialized"];
  };
  "/config/templates/{schemaName}": {
    /** Fetch all templates for a given schema. */
    get: operations["getTemplates"];
  };
  "/config/template": {
    /** Create a new template. */
    post: operations["createTemplate"];
  };
  "/config/template/{template_id}": {
    /** Update an existing template. */
    put: operations["updateTemplate"];
    /** Delete a template. */
    delete: operations["deleteTemplate"];
  };
  "/config/template/{template_id}/values": {
    /** Return template values for a template. */
    get: operations["getValuePairs"];
    /** All existing values will removed and the values provided will be inserted. */
    put: operations["overrideTemplateValues"];
  };
  "/config/config/layout/{object}": {
    /** Returns the default layout for the given object. */
    get: operations["layoutObjectDefault"];
  };
  "/custom/vocabularies": {
    get: operations["fetchVocabularies"];
  };
  "/custom/vocabulary/{schemaName}/{fieldName}": {
    get: operations["vocabularyFetch"];
    /** You must be an administrator in order to use this endpoint */
    post: operations["vocabularyCreate"];
  };
  "/custom/vocabulary/{schemaName}/{fieldName}/{value}": {
    /** You must be an administrator in order to use this endpoint */
    put: operations["vocabularyUpdate"];
    /** You must be an administrator in order to use this endpoint */
    delete: operations["vocabularyDeactivate"];
  };
  "/custom/vocabulary/dependency": {
    /** You must be an administrator in order to use this endpoint */
    post: operations["upsertFieldDependency"];
  };
  "/custom/vocabulary/dependency/delete": {
    /** You must be an administrator in order to use this endpoint */
    post: operations["deleteFieldDependency"];
  };
  "/custom/vocabulary/dependency/entry": {
    /** You must be an administrator in order to use this endpoint */
    post: operations["addFieldDependencyEntry"];
  };
  "/custom/vocabulary/dependency/entry/delete": {
    /** You must be an administrator in order to use this endpoint */
    post: operations["deleteFieldDependencyEntry"];
  };
  "/custom/usermetadata": {
    /** Deprecated: use the /auth/metadata/user endpoint instead */
    get: operations["userMetadata"];
  };
  "/files/attachment/{fileId}": {
    get: operations["downloadFile"];
    put: operations["renameFile"];
    delete: operations["deleteFile"];
  };
  "/files/attachments": {
    get: operations["getFiles"];
  };
  "/files/attachments/{parentId}": {
    get: operations["getFilesSingle"];
    put: operations["uploadReturnOldMeta"];
    post: operations["uploadReturnNewMeta"];
  };
  "/files/avatar": {
    get: operations["getAvatarFor"];
  };
  "/geoservices/distanceMatrix": {
    /**
     * The Distance Matrix endpoint computes travel distance and time for all combinations of origin and destination locations, based on the recommended route between start and end points.
     * It should be noted that there are limits on the total number elements that can be requested and that large requests (where origins * destinations > 1000) may take several seconds to satisfy. These limits may vary depending on your underlying configuration.
     */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": {
              matrix: {
                /** @enum {string} */
                status: "OK" | "NO_ROUTE";
                duration?: {
                  durationInSeconds: number;
                };
                distance?: {
                  distanceInMeters: number;
                };
              }[][];
              /** @enum {string} */
              vendor: "GOOGLE" | "GRAPHHOPPER" | "LINEOFSIGHT";
            };
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description must be non-empty */
            origins: {
              /** @description -90 <= y <= 90 */
              lat: number;
              /** @description -180 <= x <= 180 */
              lng: number;
            }[];
            /** @description must be non-empty */
            destinations: {
              /** @description -90 <= y <= 90 */
              lat: number;
              /** @description -180 <= x <= 180 */
              lng: number;
            }[];
          };
        };
      };
    };
  };
  "/geoservices/directions": {
    /** The Directions endpoint calculates directions between source and destination addresses, possibly including multiple waypoints enroute. It returns the recommended travel route (if one can be found), along with estimated travel time and distance. */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": {
              routes: {
                leg: {
                  origin: {
                    /** @description -90 <= y <= 90 */
                    lat: number;
                    /** @description -180 <= x <= 180 */
                    lng: number;
                  };
                  destination: {
                    /** @description -90 <= y <= 90 */
                    lat: number;
                    /** @description -180 <= x <= 180 */
                    lng: number;
                  };
                  avoid: ("ferry" | "highway" | "toll")[];
                };
                travelInfo: {
                  /** @enum {string} */
                  status: "OK" | "NO_ROUTE";
                  duration?: {
                    durationInSeconds: number;
                  };
                  distance?: {
                    distanceInMeters: number;
                  };
                };
              }[][];
            };
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            requests: {
              origin: {
                /** @description -90 <= y <= 90 */
                lat: number;
                /** @description -180 <= x <= 180 */
                lng: number;
              };
              destination: {
                /** @description -90 <= y <= 90 */
                lat: number;
                /** @description -180 <= x <= 180 */
                lng: number;
              };
              waypoints?: {
                /** @description -90 <= y <= 90 */
                lat: number;
                /** @description -180 <= x <= 180 */
                lng: number;
              }[];
            }[];
            avoid?: ("ferry" | "highway" | "toll")[];
          };
        };
      };
    };
  };
  "/geoservices/geocode": {
    /** For a given list of addreseses, returns a list of geocoded `LatLng`, or errors. */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": {
              result?: {
                GeocodeSuccess?: {
                  address: string;
                  latlng: {
                    /** @description -90 <= y <= 90 */
                    lat: number;
                    /** @description -180 <= x <= 180 */
                    lng: number;
                  };
                };
                GeocodeFailure?: {
                  address: string;
                  reason: {
                    msg: string;
                  };
                };
              }[];
            };
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            addresses: string[];
            /** @description Return addresses in the given language. Must be a language code. */
            language?: string;
          };
        };
      };
    };
  };
  "/geoservices/autocomplete": {
    /** For a given input string, return a list of address suggestions, or error. */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": {
              result?: {
                predictions: {
                  description: string;
                  /** @description Unique id for the suggested place, to be used with fetch place endpoint. */
                  placeId: string;
                };
                /** @enum {string} */
                status: "OK" | "ZERO_RESULTS";
                errorMessage?: string;
              }[];
            };
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            input: string;
            /**
             * Format: uuid
             * @description A caller-generated uuid to signify a session, which consists of multiple autocomplete requests and ends with a place fetch request. A different session should use a different sessionId
             */
            sessionId: string;
            location?: {
              /** @description -90 <= y <= 90 */
              lat: number;
              /** @description -180 <= x <= 180 */
              lng: number;
            };
            /** @description A two character, ISO 3166-1 Alpha-2 compatible country code */
            country?: string;
          };
        };
      };
    };
  };
  "/geoservices/place": {
    /** For a given place Id, return the detailed information for that place. */
    post: {
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": {
              addressComponents: {
                streetNumber?: string;
                route?: string;
                locality?: string;
                area2?: string;
                area1?: string;
                country?: string;
                postalCode?: string;
              };
              formattedAddress: string;
              geometry: {
                /** @description -90 <= y <= 90 */
                lat: number;
                /** @description -180 <= x <= 180 */
                lng: number;
              };
            };
          };
        };
        /** invalid request */
        400: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description Unique id for a place in Google system, obtained from autocomplete endpoint. */
            placeId: string;
            /**
             * Format: uuid
             * @description A caller-generated uuid that may have been used in an autocomplete session.
             */
            sessionId: string;
          };
        };
      };
    };
  };
  "/geoservices/timezone": {
    /** Given a location and timestamp return the timezone name, the offset and Daylight Savings offset. */
    get: {
      parameters: {
        query: {
          /** Latitude and Longitude of the location to find the timezone for */
          location: number[];
          /** Seconds since 1970 for the timezone to return (used to compute DST offset) */
          timestamp: number;
        };
      };
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": {
              /** @description The Daylight Savings time offset in seconds or 0 if no Daylight Savings time is in effect. */
              dstOffset?: number;
              /** @description The offset in seconds from UTC for the given location. */
              rawOffset?: number;
              /** @description The id of the time zone, (e.g "Australia/Brisbane" as defined by the Unicode Common Locale Data Repository (CLDR) project. */
              timeZoneId?: string;
            };
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
  };
  "/geoservices/invalidate": {
    /** Invalidate the 1 hour TTL cache for distance matrix vendor used for distance matrix requests.  In the instance that the distance matrix vendor is changed via Org Preferences, this endpoint will make that change effective immediately. */
    post: {
      parameters: {};
      responses: {
        /** successful operation */
        200: {
          content: {
            "application/json": {
              result?: { [key: string]: unknown };
            };
          };
        };
        /** unexpected error */
        default: {
          content: {
            "application/json": {
              errorType: string;
              message: string;
            };
          };
        };
      };
    };
  };
  "/ical/token": {
    get: operations["getToken"];
  };
  "/ical/{token}": {
    get: operations["getICal"];
  };
  "/schedule/async/copy": {
    /**
     * This endpoint is deprecated, use `/schedule/copy` instead.
     *
     * Jobs, shifts and activities can be copied with their attached allocations/resources and other attachments (e.g. tags). EQL filters must be provided to specify the jobs, shifts and/or activities to be copied. The start and end times of the copied work items will be offset (incremented or decremented) by the provided number of days. Executed in the background as an asynchronous task.
     */
    post: operations["copyScheduleAsync"];
  };
  "/schedule/copy": {
    /** Jobs, shifts and activities can be copied with their attached allocations/resources and other attachments (e.g. tags). EQL filters must be provided to specify the jobs, shifts and/or activities to be copied. The start and end times of the copied work items will be offset (incremented or decremented) by the provided number of days. Executed in the background as an asynchronous task. */
    post: operations["copySchedule"];
  };
  "/schedule/async/copy/{taskId}": {
    /**
     * This endpoint is deprecated, use `/schedule/copy/{taskId}` instead.
     *
     * This endpoint can be polled to get the status of the task and the results of the operation, if any.
     */
    get: operations["copyScheduleAsyncResults"];
  };
  "/schedule/copy/{taskId}": {
    /** This endpoint can be polled to get the status of the task and the results of the operation, if any. */
    get: operations["copyScheduleResults"];
  };
  "/schedule/sync/dispatch": {
    /** Multiple jobs and shifts can be dispatched/published in one request. EQL filters must be provided to specify the jobs and shifts to be dispatched. Summary notifications can optionally be sent to each resource. Individual notifications will not be sent for each job/shift. */
    post: operations["dispatchSchedule"];
  };
  "/schedule/template/apply": {
    /** A schedule template is converted to real jobs, shifts and activities, starting at the given date. Executed in the background as an asynchronous task. */
    post: operations["applyScheduleTemplate"];
  };
  "/schedule/template/apply/{taskId}": {
    /** This endpoint can be polled to get the status of the task and the results of the operation, if any. */
    get: operations["applyScheduleTemplateResults"];
  };
  "/recurring/schedules": {
    /** Get a list of recurring schedules summaries */
    get: operations["listRecurringSchedules"];
  };
  "/recurring/schedules/jobs/existing": {
    /** Fields and Child relationships can be specified (e.g. Giving created jobs the same job tags or allocations). By default, required Job fields like Region ID and duration will be propagated even if not specified */
    post: operations["createRecurringScheduleFromExistingJob"];
  };
  "/recurring/schedules/{id}": {
    /** Get summary of a recurring schedule */
    get: operations["getSingleRecurringSchedules"];
  };
  "/recurring/schedules/jobs/preview": {
    /** Preview the intervals that will be generated for a given recurrence pattern and job details */
    post: operations["preview"];
  };
  "/recurring/schedules/jobs": {
    /** Updates the fields and attached objects of jobs in a recurring schedule, where the jobs start at or after the provided timestamp. Arrays of attached 'HasMany' objects can be provided along with the fields to be updated. In this case, all existing attached objects of the same type on future jobs will be deleted and replaced with the provided objects. Job IDs may be explicitly excluded - this allows the caller to prevent modifying the job that they are currently displaying. Jobs that are Locked, In Progress, Completed or Cancelled will not be updated. */
    put: operations["updateJobs"];
    /** Create a recurring schedule from a base job and pattern */
    post: operations["createRecurringSchedule"];
  };
  "/recurring/schedules/job_allocations": {
    /** Create or update job allocations for certain resources */
    post: operations["upsertJobAllocations"];
  };
  "/recurring/schedules/job_allocations/delete": {
    /** Delete job allocations for certain resources */
    post: operations["deleteJobAllocations"];
  };
  "/virtualmeeting/meetings": {
    post: operations["createMeeting"];
  };
  "/virtualmeeting/meetings/{id}": {
    get: operations["getMeeting"];
    put: operations["updateMeeting"];
    delete: operations["deleteMeeting"];
  };
  "/query/v1/data-schema/{resourceId}": {
    get: operations["QueryService_GetDataSchema"];
    delete: operations["QueryService_DeleteDataSchema"];
  };
  "/query/v1/objects/{resourceId}": {
    get: operations["QueryService_GetObjects"];
    post: operations["QueryService_CreateObject"];
  };
  "/query/v1/objects/{resourceId}/{objectId}": {
    get: operations["QueryService_GetObject"];
    put: operations["QueryService_UpdateObject"];
    delete: operations["QueryService_DeleteObject"];
  };
  "/query/v1/schema/{resourceId}/field/{accessor}": {
    /** Returns schema for a single field in the given resources schema. */
    get: operations["QueryService_GetFieldSchema"];
  };
  "/ui/v1/bulk-action/execute": {
    post: operations["UIService_ExecuteBulkAction"];
  };
  "/ui/v1/clean-up-tenant": {
    post: operations["UIService_CleanUpTenant"];
  };
  "/ui/v1/data-relationship-overlay": {
    post: operations["UIService_NewDataRelationshipOverlay"];
  };
  "/ui/v1/data-relationship-overlay/{overlay.uid}": {
    put: operations["UIService_PutDataRelationshipOverlay"];
  };
  "/ui/v1/data-relationship-overlay/{uid}": {
    get: operations["UIService_GetDataRelationshipOverlay"];
    delete: operations["UIService_DelDataRelationshipOverlay"];
  };
  "/ui/v1/data-schema-field-overlay": {
    post: operations["UIService_NewDataSchemaFieldOverlay"];
  };
  "/ui/v1/data-schema-field-overlay/{overlay.uid}": {
    put: operations["UIService_PutDataSchemaFieldOverlay"];
  };
  "/ui/v1/data-schema-field-overlay/{uid}": {
    get: operations["UIService_GetDataSchemaFieldOverlay"];
    delete: operations["UIService_DelDataSchemaFieldOverlay"];
  };
  "/ui/v1/data-schema-overlay": {
    get: operations["UIService_GetDataSchemaOverlays"];
  };
  "/ui/v1/destination": {
    get: operations["UIService_GetDestinations"];
  };
  "/ui/v1/filter": {
    get: operations["UIService_GetFilters"];
    post: operations["UIService_NewFilter"];
  };
  "/ui/v1/filter/relevant/{resourceId}": {
    get: operations["UIService_GetRelevantFilter"];
  };
  "/ui/v1/filter/{filter.uid}": {
    put: operations["UIService_PutFilter"];
  };
  "/ui/v1/filter/{uid}": {
    get: operations["UIService_GetFilter"];
    delete: operations["UIService_DelFilter"];
  };
  "/ui/v1/list": {
    get: operations["UIService_GetLists"];
    post: operations["UIService_NewList"];
  };
  "/ui/v1/list/relevant/{resourceId}": {
    get: operations["UIService_GetRelevantList"];
  };
  "/ui/v1/list/{list.uid}": {
    put: operations["UIService_PutList"];
  };
  "/ui/v1/list/{uid}": {
    get: operations["UIService_GetList"];
    delete: operations["UIService_DelList"];
  };
  "/ui/v1/nav": {
    get: operations["UIService_GetNavs"];
    post: operations["UIService_NewNav"];
  };
  "/ui/v1/nav-unrestricted": {
    get: operations["UIService_GetNavsUnrestricted"];
  };
  "/ui/v1/nav-unrestricted/{uid}": {
    get: operations["UIService_GetNavUnrestricted"];
  };
  "/ui/v1/nav/{nav.uid}": {
    put: operations["UIService_PutNav"];
  };
  "/ui/v1/nav/{uid}": {
    get: operations["UIService_GetNav"];
    delete: operations["UIService_DelNav"];
  };
  "/ui/v1/resource": {
    get: operations["UIService_GetResources"];
    post: operations["UIService_NewResource"];
  };
  "/ui/v1/resource/{resource.uid}": {
    put: operations["UIService_PutResource"];
  };
  "/ui/v1/resource/{uid}": {
    get: operations["UIService_GetResource"];
    delete: operations["UIService_DelResource"];
  };
  "/ui/v1/sync": {
    post: operations["UIService_InitiateSchemaSync"];
  };
  "/ui/v1/template": {
    get: operations["UIService_GetTemplates"];
    post: operations["UIService_NewTemplate"];
  };
  "/ui/v1/template/{template.uid}": {
    put: operations["UIService_PutTemplate"];
  };
  "/ui/v1/template/{uid}": {
    get: operations["UIService_GetTemplate"];
    delete: operations["UIService_DelTemplate"];
  };
  "/ui/v1/validation": {
    get: operations["UIService_GetValidations"];
    post: operations["UIService_NewValidation"];
  };
  "/ui/v1/validation/{name}/validate": {
    post: operations["UIService_ValidateData"];
  };
  "/ui/v1/validation/{uid}": {
    get: operations["UIService_GetValidation"];
    delete: operations["UIService_DelValidation"];
  };
  "/ui/v1/validation/{validation.uid}": {
    put: operations["UIService_PutValidation"];
  };
  "/ui/v1/view-override": {
    get: operations["UIService_GetViewOverrides"];
    post: operations["UIService_NewViewOverride"];
  };
  "/ui/v1/view-override/{uid}": {
    get: operations["UIService_GetViewOverride"];
    delete: operations["UIService_DelViewOverride"];
  };
  "/ui/v1/view-override/{viewOverride.uid}": {
    put: operations["UIService_PutViewOverride"];
  };
}

export interface components {}

export interface operations {
  /** Return the current user's authentication information */
  whoami: {
    parameters: {
      query: {
        /** Access token. This is an alternative to passing the Authorization: `Bearer` header */
        access_token?: string;
      };
    };
    responses: {
      /** The current users authentication information was returned */
      200: {
        content: {
          "application/json": {
            result?: {
              username: string;
              userId: string;
              tenantId: string;
              roles: ("administrator" | "scheduler" | "resource")[];
              resourceId?: string;
              vendorInfo:
                | {
                    /** @example salesforce */
                    vendor: string;
                    /** @enum {string} */
                    env: "salesforce" | "salesforce-sandbox";
                    /** @description community ID for this user if this user belongs to one */
                    communityId?: string;
                    /** @description Salesforce user ID of this user */
                    vendorUserId?: string;
                  }
                | {
                    /** @example skedulo */
                    vendor: string;
                    /** @description Skedulo user ID of this user */
                    vendorUserId?: string;
                  };
              /** @description The permissions for the user. Only present if the useNewPermissions feature flag is enabled. */
              permissions?: string[];
            };
          };
        };
      };
    };
  };
  /** Return the current user's data access rules. Requires the useRecordAccessPolicies feature flag. */
  access_rules: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result?: {
              objectType: string;
              /** @description EQL filter that is applied when accessing records of the object type */
              filter: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * The user assigning the API user must be an administrator.
   *
   * >NOTE:
   * >If you make any modifications to the user assigned as the API User, you need to set the user as the API User again to ensure the data stored for the user is up to date. Otherwise, some claims in the access token will be outdated.
   */
  setApiUser: {
    responses: {
      /** The user was successfully setup as the API User. */
      200: {
        content: {
          "*/*": {
            result: {
              /** @description The endpoint to obtain the Skedulo API access token using the body given in authBody. The authorization flow is called client credentials flow. */
              authEndpoint: string;
              /** @description The content of this object should be sent verbatim to the authEndpoint (POST) to obtain a Skedulo API access token. */
              authBody: {
                /** @example client_credentials */
                grant_type: string;
                client_id: string;
                client_secret: string;
                audience: string;
              };
            };
          };
        };
      };
      /** If the user is not an administrator */
      403: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Skedulo User ID of the user to be setup as the API User */
          userId: string;
        };
      };
    };
  };
  /** Removes the API User for this tenant if they have one. If the tenant is on Standalone this will reset their API user to the system user. The caller must be an administrator. */
  removeApiUser: {
    responses: {
      /** successful result */
      200: unknown;
      /** If the user is not an administrator */
      403: unknown;
    };
  };
  /** The user requesting this information must be an administrator for their organization. */
  getApiUserClientCredentials: {
    responses: {
      /** Client credentials information of the API user */
      200: {
        content: {
          "*/*": {
            result: {
              /** @description The endpoint to obtain the Skedulo API access token using the body given in authBody. The authorization flow is called client credentials flow. */
              authEndpoint: string;
              /** @description The content of this object should be sent verbatim to the authEndpoint (POST) to obtain a Skedulo API access token. */
              authBody: {
                /** @example client_credentials */
                grant_type: string;
                client_id: string;
                client_secret: string;
                audience: string;
              };
            };
          };
        };
      };
      /** User is not an administrator */
      403: unknown;
      /** API user is not setup */
      404: unknown;
    };
  };
  /** List candidates that can be set as the API user and the current API user. Only users with role `administrator` are returned. */
  listApiUserCandidates: {
    responses: {
      /** List of candidates that can be assigned as the API User */
      200: {
        content: {
          "application/json": {
            result: {
              /** @description User ID of the current API User */
              currentApiUserId?: string;
              /** @description True if only a subset of all available candidates is being returned */
              moreCandidatesExist?: boolean;
              candidates: {
                userId: string;
                vendorUserId: string;
                firstName?: string;
                lastName: string;
                username: string;
                resourceId?: string;
                roles: ("administrator" | "scheduler" | "resource")[];
                /** Format: email */
                email: string;
                emailVerified: boolean;
              }[];
            };
          };
        };
      };
    };
  };
  verifyApiUser: {
    responses: {
      /** If the result contains success equal to true the API user is verified, otherwise it is not. */
      200: {
        content: {
          "application/json": {
            result: {
              success: boolean;
              code?: string;
              message?: boolean;
              /** @description Additional information about the error */
              extraFields?: { [key: string]: unknown };
            };
          };
        };
      };
    };
  };
  /** Fetch metadata about the current user. */
  metadataUser: {
    responses: {
      /** The current users metadata */
      200: {
        content: {
          "application/json": {
            created?: {
              id: string;
              email: string;
              username: string;
              fullName: string;
              firstName?: string;
              lastName: string;
              team: {
                id: string;
                /** @description A valid DNS sub domain */
                name: string;
                /** @description A human friendly name */
                description: string;
                /**
                 * @description The vendor associated with this organization
                 * @enum {string}
                 */
                vendor: "salesforce" | "servicenow" | "skedulo";
                /** @description The vendor specific organization ID */
                orgId: string;
                /** @description The customer name. */
                customer?: string;
              };
              resource?: {
                id: string;
                category?: string;
                employmentType?: string;
                address?: string;
                latitude?: number;
                longitude?: number;
                mobilePhone?: string;
                timezone: string;
              };
            };
          };
        };
      };
      /** The user belongs to a tenant that is not associated with a team */
      412: unknown;
    };
  };
  /** Links (assigns) a resource to a user by their respective Ids. */
  linkResource: {
    responses: {
      /** User and resource were successfully linked. */
      200: unknown;
      /** The user does not have permission to perform this action. */
      403: unknown;
      /** No user found for the given id. */
      404: {
        content: {
          "*/*": { [key: string]: unknown };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The user id of the user to be linked to given resource */
          userId: string;
          /** @description The resource id of the resource to be linked to given user */
          resourceId: string;
        };
      };
    };
  };
  /** Unlinked a resource to a user by their respective Ids. */
  unlinkResource: {
    responses: {
      /** successful result */
      200: unknown;
      /** The user does not have permission to perform this action. */
      403: unknown;
      /** No user found for the given id. */
      404: {
        content: {
          "*/*": { [key: string]: unknown };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The user id of the user to be linked to given resource */
          user_id: string;
          /** @description The resource id of the resource to be linked to given user */
          resource_id: string;
        };
      };
    };
  };
  /** List all the available and revoked API tokens. */
  fetchAll: {
    responses: {
      /** Return information about all the available and revoked API tokens. */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @example sk_e0bb1f8aa1924a00b77a9c1f43b09e41 */
              tenantId: string;
              /** @example BM10SHoI4Z4nmhtElInXuJWLkeeqqyzy */
              jti: string;
              /** @description Selection of the user claims from the JWT */
              claims: { [key: string]: unknown };
              /** Format: date-time */
              createdDate: string;
              createdBy: string;
              /** Format: date-time */
              revokedDate?: string;
              revokedBy?: string;
              /** Format: date-time */
              lastUpdated?: string;
            }[];
          };
        };
      };
    };
  };
  /** Get an API token by specifying its JTI. */
  fetchAllApiTokens: {
    parameters: {
      path: {
        /** The JWT Identifier for the API token */
        jti: string;
      };
    };
    responses: {
      /** Return information about the requested API token */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @example sk_e0bb1f8aa1924a00b77a9c1f43b09e41 */
              tenantId: string;
              /** @example BM10SHoI4Z4nmhtElInXuJWLkeeqqyzy */
              jti: string;
              /** @description Selection of the user claims from the JWT */
              claims: { [key: string]: unknown };
              /** Format: date-time */
              createdDate: string;
              createdBy: string;
              /** Format: date-time */
              revokedDate?: string;
              revokedBy?: string;
              /** Format: date-time */
              lastUpdated?: string;
            };
          };
        };
      };
    };
  };
  /** Create an API token with an optional expiry. This token can be used to authenticate as the same user that created it (with the same claims) for as long as the token is valid. Tokens may be revoked. */
  createApiToken: {
    responses: {
      /** Return the API token */
      200: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: base64
               * @example 5l8l/TyAG+282cBi0JoAp8Gj2WtnXjhxkHKu5J+ytWJcp5kHG9I7k...A==
               */
              token: string;
              /** @example x62ThdBIqHVmILpLKdHbZctTaEzySGGc */
              jti: string;
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: date-time
           * @description Optional expiry. If omitted the token is valid forever.
           */
          expiry?: string;
        };
      };
    };
  };
  /** Revoke an API token so it can no longer be used. The token will be returned but marked as revoked. It cannot be used to authenticate once revoked. */
  revokeToken: {
    responses: {
      /** The token was revoked */
      200: {
        content: {
          "application/json": {
            result: { [key: string]: unknown };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description JWT Identfier of token to revoke */
          jti?: string;
        };
      };
    };
  };
  fetchPermissions: {
    parameters: {
      path: {
        /** A non-empty comma separated string of object names to fetch permission metadata for */
        names: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": {
            /** @description Object permission metadata keyed by the object name */
            result?: {
              [key: string]: {
                /** @description True if the current user has permission to read from this object */
                read: boolean;
                /** @description True if the current user has permission to create a record in this object */
                create: boolean;
                /** @description True if the current user has permission to update a record in this object */
                update: boolean;
                /** @description True if the current user has permission to delete a record in this object */
                delete: boolean;
                /** @description Fields of the object keyed by their name */
                fields: {
                  [key: string]: {
                    /** @description True if the current user has permission to read from this field */
                    read: boolean;
                    /** @description True if the current user has permission to insert a value into this field */
                    create: boolean;
                    /** @description True if the current user has permission to update a value in this field */
                    update: boolean;
                  };
                };
              };
            };
          };
        };
      };
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  /** Fetch the default permissions and custom permissions for each role */
  rolePermissions: {
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            /** @description The object key is the name of the role */
            result: {
              [key: string]: {
                defaults?:
                  | (
                      | {
                          /** @enum {string} */
                          type: "all";
                        }
                      | {
                          /** @enum {string} */
                          type: "custom";
                          /** @description key is the name of the object */
                          objects: {
                            [key: string]: {
                              permissions: {
                                read: boolean;
                                create: boolean;
                                update: boolean;
                                delete: boolean;
                              };
                              /** @description key is the name of the field */
                              fields: {
                                [key: string]: {
                                  read: boolean;
                                  create: boolean;
                                  update: boolean;
                                };
                              };
                            };
                          };
                        }
                    )
                  | null;
                overrides?:
                  | (
                      | {
                          /** @enum {string} */
                          type: "all";
                        }
                      | {
                          /** @enum {string} */
                          type: "custom";
                          /** @description key is the name of the object */
                          objects: {
                            [key: string]: {
                              permissions: {
                                read: boolean;
                                create: boolean;
                                update: boolean;
                                delete: boolean;
                              };
                              /** @description key is the name of the field */
                              fields: {
                                [key: string]: {
                                  read: boolean;
                                  create: boolean;
                                  update: boolean;
                                };
                              };
                            };
                          };
                        }
                    )
                  | null;
              };
            };
          };
        };
      };
      /** If the user is not an administrator */
      403: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  /** To remove a single object or field override pass `null` as the value. */
  rolePermissionsSet: {
    parameters: {
      path: {
        /** Name of the role */
        role: string;
      };
    };
    responses: {
      /** successful operation */
      200: unknown;
      /** If the user is not an administrator */
      403: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description key is the name of the object */
          objects: {
            [key: string]: {
              permissions: {
                read: boolean;
                create: boolean;
                update: boolean;
                delete: boolean;
              };
              /** @description key is the name of the field */
              fields: {
                [key: string]: {
                  read: boolean;
                  create: boolean;
                  update: boolean;
                } | null;
              };
            } | null;
          };
        };
      };
    };
  };
  rolePermissionsDelete: {
    parameters: {
      path: {
        /** Name of the role */
        role: string;
      };
    };
    responses: {
      /** successful operation */
      200: unknown;
      /** If the user is not an administrator */
      403: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  templateV2Upsert: {
    parameters: {
      path: {
        type: "job_dispatch" | "job_reminder" | "job_cancelled" | "job_offer";
        protocol: "sms" | "push";
      };
    };
    responses: {
      /** Successfully created or updated */
      200: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description A notification template to use for this protocol. Accepts Mustache style variables that point at schema fields and a small number of Handlebar handlers.
           * @example New {{ Name }}. {{ Start }}. {{first Address "Unknown Address" }}. For {{first Account.Name Contact.FullName "Unknown Customer" }}, {{ Duration }}.
           */
          template?: string;
        };
      };
    };
  };
  /** The latest locations endpoint returns information about the **resource's** latest location. It is a map from resourceId to latest location. */
  locationLatest: {
    parameters: {
      query: {
        /** Comma separated resourceIds */
        resource_ids: string;
      };
    };
    responses: {
      /** A map from resourceId to Latest Location */
      200: {
        content: {
          "application/json": {
            result: {
              [key: string]: {
                /**
                 * Format: date-time
                 * @description Time the location was recorded. This must be in ISO date format.
                 */
                time: string;
                /**
                 * Format: double
                 * @description The latitude (degrees).  This should be in decimal format, ie. "DDD.DDDD" not degrees and minutes.
                 */
                lat: number;
                /**
                 * Format: double
                 * @description The longitude (degrees). This should be in decimal format, ie. "DDD.DDDD" not degrees and minutes.
                 */
                lng: number;
                /**
                 * Format: float
                 * @description The altitude (m)
                 */
                altitude?: number;
                /**
                 * Format: float
                 * @description The current heading/bearing of the path track (degrees).  Where both bearing and orientation are available, the bearing should be used.  This distinguishes the current orientation of the device which  may be determined by compass for example from the heading of the track taken as the user moves.
                 */
                heading?: number;
                /**
                 * Format: float
                 * @description The current speed (m/s).
                 */
                speed?: number;
                /**
                 * Format: float
                 * @description Horizontal position accuracy (m).
                 */
                accuracy?: number;
                /**
                 * Format: float
                 * @description Vertical position accuracy (m).
                 */
                altAccuracy?: number;
              };
            };
          };
          result: unknown;
        };
      };
      /** Bad request. eg. resourceId cannot be empty */
      400: {
        content: {
          "application/json": {
            errorType?: string;
            message?: string;
          };
        };
      };
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType?: string;
            message?: string;
          };
        };
      };
    };
  };
  /**
   * The Location history end point allows you to retrieve the location history for a resource.
   * The default limit is 100 results.
   */
  locationHistory: {
    parameters: {
      query: {
        /** Identifier of a resource */
        resource_id: string;
        /** Start time */
        start: string;
        /** End Time */
        end: string;
        /** All points returned will have an accuracy of at least the number given. If this parameter is not provided the default value is 100. To return all points use an empty string. */
        accuracy?: number;
        limit?: number;
        offset?: number;
      };
    };
    responses: {
      /** Paged array of locations */
      200: {
        content: {
          "application/json": {
            paging: {
              /** Format: int64 */
              total: number;
              /** Format: int64 */
              offset: number;
              /** Format: int64 */
              limit: number;
            };
            result: {
              /**
               * Format: date-time
               * @description Time the location was recorded. This must be in ISO date format.
               */
              time: string;
              /**
               * Format: double
               * @description The latitude (degrees).  This should be in decimal format, ie. "DDD.DDDD" not degrees and minutes.
               */
              lat: number;
              /**
               * Format: double
               * @description The longitude (degrees). This should be in decimal format, ie. "DDD.DDDD" not degrees and minutes.
               */
              lng: number;
              /**
               * Format: float
               * @description The altitude (m)
               */
              altitude?: number;
              /**
               * Format: float
               * @description The current heading/bearing of the path track (degrees).  Where both bearing and orientation are available, the bearing should be used.  This distinguishes the current orientation of the device which  may be determined by compass for example from the heading of the track taken as the user moves.
               */
              heading?: number;
              /**
               * Format: float
               * @description The current speed (m/s).
               */
              speed?: number;
              /**
               * Format: float
               * @description Horizontal position accuracy (m).
               */
              accuracy?: number;
              /**
               * Format: float
               * @description Vertical position accuracy (m).
               */
              altAccuracy?: number;
            }[];
          };
        };
      };
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType?: string;
            message?: string;
          };
        };
      };
    };
  };
  /**
   * The location update endpoint allows one or more position updates to be provided indicating a resource's location.
   *
   * The resource is determined by the Java Web Token provided. It is not possible for users other than the logged in user to update a resources position.
   */
  locationUpdate: {
    responses: {
      /** Location update added */
      200: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType?: string;
            message?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: date-time
           * @description Time the location was recorded. This must be in ISO date format.
           */
          time: string;
          /**
           * Format: double
           * @description The latitude (degrees).  This should be in decimal format, ie. "DDD.DDDD" not degrees and minutes.
           */
          lat: number;
          /**
           * Format: double
           * @description The longitude (degrees). This should be in decimal format, ie. "DDD.DDDD" not degrees and minutes.
           */
          lng: number;
          /**
           * Format: float
           * @description The altitude (m)
           */
          altitude?: number;
          /**
           * Format: float
           * @description The current heading/bearing of the path track (degrees).  Where both bearing and orientation are available, the bearing should be used.  This distinguishes the current orientation of the device which  may be determined by compass for example from the heading of the track taken as the user moves.
           */
          heading?: number;
          /**
           * Format: float
           * @description The current speed (m/s).
           */
          speed?: number;
          /**
           * Format: float
           * @description Horizontal position accuracy (m).
           */
          accuracy?: number;
          /**
           * Format: float
           * @description Vertical position accuracy (m).
           */
          altAccuracy?: number;
        }[];
      };
    };
  };
  /** Locate all resources within a set distance of a specified location. */
  locationResourcesWithinDistance: {
    parameters: {
      query: {
        /** The latitude (degrees).  This should be in decimal format, ie. "DDD.DDDD" not degrees and minutes. */
        lat: number;
        /** The longitude of the position (degrees).  This should be in decimal format, ie. "DDD.DDDD" not degrees and minutes. */
        lng: number;
        /** The distance (metres) to query for resources.  Note that the accuracy of the resources location is not considered when making this query. */
        distance: number;
        /** Only consider points after this time. */
        start?: string;
        /** Only consider points before this time. */
        end?: string;
        /** Ignores any points that have an accuracy greater than the number given. If this parameter is not provided the default value is 100. To return all points use an empty string. */
        accuracy?: number;
      };
    };
    responses: {
      /** Resources and their latest position that was within distance of the location. */
      200: {
        content: {
          "application/json": {
            /** @description Map resource ids to their distance from a location */
            result: {
              [key: string]: {
                /**
                 * Format: date-time
                 * @description Time the last position was received
                 */
                time: string;
                /**
                 * Format: double
                 * @description Latitude of the position
                 */
                lat: number;
                /**
                 * Format: double
                 * @description Longitude of the position
                 */
                lng: number;
                /**
                 * Format: double
                 * @description Distance from the requested location (in meters)
                 */
                distance: number;
                /**
                 * Format: double
                 * @description Accuracy of the position
                 */
                accuracy?: number;
              };
            };
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType?: string;
            message?: string;
          };
        };
      };
    };
  };
  /**
   * Given a comma-separated list of resource Ids and a start and end date, return the route taken by that resource between the start and end time.
   *
   * The maximum amount of time supported is 24 hours.
   *
   * The supported formats are
   * * _polyline_ Uses the Google Maps Polyline encoding (default)
   * * _wkt_ - Well Known Text Strings.  Either a LINESTRING or a POINT is returned
   * * _geojson_ - GeoJSON format. Either a linestring or a point is returned
   */
  travelRoutes: {
    parameters: {
      query: {
        /** Comma separated resource Id values */
        resource_ids: string;
        /** Start time */
        start: string;
        /** End Time */
        end: string;
        /** All points returned will have an accuracy of at least the number given. If this parameter is not provided the default value is 100. To return all points use an empty string. */
        accuracy?: number;
        /** Output Format. */
        format?: "polyline" | "wkt" | "geojson";
      };
    };
    responses: {
      /** Map from resourceId to route in the requested format */
      200: {
        content: {
          "application/json": {
            /** @description Map resource ids to routes with start and end times */
            result: {
              /** @description Map resource ids to route information */
              result: {
                [key: string]: {
                  /**
                   * Format: date-time
                   * @description Time of the first position in the result
                   */
                  start: string;
                  /**
                   * Format: date-time
                   * @description Time of the last position in the result
                   */
                  end: string;
                  /**
                   * Format: Google Maps Polyline
                   * @description The route encoded as a Google maps polylne
                   */
                  polyline?: string;
                  /**
                   * Format: Well Known Text
                   * @description The route encoded in Well Known Text (wkt) format. Either POINT or LINESTRING will be returned
                   */
                  wkt?: string;
                  /**
                   * Format: GeoJson
                   * @description GeoJSON encoded point or linestring
                   */
                  geoJson?: { [key: string]: unknown };
                };
              };
            };
          };
          polyline: unknown;
          WKT: unknown;
          "WKT (With a Point)": unknown;
          GeoJSON: unknown;
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType?: string;
            message?: string;
          };
        };
      };
    };
  };
  /**
   * Query the `/optimize/suggest` endpoint to find the best time to schedule a single job given a set of resources within a specific time range.
   *
   * For example, if a job must be done on Thursday before noon you can specify the time window of 8AM to 12PM on Thursday and the resources that are available to find the best time to schedule the job that morning.
   */
  suggest: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result?: {
              routes?: {
                [key: string]: {
                  /** @description Id of the resource this suggestion is related to. */
                  resourceId?: string;
                  /** @description Flag that signifies whether this resource has already been allocated to the job. */
                  isAllocated?: boolean;
                  route?: {
                    /** @description Duration ( in minutes ) of the current job. */
                    duration?: number;
                    /** @description Id of the current job. */
                    jobId?: string;
                    /** @description Name of the current job ( Job.Name ). */
                    jobName?: string;
                    /**
                     * Format: date-time
                     * @description Suggested start time of the job as an ISO8601 Date Time string.
                     */
                    start?: string;
                    /** @description Travel time ( in minutes ) from the previous location ( resource home or previous job ) to the current job. */
                    travelTime?: number;
                    type?: string;
                  };
                };
              };
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description ID of the job that you want the suggestion for. */
          suggestForNode: string;
          resourceIds: string[];
          /**
           * Format: date-time
           * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
           */
          scheduleStart: string;
          /**
           * Format: date-time
           * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
           */
          scheduleEnd: string;
          schedulingOptions?: {
            /**
             * @description Equalize total allocated duration including travel time for each resource.
             * @default false
             */
            balanceWorkload?: boolean;
            /**
             * @description Attempt to allocate to the fewest number of resources in a scheduling window.
             * @default false
             */
            minimizeResources?: boolean;
            /**
             * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
             * @default true
             */
            jobTimeAsTimeConstraint?: boolean;
            /**
             * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
             * @default true
             */
            preferJobTimeOverTimeConstraint?: boolean;
            /**
             * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
             * @default true
             */
            respectSchedule?: boolean;
            /**
             * @description Ignore all travel times between resources and jobs.
             * @default false
             */
            ignoreTravelTimes?: boolean;
            /**
             * @description Ignore travel time from a resource' home location to the first job.
             * @default false
             */
            ignoreTravelTimeFirstJob?: boolean;
            /**
             * @description Ignore travel time to the resource' home location from the last job.
             * @default false
             */
            ignoreTravelTimeLastJob?: boolean;
            /**
             * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelBeforeStart?: boolean;
            /**
             * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelAfterEnd?: boolean;
            /**
             * @description A fixed interval of time between consecutive jobs.
             * @default 0
             */
            padding?: number;
            /**
             * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
             * @default 0
             */
            snapUnit?: number;
            /**
             * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
             * @default 0
             */
            maxTravelTimeInMinutes?: number;
          };
          /** @description An array of accounts and resources to blacklist */
          accountResourceScores?: {
            /** @description The resource id black listing or white listing jobs associated with the account id */
            resourceId: string;
            /** @description The account id associated with jobs black listing or white listing a resource */
            accountId: string;
            /** @description Is true if the resource and jobs assoicated with the account id are white listed */
            whitelist: boolean;
            /** @description Is true if the resource and jobs associated with the account id are black listed */
            blacklist: boolean;
          }[];
        };
      };
    };
  };
  /**
   * Find the best resources within a given time range, for a given job and resource availabilities.
   *
   * This query provides the amount of time each resource has available during the time period to complete the task.
   */
  "/optimize/resource_suggestions": {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result?: {
              [key: string]: {
                /** @description UID of the resource. */
                resourceId?: string;
                /** @description UID of the current job. */
                jobId?: string;
                /**
                 * Format: date-time
                 * @description Suggested start time of the job as an ISO8601 Date Time string.
                 */
                start?: string;
                /** @description Duration ( in minutes ) of the current job. */
                duration?: number;
                /** @description Travel time ( in minutes ) from the previous location ( resource home or previous job ) to the current job. */
                travelTime?: number;
                /** @description Available capacity for the resource based on currently scheduled jobs. */
                currentCapacityInSeconds?: number;
                /** @description Updated capacity for the resource once this job has been scheduled to the resource. */
                newCapacityInSeconds?: number;
              };
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description UID of the job that you want the suggestion for. */
          jobId: string;
          /** @description A map of availability windows for each resource. */
          resources: {
            [key: string]: {
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              start?: string;
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              end?: string;
            }[];
          };
          /**
           * Format: date-time
           * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
           */
          scheduleStart: string;
          /**
           * Format: date-time
           * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
           */
          scheduleEnd: string;
          schedulingOptions?: {
            /**
             * @description Equalize total allocated duration including travel time for each resource.
             * @default false
             */
            balanceWorkload?: boolean;
            /**
             * @description Attempt to allocate to the fewest number of resources in a scheduling window.
             * @default false
             */
            minimizeResources?: boolean;
            /**
             * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
             * @default true
             */
            jobTimeAsTimeConstraint?: boolean;
            /**
             * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
             * @default true
             */
            preferJobTimeOverTimeConstraint?: boolean;
            /**
             * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
             * @default true
             */
            respectSchedule?: boolean;
            /**
             * @description Ignore all travel times between resources and jobs.
             * @default false
             */
            ignoreTravelTimes?: boolean;
            /**
             * @description Ignore travel time from a resource' home location to the first job.
             * @default false
             */
            ignoreTravelTimeFirstJob?: boolean;
            /**
             * @description Ignore travel time to the resource' home location from the last job.
             * @default false
             */
            ignoreTravelTimeLastJob?: boolean;
            /**
             * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelBeforeStart?: boolean;
            /**
             * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelAfterEnd?: boolean;
            /**
             * @description A fixed interval of time between consecutive jobs.
             * @default 0
             */
            padding?: number;
            /**
             * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
             * @default 0
             */
            snapUnit?: number;
            /**
             * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
             * @default 0
             */
            maxTravelTimeInMinutes?: number;
          };
          /** @description An array of accounts and resources to blacklist */
          accountResourceScores?: {
            /** @description The resource id black listing or white listing jobs associated with the account id */
            resourceId: string;
            /** @description The account id associated with jobs black listing or white listing a resource */
            accountId: string;
            /** @description Is true if the resource and jobs assoicated with the account id are white listed */
            whitelist: boolean;
            /** @description Is true if the resource and jobs associated with the account id are black listed */
            blacklist: boolean;
          }[];
        };
      };
    };
  };
  /**
   * Splits a given time window into intervals of grid size; then aggregates resource availability into it, against the given job. Availability is determined by working hours, holidays, existing jobs and activities. Resource must be available for the entire duration of the slot to be returned in the list.
   *
   * Use the `/grid/schedule` endpoint to find all of the available time slots for a job to be completed during a specified time window. For example, if a job must be completed by the close of business the following day, you can query the `/grid/schedule` endpoint to obtain an aggregate of resource availability between now and tomorrow afternoon at 5PM.
   *
   * The query splits the time window into intervals to determine which resources are available at different times during the time window for the job.
   *
   * * Resource availability is determined by working hours, holidays, existing jobs, shifts, and activities.
   * * Resources must be available for the entire duration of the job slot to be returned in the list.
   */
  "/grid/schedule": {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result?: {
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              start?: string;
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              end?: string;
              /** @description Resource ids of available resources. */
              availableResources?: string[];
            }[];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An array of resource IDs to generate availability slots. */
          resourceIds: string[];
          /** @description Job properties that needs to be considered when generating availability slots for the grid. */
          job: {
            /** @description Geocoordinates of the job. When this is set, travel time is considered when generating slots. */
            location?: {
              /** @description Latitude */
              lat: number;
              /** @description Longitude */
              lng: number;
            };
          };
          /** @description The size of the grid ( in seconds ). The default is 5 minutes (300 seconds). */
          gridSize: number;
          /**
           * Format: date-time
           * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
           */
          scheduleStart: string;
          /**
           * Format: date-time
           * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
           */
          scheduleEnd: string;
        };
      };
    };
  };
  /**
   * This API attempts to schedule jobs against a given list of resources and returns a valid schedule. You can use this endpoint to specify availability windows for resources who are available outside the scheduling window for the job/s you want to schedule. This prevents Planr from returning invalid solutions and provides an extra layer of flexibility in optimized job scheduling.
   *
   * `POST` request for `/optimize/schedule` must include either the `resources` or `resourceIds` property in the body.
   *
   * * The `resourceIds` property is an array.
   * * The `resources` property is an object containing the resource ID along with the working hours start and end timestamp.
   */
  "/optimize/schedule": {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result?: {
              score?: {
                hardScore?: number;
                mediumScore?: number;
                softScore?: number;
              };
              timeToSolve?: number;
              routes?: {
                resourceId?: string;
                resourceName?: string;
                route?: {
                  jobId?: string;
                  jobName?: string;
                  /**
                   * Format: date-time
                   * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                   */
                  start?: string;
                  duration?: number;
                  travelTime?: number;
                  type?: string;
                }[];
              }[];
              unscheduled?: {
                jobId?: string;
                jobName?: string;
                jobReasons?: string[];
                resourceReasons?: {
                  [key: string]: {
                    name?: string;
                    address?: string;
                    reasons?: string[];
                  };
                };
              }[];
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json":
          | {
              /** @description An array of job IDs to schedule resources for */
              jobIds: string[];
              /** @description Resource IDs that can be scheduled for the jobs */
              resources: {
                [key: string]: {
                  /**
                   * Format: date-time
                   * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                   */
                  start?: string;
                  /**
                   * Format: date-time
                   * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                   */
                  end?: string;
                }[];
              };
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              scheduleStart: string;
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              scheduleEnd: string;
              timeZone: string;
              schedulingOptions: {
                /**
                 * @description Equalize total allocated duration including travel time for each resource.
                 * @default false
                 */
                balanceWorkload?: boolean;
                /**
                 * @description Attempt to allocate to the fewest number of resources in a scheduling window.
                 * @default false
                 */
                minimizeResources?: boolean;
                /**
                 * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
                 * @default true
                 */
                jobTimeAsTimeConstraint?: boolean;
                /**
                 * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
                 * @default true
                 */
                preferJobTimeOverTimeConstraint?: boolean;
                /**
                 * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
                 * @default true
                 */
                respectSchedule?: boolean;
                /**
                 * @description Ignore all travel times between resources and jobs.
                 * @default false
                 */
                ignoreTravelTimes?: boolean;
                /**
                 * @description Ignore travel time from a resource' home location to the first job.
                 * @default false
                 */
                ignoreTravelTimeFirstJob?: boolean;
                /**
                 * @description Ignore travel time to the resource' home location from the last job.
                 * @default false
                 */
                ignoreTravelTimeLastJob?: boolean;
                /**
                 * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
                 * @default false
                 */
                assumeResourceCanTravelBeforeStart?: boolean;
                /**
                 * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
                 * @default false
                 */
                assumeResourceCanTravelAfterEnd?: boolean;
                /**
                 * @description A fixed interval of time between consecutive jobs.
                 * @default 0
                 */
                padding?: number;
                /**
                 * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
                 * @default 0
                 */
                snapUnit?: number;
                /**
                 * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
                 * @default 0
                 */
                maxTravelTimeInMinutes?: number;
              };
              responseConfig?: {
                /**
                 * @description The scheduled jobs returned are only the jobs optimized. Jobs that are fixed (resource and time) are not returned
                 * @default false
                 */
                optimizedJobsOnly?: boolean;
              };
            }
          | {
              /** @description An array of job IDs to schedule resources for */
              jobIds: string[];
              /** @description An array of resource ids that can be schedules for the jobs */
              resourceIds: string[];
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              scheduleStart: string;
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              scheduleEnd: string;
              timeZone: string;
              schedulingOptions: {
                /**
                 * @description Equalize total allocated duration including travel time for each resource.
                 * @default false
                 */
                balanceWorkload?: boolean;
                /**
                 * @description Attempt to allocate to the fewest number of resources in a scheduling window.
                 * @default false
                 */
                minimizeResources?: boolean;
                /**
                 * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
                 * @default true
                 */
                jobTimeAsTimeConstraint?: boolean;
                /**
                 * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
                 * @default true
                 */
                preferJobTimeOverTimeConstraint?: boolean;
                /**
                 * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
                 * @default true
                 */
                respectSchedule?: boolean;
                /**
                 * @description Ignore all travel times between resources and jobs.
                 * @default false
                 */
                ignoreTravelTimes?: boolean;
                /**
                 * @description Ignore travel time from a resource' home location to the first job.
                 * @default false
                 */
                ignoreTravelTimeFirstJob?: boolean;
                /**
                 * @description Ignore travel time to the resource' home location from the last job.
                 * @default false
                 */
                ignoreTravelTimeLastJob?: boolean;
                /**
                 * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
                 * @default false
                 */
                assumeResourceCanTravelBeforeStart?: boolean;
                /**
                 * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
                 * @default false
                 */
                assumeResourceCanTravelAfterEnd?: boolean;
                /**
                 * @description A fixed interval of time between consecutive jobs.
                 * @default 0
                 */
                padding?: number;
                /**
                 * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
                 * @default 0
                 */
                snapUnit?: number;
                /**
                 * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
                 * @default 0
                 */
                maxTravelTimeInMinutes?: number;
              };
              responseConfig?: {
                /**
                 * @description The scheduled jobs returned are only the jobs optimized. Jobs that are fixed (resource and time) are not returned
                 * @default false
                 */
                optimizedJobsOnly?: boolean;
              };
            };
      };
    };
  };
  /** The Travel Time endpoint will approximate how long it takes for a resource to travel between destinations. It will filter down to relevant availability windows (ignoring destinations outside the resource's availability), order the work to be completed, and finally calculate the travel time between each destination. The result will contain only the node identifier and the relevant travel time. */
  "/geoservices/travel-time": {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The response will contain successful travel times grouped by the Nodes id */
            result?: { [key: string]: unknown };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          resources: {
            /** @description The identifier of the resource */
            id?: string;
            /** @description Geocoordinates of the activity/job/resource */
            origin?: {
              /** @description Latitude */
              lat: number;
              /** @description Longitude */
              lng: number;
            };
            /** @description The time windows when a resource is available */
            availabilities?: {
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              start: string;
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              end: string;
            }[];
          }[];
          nodes: {
            /** @description The requesting system's identifier that needs travel time */
            id: string;
            /** @description The identifier of the resource to determine routes and waypoints */
            resourceId: string;
            /**
             * Format: date-time
             * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
             */
            start: string;
            /**
             * Format: date-time
             * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
             */
            end: string;
            /** @description Latitude */
            lat?: number;
            /** @description Longitude */
            lng?: number;
          }[];
          schedulingOptions?: {
            /**
             * @description Equalize total allocated duration including travel time for each resource.
             * @default false
             */
            balanceWorkload?: boolean;
            /**
             * @description Attempt to allocate to the fewest number of resources in a scheduling window.
             * @default false
             */
            minimizeResources?: boolean;
            /**
             * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
             * @default true
             */
            jobTimeAsTimeConstraint?: boolean;
            /**
             * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
             * @default true
             */
            preferJobTimeOverTimeConstraint?: boolean;
            /**
             * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
             * @default true
             */
            respectSchedule?: boolean;
            /**
             * @description Ignore all travel times between resources and jobs.
             * @default false
             */
            ignoreTravelTimes?: boolean;
            /**
             * @description Ignore travel time from a resource' home location to the first job.
             * @default false
             */
            ignoreTravelTimeFirstJob?: boolean;
            /**
             * @description Ignore travel time to the resource' home location from the last job.
             * @default false
             */
            ignoreTravelTimeLastJob?: boolean;
            /**
             * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelBeforeStart?: boolean;
            /**
             * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelAfterEnd?: boolean;
            /**
             * @description A fixed interval of time between consecutive jobs.
             * @default 0
             */
            padding?: number;
            /**
             * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
             * @default 0
             */
            snapUnit?: number;
            /**
             * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
             * @default 0
             */
            maxTravelTimeInMinutes?: number;
          };
        };
      };
    };
  };
  batchSchedulesList: {
    parameters: {
      query: {
        /**
         * Return results at this record offset.
         * NOTE: Mutually exclusive to `after`.
         */
        offset?: number;
        /**
         * Taken from the page result `nextCursor`
         * NOTE: Mutually exclusive to `offset`.
         */
        after?: string;
        limit?: number;
        ids?: string[];
        statuses?: "deleted"[];
        name?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            paging: {
              total?: number;
              limit: number;
              /**
               * @description Returns an opaque cursor for the "next" page of results.
               * This can be used when sequentially paging over the result instead of having to calculate the next offset.
               */
              nextCursor?: string;
            };
            result: ({
              /** @description The name of the schedule. */
              name: string;
              /** @description The name of the type of jobs query. */
              jobQuery: string;
              /** @description The resource types included in the query. */
              resourceQuery: string;
              /** @description The Region ID in which job/resource queries are run against. */
              region: string;
              /** @description The day in which to execute this schedule the first time. */
              runDate: string;
              /** @description The timezone in which to run this schedule, which affects the runDate and start/end times. */
              timezone: string;
              /** @description The time of day (in the given timezone) to run this schedule. */
              earliestStartTime: string;
              /**
               * @description The (optional) time of day (in the given timezone) in which the results of this optimization _must_ be completed before.
               * This is only a time (and not a duration) as optimizations can only run within a 24 hour window.
               * eg. If the earliestStartTime is 16:00 then 15:00 refers to 3pm the next day.
               */
              latestEndTime?: string;
              /**
               * @description The number of days in which to optimize.
               *
               * NOTE: Optimization occurs across an entire day, from 12:00am to 11:59pm
               */
              dayRange: number;
              /** @description The number of days to optimize ahead of the scheduled run. */
              dayOffset: number;
              schedulingOptions?: {
                /**
                 * @description Equalize total allocated duration including travel time for each resource.
                 * @default false
                 */
                balanceWorkload?: boolean;
                /**
                 * @description Attempt to allocate to the fewest number of resources in a scheduling window.
                 * @default false
                 */
                minimizeResources?: boolean;
                /**
                 * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
                 * @default true
                 */
                jobTimeAsTimeConstraint?: boolean;
                /**
                 * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
                 * @default true
                 */
                preferJobTimeOverTimeConstraint?: boolean;
                /**
                 * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
                 * @default true
                 */
                respectSchedule?: boolean;
                /**
                 * @description Ignore all travel times between resources and jobs.
                 * @default false
                 */
                ignoreTravelTimes?: boolean;
                /**
                 * @description Ignore travel time from a resource' home location to the first job.
                 * @default false
                 */
                ignoreTravelTimeFirstJob?: boolean;
                /**
                 * @description Ignore travel time to the resource' home location from the last job.
                 * @default false
                 */
                ignoreTravelTimeLastJob?: boolean;
                /**
                 * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
                 * @default false
                 */
                assumeResourceCanTravelBeforeStart?: boolean;
                /**
                 * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
                 * @default false
                 */
                assumeResourceCanTravelAfterEnd?: boolean;
                /**
                 * @description A fixed interval of time between consecutive jobs.
                 * @default 0
                 */
                padding?: number;
                /**
                 * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
                 * @default 0
                 */
                snapUnit?: number;
                /**
                 * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
                 * @default 0
                 */
                maxTravelTimeInMinutes?: number;
              };
              recurring?: {
                /**
                 * @description The number of days/months/years between each generated interval.
                 * For example, with repeatMode = 'daily' and step = 1, an interval will be generated every day.
                 */
                step: number;
                /**
                 * @description How occurences are repeated
                 * @enum {string}
                 */
                repeatMode: "daily" | "weekly" | "monthly_nth_day" | "yearly";
                /**
                 * @description The day of the month on which the schedule should run. This is required when the `repeatMode` is `monthly_nth_day`.
                 *
                 * @example 1
                 */
                dayOfMonthToRepeatOn?: number;
                /**
                 * @description Number of occurrence to generate. If using this, do not provide endOn.
                 * If neither are provided then never end.
                 *
                 * Note: when repeatMode is 'weekly', this value means the number of week periods to generate the intervals from,
                 * So when endAfterNumberOccurrences = 4, only the next 4 weeks will be checked (some weeks may not generated an interval due
                 * to other rules, leading to less than 4 intervals being generated in total).
                 *
                 * @example 5
                 */
                endAfterNumberOccurrences?: number;
                /**
                 * Format: date
                 * @description Date the pattern should end on. If using this, do not provide endAfterNumberOccurrences.
                 * If neither are provided then never end.
                 *
                 * @example 2020-05-13T00:00:00.000Z
                 */
                endOn?: string;
                /** @description The days of week intervals can occur on. Only applies when repeatMode = 'daily' or 'weekly'. */
                repeatOnWeekDays?: (
                  | "mon"
                  | "tue"
                  | "wed"
                  | "thu"
                  | "fri"
                  | "sat"
                  | "sun"
                )[];
              };
            } & {
              /** Format: uuid */
              id: string;
              lastModifiedByUserId: string;
              /** Format: date-time */
              lastModifiedByDate: string;
              createdByUserId: string;
              /** Format: date-time */
              createdByDate: string;
              /** Format: date-time */
              lastRun?: string;
              /** Format: date-time */
              nextRun?: string;
              /** @enum {string} */
              status?: "deleted";
            })[];
          };
        };
      };
    };
  };
  batchScheduleCreate: {
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            id?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The name of the schedule. */
          name: string;
          /** @description The name of the type of jobs query. */
          jobQuery: string;
          /** @description The resource types included in the query. */
          resourceQuery: string;
          /** @description The Region ID in which job/resource queries are run against. */
          region: string;
          /** @description The day in which to execute this schedule the first time. */
          runDate: string;
          /** @description The timezone in which to run this schedule, which affects the runDate and start/end times. */
          timezone: string;
          /** @description The time of day (in the given timezone) to run this schedule. */
          earliestStartTime: string;
          /**
           * @description The (optional) time of day (in the given timezone) in which the results of this optimization _must_ be completed before.
           * This is only a time (and not a duration) as optimizations can only run within a 24 hour window.
           * eg. If the earliestStartTime is 16:00 then 15:00 refers to 3pm the next day.
           */
          latestEndTime?: string;
          /**
           * @description The number of days in which to optimize.
           *
           * NOTE: Optimization occurs across an entire day, from 12:00am to 11:59pm
           */
          dayRange: number;
          /** @description The number of days to optimize ahead of the scheduled run. */
          dayOffset: number;
          schedulingOptions?: {
            /**
             * @description Equalize total allocated duration including travel time for each resource.
             * @default false
             */
            balanceWorkload?: boolean;
            /**
             * @description Attempt to allocate to the fewest number of resources in a scheduling window.
             * @default false
             */
            minimizeResources?: boolean;
            /**
             * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
             * @default true
             */
            jobTimeAsTimeConstraint?: boolean;
            /**
             * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
             * @default true
             */
            preferJobTimeOverTimeConstraint?: boolean;
            /**
             * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
             * @default true
             */
            respectSchedule?: boolean;
            /**
             * @description Ignore all travel times between resources and jobs.
             * @default false
             */
            ignoreTravelTimes?: boolean;
            /**
             * @description Ignore travel time from a resource' home location to the first job.
             * @default false
             */
            ignoreTravelTimeFirstJob?: boolean;
            /**
             * @description Ignore travel time to the resource' home location from the last job.
             * @default false
             */
            ignoreTravelTimeLastJob?: boolean;
            /**
             * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelBeforeStart?: boolean;
            /**
             * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelAfterEnd?: boolean;
            /**
             * @description A fixed interval of time between consecutive jobs.
             * @default 0
             */
            padding?: number;
            /**
             * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
             * @default 0
             */
            snapUnit?: number;
            /**
             * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
             * @default 0
             */
            maxTravelTimeInMinutes?: number;
          };
          recurring?: {
            /**
             * @description The number of days/months/years between each generated interval.
             * For example, with repeatMode = 'daily' and step = 1, an interval will be generated every day.
             */
            step: number;
            /**
             * @description How occurences are repeated
             * @enum {string}
             */
            repeatMode: "daily" | "weekly" | "monthly_nth_day" | "yearly";
            /**
             * @description The day of the month on which the schedule should run. This is required when the `repeatMode` is `monthly_nth_day`.
             *
             * @example 1
             */
            dayOfMonthToRepeatOn?: number;
            /**
             * @description Number of occurrence to generate. If using this, do not provide endOn.
             * If neither are provided then never end.
             *
             * Note: when repeatMode is 'weekly', this value means the number of week periods to generate the intervals from,
             * So when endAfterNumberOccurrences = 4, only the next 4 weeks will be checked (some weeks may not generated an interval due
             * to other rules, leading to less than 4 intervals being generated in total).
             *
             * @example 5
             */
            endAfterNumberOccurrences?: number;
            /**
             * Format: date
             * @description Date the pattern should end on. If using this, do not provide endAfterNumberOccurrences.
             * If neither are provided then never end.
             *
             * @example 2020-05-13T00:00:00.000Z
             */
            endOn?: string;
            /** @description The days of week intervals can occur on. Only applies when repeatMode = 'daily' or 'weekly'. */
            repeatOnWeekDays?: (
              | "mon"
              | "tue"
              | "wed"
              | "thu"
              | "fri"
              | "sat"
              | "sun"
            )[];
          };
        };
      };
    };
  };
  batchScheduleGet: {
    parameters: {
      path: {
        schedule_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The name of the schedule. */
            name: string;
            /** @description The name of the type of jobs query. */
            jobQuery: string;
            /** @description The resource types included in the query. */
            resourceQuery: string;
            /** @description The Region ID in which job/resource queries are run against. */
            region: string;
            /** @description The day in which to execute this schedule the first time. */
            runDate: string;
            /** @description The timezone in which to run this schedule, which affects the runDate and start/end times. */
            timezone: string;
            /** @description The time of day (in the given timezone) to run this schedule. */
            earliestStartTime: string;
            /**
             * @description The (optional) time of day (in the given timezone) in which the results of this optimization _must_ be completed before.
             * This is only a time (and not a duration) as optimizations can only run within a 24 hour window.
             * eg. If the earliestStartTime is 16:00 then 15:00 refers to 3pm the next day.
             */
            latestEndTime?: string;
            /**
             * @description The number of days in which to optimize.
             *
             * NOTE: Optimization occurs across an entire day, from 12:00am to 11:59pm
             */
            dayRange: number;
            /** @description The number of days to optimize ahead of the scheduled run. */
            dayOffset: number;
            schedulingOptions?: {
              /**
               * @description Equalize total allocated duration including travel time for each resource.
               * @default false
               */
              balanceWorkload?: boolean;
              /**
               * @description Attempt to allocate to the fewest number of resources in a scheduling window.
               * @default false
               */
              minimizeResources?: boolean;
              /**
               * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
               * @default true
               */
              jobTimeAsTimeConstraint?: boolean;
              /**
               * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
               * @default true
               */
              preferJobTimeOverTimeConstraint?: boolean;
              /**
               * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
               * @default true
               */
              respectSchedule?: boolean;
              /**
               * @description Ignore all travel times between resources and jobs.
               * @default false
               */
              ignoreTravelTimes?: boolean;
              /**
               * @description Ignore travel time from a resource' home location to the first job.
               * @default false
               */
              ignoreTravelTimeFirstJob?: boolean;
              /**
               * @description Ignore travel time to the resource' home location from the last job.
               * @default false
               */
              ignoreTravelTimeLastJob?: boolean;
              /**
               * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
               * @default false
               */
              assumeResourceCanTravelBeforeStart?: boolean;
              /**
               * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
               * @default false
               */
              assumeResourceCanTravelAfterEnd?: boolean;
              /**
               * @description A fixed interval of time between consecutive jobs.
               * @default 0
               */
              padding?: number;
              /**
               * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
               * @default 0
               */
              snapUnit?: number;
              /**
               * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
               * @default 0
               */
              maxTravelTimeInMinutes?: number;
            };
            recurring?: {
              /**
               * @description The number of days/months/years between each generated interval.
               * For example, with repeatMode = 'daily' and step = 1, an interval will be generated every day.
               */
              step: number;
              /**
               * @description How occurences are repeated
               * @enum {string}
               */
              repeatMode: "daily" | "weekly" | "monthly_nth_day" | "yearly";
              /**
               * @description The day of the month on which the schedule should run. This is required when the `repeatMode` is `monthly_nth_day`.
               *
               * @example 1
               */
              dayOfMonthToRepeatOn?: number;
              /**
               * @description Number of occurrence to generate. If using this, do not provide endOn.
               * If neither are provided then never end.
               *
               * Note: when repeatMode is 'weekly', this value means the number of week periods to generate the intervals from,
               * So when endAfterNumberOccurrences = 4, only the next 4 weeks will be checked (some weeks may not generated an interval due
               * to other rules, leading to less than 4 intervals being generated in total).
               *
               * @example 5
               */
              endAfterNumberOccurrences?: number;
              /**
               * Format: date
               * @description Date the pattern should end on. If using this, do not provide endAfterNumberOccurrences.
               * If neither are provided then never end.
               *
               * @example 2020-05-13T00:00:00.000Z
               */
              endOn?: string;
              /** @description The days of week intervals can occur on. Only applies when repeatMode = 'daily' or 'weekly'. */
              repeatOnWeekDays?: (
                | "mon"
                | "tue"
                | "wed"
                | "thu"
                | "fri"
                | "sat"
                | "sun"
              )[];
            };
          } & {
            /** Format: uuid */
            id: string;
            lastModifiedByUserId: string;
            /** Format: date-time */
            lastModifiedByDate: string;
            createdByUserId: string;
            /** Format: date-time */
            createdByDate: string;
            /** Format: date-time */
            lastRun?: string;
            /** Format: date-time */
            nextRun?: string;
            /** @enum {string} */
            status?: "deleted";
          };
        };
      };
      /** The batch schedule does not exist */
      404: unknown;
    };
  };
  batchscheduleUpsert: {
    parameters: {
      path: {
        schedule_id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The name of the schedule. */
          name: string;
          /** @description The name of the type of jobs query. */
          jobQuery: string;
          /** @description The resource types included in the query. */
          resourceQuery: string;
          /** @description The Region ID in which job/resource queries are run against. */
          region: string;
          /** @description The day in which to execute this schedule the first time. */
          runDate: string;
          /** @description The timezone in which to run this schedule, which affects the runDate and start/end times. */
          timezone: string;
          /** @description The time of day (in the given timezone) to run this schedule. */
          earliestStartTime: string;
          /**
           * @description The (optional) time of day (in the given timezone) in which the results of this optimization _must_ be completed before.
           * This is only a time (and not a duration) as optimizations can only run within a 24 hour window.
           * eg. If the earliestStartTime is 16:00 then 15:00 refers to 3pm the next day.
           */
          latestEndTime?: string;
          /**
           * @description The number of days in which to optimize.
           *
           * NOTE: Optimization occurs across an entire day, from 12:00am to 11:59pm
           */
          dayRange: number;
          /** @description The number of days to optimize ahead of the scheduled run. */
          dayOffset: number;
          schedulingOptions?: {
            /**
             * @description Equalize total allocated duration including travel time for each resource.
             * @default false
             */
            balanceWorkload?: boolean;
            /**
             * @description Attempt to allocate to the fewest number of resources in a scheduling window.
             * @default false
             */
            minimizeResources?: boolean;
            /**
             * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
             * @default true
             */
            jobTimeAsTimeConstraint?: boolean;
            /**
             * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
             * @default true
             */
            preferJobTimeOverTimeConstraint?: boolean;
            /**
             * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
             * @default true
             */
            respectSchedule?: boolean;
            /**
             * @description Ignore all travel times between resources and jobs.
             * @default false
             */
            ignoreTravelTimes?: boolean;
            /**
             * @description Ignore travel time from a resource' home location to the first job.
             * @default false
             */
            ignoreTravelTimeFirstJob?: boolean;
            /**
             * @description Ignore travel time to the resource' home location from the last job.
             * @default false
             */
            ignoreTravelTimeLastJob?: boolean;
            /**
             * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelBeforeStart?: boolean;
            /**
             * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
             * @default false
             */
            assumeResourceCanTravelAfterEnd?: boolean;
            /**
             * @description A fixed interval of time between consecutive jobs.
             * @default 0
             */
            padding?: number;
            /**
             * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
             * @default 0
             */
            snapUnit?: number;
            /**
             * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
             * @default 0
             */
            maxTravelTimeInMinutes?: number;
          };
          recurring?: {
            /**
             * @description The number of days/months/years between each generated interval.
             * For example, with repeatMode = 'daily' and step = 1, an interval will be generated every day.
             */
            step: number;
            /**
             * @description How occurences are repeated
             * @enum {string}
             */
            repeatMode: "daily" | "weekly" | "monthly_nth_day" | "yearly";
            /**
             * @description The day of the month on which the schedule should run. This is required when the `repeatMode` is `monthly_nth_day`.
             *
             * @example 1
             */
            dayOfMonthToRepeatOn?: number;
            /**
             * @description Number of occurrence to generate. If using this, do not provide endOn.
             * If neither are provided then never end.
             *
             * Note: when repeatMode is 'weekly', this value means the number of week periods to generate the intervals from,
             * So when endAfterNumberOccurrences = 4, only the next 4 weeks will be checked (some weeks may not generated an interval due
             * to other rules, leading to less than 4 intervals being generated in total).
             *
             * @example 5
             */
            endAfterNumberOccurrences?: number;
            /**
             * Format: date
             * @description Date the pattern should end on. If using this, do not provide endAfterNumberOccurrences.
             * If neither are provided then never end.
             *
             * @example 2020-05-13T00:00:00.000Z
             */
            endOn?: string;
            /** @description The days of week intervals can occur on. Only applies when repeatMode = 'daily' or 'weekly'. */
            repeatOnWeekDays?: (
              | "mon"
              | "tue"
              | "wed"
              | "thu"
              | "fri"
              | "sat"
              | "sun"
            )[];
          };
        };
      };
    };
  };
  batchScheduleDelete: {
    parameters: {
      path: {
        schedule_id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
    };
  };
  /**
   * This API attempts to schedule jobs against a given list of resources and returns a valid schedule.
   * You can use this endpoint to specify availability windows for resources who are available outside the scheduling
   * window for the job/s you want to schedule. This prevents the optimizer from returning invalid solutions and
   * provides an extra layer of flexibility in optimized job scheduling.
   */
  schedule: {
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            result?: {
              /** Format: uuid */
              id?: string;
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": (
          | {
              /** @description An array of resource ids that can be schedules for the jobs */
              resourceIds: string[];
            }
          | {
              /** @description Resource IDs that can be scheduled for the jobs */
              resources: {
                [key: string]: {
                  /**
                   * Format: date-time
                   * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                   */
                  start?: string;
                  /**
                   * Format: date-time
                   * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                   */
                  end?: string;
                }[];
              };
            }
        ) &
          ({
            /** @description An array of job IDs to schedule resources for */
            jobIds: string[];
            /**
             * Format: date-time
             * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
             */
            scheduleStart: string;
            /**
             * Format: date-time
             * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
             */
            scheduleEnd: string;
            timeZone: string;
            schedulingOptions: {
              /**
               * @description Equalize total allocated duration including travel time for each resource.
               * @default false
               */
              balanceWorkload?: boolean;
              /**
               * @description Attempt to allocate to the fewest number of resources in a scheduling window.
               * @default false
               */
              minimizeResources?: boolean;
              /**
               * @description When a job has a time set, consider it to be a time constraint and never re-schedule to another time slot.
               * @default true
               */
              jobTimeAsTimeConstraint?: boolean;
              /**
               * @description When a job with a JobTimeConstraint also has a time set, consider the job time as the authoritative constraint and ignore the JobTimeConstraint.
               * @default true
               */
              preferJobTimeOverTimeConstraint?: boolean;
              /**
               * @description For a job that is allocated and in "Pending Dispatch" status, do not move the job to a different time.
               * @default true
               */
              respectSchedule?: boolean;
              /**
               * @description Ignore all travel times between resources and jobs.
               * @default false
               */
              ignoreTravelTimes?: boolean;
              /**
               * @description Ignore travel time from a resource' home location to the first job.
               * @default false
               */
              ignoreTravelTimeFirstJob?: boolean;
              /**
               * @description Ignore travel time to the resource' home location from the last job.
               * @default false
               */
              ignoreTravelTimeLastJob?: boolean;
              /**
               * @description Ignore travel time to first job when deriving its arrival time however include the travel time when considering overall travel time reduction.
               * @default false
               */
              assumeResourceCanTravelBeforeStart?: boolean;
              /**
               * @description Assume that the resource can travel after their end time to get to their end location however include the travel time when considering overall travel time reduction.
               * @default false
               */
              assumeResourceCanTravelAfterEnd?: boolean;
              /**
               * @description A fixed interval of time between consecutive jobs.
               * @default 0
               */
              padding?: number;
              /**
               * @description Divide the given time frame into parts described by this value and allocate all jobs to the nearest part.
               * @default 0
               */
              snapUnit?: number;
              /**
               * @description When greater than zero do not schedule nodes whose travel time would exceed this value in minutes.
               * @default 0
               */
              maxTravelTimeInMinutes?: number;
            };
            /**
             * @description Whether an optimization should persist the results on successful completion.
             *
             * @enum {string}
             */
            persistenceStrategy?: "save" | "optimize";
          } & {
            resources: unknown;
          });
      };
    };
  };
  getRunSave: {
    parameters: {
      path: {
        run_id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result?:
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'saved' as value */
                  state?: string;
                  change?: {
                    deleteAllocationsIds?: string[];
                    insertAllocations?: {
                      resourceId?: string;
                      jobId?: string;
                      resourceRequirementId?: string;
                    }[];
                    updateJobs?: {
                      jobId?: string;
                      /**
                       * Format: date-time
                       * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                       */
                      start?: string;
                      /**
                       * Format: date-time
                       * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                       */
                      end?: string;
                    }[];
                  };
                })
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'rejected' as value */
                  state?: string;
                })
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'error' as value */
                  state?: string;
                  message?: string;
                });
          };
        };
      };
      /** Run not found */
      404: unknown;
    };
  };
  saveRun: {
    parameters: {
      path: {
        run_id: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            result?:
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'saved' as value */
                  state?: string;
                  change?: {
                    deleteAllocationsIds?: string[];
                    insertAllocations?: {
                      resourceId?: string;
                      jobId?: string;
                      resourceRequirementId?: string;
                    }[];
                    updateJobs?: {
                      jobId?: string;
                      /**
                       * Format: date-time
                       * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                       */
                      start?: string;
                      /**
                       * Format: date-time
                       * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                       */
                      end?: string;
                    }[];
                  };
                })
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'rejected' as value */
                  state?: string;
                })
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'error' as value */
                  state?: string;
                  message?: string;
                });
          };
        };
      };
    };
  };
  /** Reject the run save. Saved or failed run cannot be rejected. */
  rejectRun: {
    parameters: {
      path: {
        run_id: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            result?:
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'saved' as value */
                  state?: string;
                  change?: {
                    deleteAllocationsIds?: string[];
                    insertAllocations?: {
                      resourceId?: string;
                      jobId?: string;
                      resourceRequirementId?: string;
                    }[];
                    updateJobs?: {
                      jobId?: string;
                      /**
                       * Format: date-time
                       * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                       */
                      start?: string;
                      /**
                       * Format: date-time
                       * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                       */
                      end?: string;
                    }[];
                  };
                })
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'rejected' as value */
                  state?: string;
                })
              | ({
                  autoApplied?: boolean;
                  /** Format: uuid */
                  runId?: string;
                  meta?: {
                    userId?: string;
                    /**
                     * Format: date-time
                     * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                     */
                    date?: string;
                  };
                } & {
                  /** @description Use 'error' as value */
                  state?: string;
                  message?: string;
                });
          };
        };
      };
    };
  };
  getRuns: {
    parameters: {
      query: {
        /**
         * Return results at this record offset.
         * NOTE: Mutually exclusive to `after`.
         */
        offset?: number;
        /**
         * Taken from the page result `nextCursor`
         * NOTE: Mutually exclusive to `offset`.
         */
        after?: string;
        limit?: number;
        schedule_id?: string[];
        schedule_ids?: string[];
        types?: ("one-off" | "batch")[];
        users?: string[];
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            paging: {
              total?: number;
              limit: number;
              /**
               * @description Returns an opaque cursor for the "next" page of results.
               * This can be used when sequentially paging over the result instead of having to calculate the next offset.
               */
              nextCursor?: string;
            };
            result: {
              /** Format: uuid */
              id: string;
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              start: string;
              /** @enum {string} */
              status: "pending" | "processing" | "complete" | "failed";
              /**
               * Format: date-time
               * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
               */
              completedAt?: string;
              /**
               * Format: uuid
               * @description An optional field that indicates when this run was triggered from a batch schedule.
               */
              scheduleId?: string;
              createdByUserId: string;
              label: string;
              summary?: {
                totalPlannedJobs: number;
                totalScheduledJobs: number;
              };
            }[];
          };
        };
      };
    };
  };
  getOptimizationResult: {
    parameters: {
      path: {
        run_id: string;
      };
      query: {
        /** The scheduled jobs returned are only the jobs optimized. Jobs that are fixed (resource and time) are not returned */
        optimizedJobsOnly?: boolean;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result?: {
              score?: {
                hardScore?: number;
                mediumScore?: number;
                softScore?: number;
              };
              timeToSolve?: number;
              routes?: {
                resourceId?: string;
                resourceName?: string;
                route?: {
                  jobId?: string;
                  jobName?: string;
                  /**
                   * Format: date-time
                   * @description Can be either ISO8601 date time string or Unix timestamp number ( in milliseconds ). Always returned in ISO8601 format.
                   */
                  start?: string;
                  duration?: number;
                  travelTime?: number;
                  type?: string;
                }[];
              }[];
              unscheduled?: {
                jobId?: string;
                jobName?: string;
                jobReasons?: string[];
                resourceReasons?: {
                  [key: string]: {
                    name?: string;
                    address?: string;
                    reasons?: string[];
                  };
                };
              }[];
            };
          };
        };
      };
      /** Error */
      409: {
        content: {
          "application/json":
            | {
                /** @enum {string} */
                errorType?: "optimization_running";
                message?: string;
              }
            | {
                /** @enum {string} */
                errorType?: "optimization_error";
                message?: string;
              };
        };
      };
    };
  };
  /**
   * Run queries and mutations against the schema using the `/graphql/graphql` endpoint.
   *
   * Queries and mutations are `POST` operations with a GraphQL payload that defines shape of the query or mutation you want to make against the schema. A mutation with multiple operations is executed as an atomic transaction.
   *
   * The response may include standard Skedulo objects and custom objects and fields you have defined.
   *
   * To improve the performance of query operations on Skedulo Platform, set the header X-Skedulo-Read-Only=true. This will execute against a read replica database and will produce an error if any write operation is attempted. Beware of race conditions - there may be a small delay between a write being executed and the data being available on the read replica.
   */
  graphql: {
    responses: {
      /** Query or Mutation result was returned */
      200: {
        content: {
          "application/json": {
            /** @description Query or mutation result. */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          };
        };
      };
      /** Query or Mutation failed, an error is returned.  The `data` property will be null in this case. */
      400: {
        content: {
          "application/json": {
            /** @description Query or mutation result. */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          };
        };
      };
      /** Authentication/Authorization failed */
      401: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /**
   * GraphQL batching involves sending multiple queries or mutations to the server in a single request. This reduces the number of server round trips to fetch data, which makes interaction more efficient.
   *
   * See https://blog.apollographql.com/query-batching-in-apollo-63acfd859862 for more information
   */
  graphqlBatch: {
    responses: {
      /** An array of Query or Mutation results corresponding to the input */
      200: {
        content: {
          "application/json": {
            /** @description Query or mutation result. */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          }[];
        };
      };
      /** Authentication/Authorization failed */
      401: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /**
   * GraphQL Subscriptions via Apollo `graphql-ws` protocol.
   *
   * * Your tenant must have an API user.
   *
   * * You must be a 'Scheduler' or 'Administrator'.
   *
   * The `Authorization` header must be passed in the `connection_init` message.
   */
  graphqlSubscriptions: {
    responses: {
      /** WebSocket connection succeeded */
      101: {
        content: {
          "*/*": {
            /** @description Query or mutation result. */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          };
        };
      };
      /** If the WebSocket protocol was not 'graphql-ws' */
      400: {
        content: {
          "*/*": {
            /** @description Query or mutation result. */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          };
        };
      };
      /** Error */
      default: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Retrieve the Skedulo GraphQL schema. */
  graphqlSchema: {
    responses: {
      /** Schema was returned */
      200: unknown;
      /** Authentication/Authorization failed */
      401: {
        content: {
          "application/text": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/text": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Perform an introspection query against the GraphQL query that is used for webhooks with type `graphql`. */
  webhookGraphQLQuery: {
    responses: {
      /** Introspection query was returned. */
      200: {
        content: {
          "application/json": {
            /** @description Query result */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          };
        };
      };
      /** Invalid query */
      400: {
        content: {
          "application/json": {
            /** @description Query result */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Perform an introspection query against the GraphQL query that is used for webhooks with type `graphql_deferred`. */
  webhookDeferredGraphQLQuery: {
    responses: {
      /** Introspection query was returned. */
      200: {
        content: {
          "application/json": {
            /** @description Query result */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          };
        };
      };
      /** Invalid query */
      400: {
        content: {
          "application/json": {
            /** @description Query result */
            data?: { [key: string]: unknown };
            errors?: {
              /** @description Error message. */
              message?: string;
              location?: {
                /** @description Line Number */
                line?: string;
                /** @description Column number */
                column?: string;
              };
            }[];
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Fetch all existing webhooks. */
  webhooksFetch: {
    responses: {
      /** success */
      200: {
        content: {
          "application/json": {
            result: (
              | (({
                  /** Format: uuid */
                  id: string;
                  name: string;
                  /** Format: uri */
                  url: string;
                  headers: { [key: string]: unknown };
                } & {
                  type: unknown;
                }) & {
                  /** @enum {string} */
                  type: "graphql";
                  query: string;
                })
              | (({
                  /** Format: uuid */
                  id: string;
                  name: string;
                  /** Format: uri */
                  url: string;
                  headers: { [key: string]: unknown };
                } & {
                  type: unknown;
                }) & {
                  /** @enum {string} */
                  type: "graphql_deferred";
                  filter?: string;
                  name: string;
                  offset:
                    | number
                    | {
                        fieldName: string;
                        /** Format: int64 */
                        default?: number;
                      };
                  query: string;
                })
              | (({
                  /** Format: uuid */
                  id: string;
                  name: string;
                  /** Format: uri */
                  url: string;
                  headers: { [key: string]: unknown };
                } & {
                  type: unknown;
                }) & {
                  /** @enum {string} */
                  type: "scheduled";
                  cron: string;
                })
              | (({
                  /** Format: uuid */
                  id: string;
                  name: string;
                  /** Format: uri */
                  url: string;
                  headers: { [key: string]: unknown };
                } & {
                  type: unknown;
                }) & {
                  /** @enum {string} */
                  type: "inbound_sms";
                })
            )[];
          };
        };
      };
      /** If the user is not an administrator */
      403: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Establish a new webhook. */
  webhooksCreate: {
    responses: {
      /** success */
      200: {
        content: {
          "application/json": {
            result: (
              | (({
                  /** Format: uuid */
                  id: string;
                  name: string;
                  /** Format: uri */
                  url: string;
                  headers: { [key: string]: unknown };
                } & {
                  type: unknown;
                }) & {
                  /** @enum {string} */
                  type: "graphql";
                  query: string;
                })
              | (({
                  /** Format: uuid */
                  id: string;
                  name: string;
                  /** Format: uri */
                  url: string;
                  headers: { [key: string]: unknown };
                } & {
                  type: unknown;
                }) & {
                  /** @enum {string} */
                  type: "graphql_deferred";
                  filter?: string;
                  name: string;
                  offset:
                    | number
                    | {
                        fieldName: string;
                        /** Format: int64 */
                        default?: number;
                      };
                  query: string;
                })
              | (({
                  /** Format: uuid */
                  id: string;
                  name: string;
                  /** Format: uri */
                  url: string;
                  headers: { [key: string]: unknown };
                } & {
                  type: unknown;
                }) & {
                  /** @enum {string} */
                  type: "scheduled";
                  cron: string;
                })
              | (({
                  /** Format: uuid */
                  id: string;
                  name: string;
                  /** Format: uri */
                  url: string;
                  headers: { [key: string]: unknown };
                } & {
                  type: unknown;
                }) & {
                  /** @enum {string} */
                  type: "inbound_sms";
                })
            )[];
          };
        };
      };
      /** If the user is not an administrator. */
      403: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json":
          | (({
              /** Format: uuid */
              id: string;
              name: string;
              /** Format: uri */
              url: string;
              headers: { [key: string]: unknown };
            } & {
              type: unknown;
            }) & {
              /** @enum {string} */
              type: "graphql";
              query: string;
            })
          | (({
              /** Format: uuid */
              id: string;
              name: string;
              /** Format: uri */
              url: string;
              headers: { [key: string]: unknown };
            } & {
              type: unknown;
            }) & {
              /** @enum {string} */
              type: "graphql_deferred";
              filter?: string;
              name: string;
              offset:
                | number
                | {
                    fieldName: string;
                    /** Format: int64 */
                    default?: number;
                  };
              query: string;
            })
          | (({
              /** Format: uuid */
              id: string;
              name: string;
              /** Format: uri */
              url: string;
              headers: { [key: string]: unknown };
            } & {
              type: unknown;
            }) & {
              /** @enum {string} */
              type: "scheduled";
              cron: string;
            })
          | (({
              /** Format: uuid */
              id: string;
              name: string;
              /** Format: uri */
              url: string;
              headers: { [key: string]: unknown };
            } & {
              type: unknown;
            }) & {
              /** @enum {string} */
              type: "inbound_sms";
            });
      };
    };
  };
  /** Delete a webhook using the webhook ID. */
  webhooksDelete: {
    parameters: {
      path: {
        /** Identifier of the webhook to delete. */
        id: string;
      };
    };
    responses: {
      /** success */
      200: unknown;
      /** If the user is not an administrator. */
      403: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  triggeredActionsFetch: {
    responses: {
      /** success */
      200: {
        content: {
          "application/json": {
            result: {
              /** Format: uuid */
              id: string;
              name: string;
              trigger:
                | ({
                    /** @enum {string} */
                    type: "object_modified" | "event";
                  } & {
                    schemaName: string;
                    /** @description An EQL filter that has access to the `Current` and `Previous` values along with the `Operation` */
                    filter: string;
                    /** @description An optional field to support scheduling the trigger at a later date based on the object itself */
                    deferred?: {
                      /** @description A time field on the schema which determines when the deferred task will run */
                      fieldName: string;
                      offset:
                        | number
                        | {
                            /** @description The name of a field that has a type of Int, Decimal or Duration */
                            fieldName: string;
                            /**
                             * Format: int64
                             * @description A default value to use as the offset if the field has no value
                             */
                            default?: number;
                          };
                    };
                  })
                | ({
                    /** @enum {string} */
                    type: "object_modified" | "event";
                  } & {
                    /**
                     * @deprecated
                     * @description Legacy event type filter that contains the list of accepted event types.
                     */
                    typesFilter?: string[];
                    /**
                     * @description An EQL-like filter that has access to the top-level fields of the event JSON.
                     *
                     * Only equality checks and `AND` expressions are supported currently (and no parentheses). Left-hand values are names of top-level JSON fields, right-hand values must be valid JSON values, with the difference that strings are enclosed in single-quotes and escaping is not supported.
                     *
                     * Example filter that checks if the top-level `type` and `taskType` fields in the event JSON match the specified values:
                     *
                     * `type == 'async_task_completed' AND taskType == 'apply_schedule_template'`
                     */
                    filter?: string;
                  });
              action:
                | ({
                    /** @enum {string} */
                    type: "call_url" | "send_sms";
                  } & {
                    /**
                     * Format: uri
                     * @description Must be a HTTPS URL
                     */
                    url: string;
                    /**
                     * @description A map of headers that are sent for each request
                     * @example {
                     *   "My-Auth-Header": "my_secret_token"
                     * }
                     */
                    headers: { [key: string]: string };
                    /**
                     * @description A GraphQL query block that contains the structure of the data that will be returned
                     * @example {
                     *   Name
                     *   Contact {
                     *     FullName
                     *   }
                     * }
                     */
                    query: string;
                  })
                | ({
                    /** @enum {string} */
                    type: "call_url" | "send_sms";
                  } & {
                    to: { [key: string]: unknown };
                    /**
                     * @description A mustache template that allows EQL field names as variables. Values can reference fields defined on lookups.
                     * @example For a job: {{ Name }} {{ Job.Contact.FullName }}
                     */
                    template: string;
                  });
              /** Format: date-time */
              created: string;
              /** Format: date-time */
              updated: string;
              /** @description Custom fields as key-value pairs; only set for object_modified triggers. */
              customFields?: { [key: string]: unknown };
              enabled: boolean;
            }[];
          };
        };
      };
      /** If the user is not an administrator */
      403: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  triggeredActionCreate: {
    responses: {
      /** success */
      200: {
        content: {
          "application/json": {
            result: {
              /** Format: uuid */
              id: string;
              name: string;
              trigger:
                | ({
                    /** @enum {string} */
                    type: "object_modified" | "event";
                  } & {
                    schemaName: string;
                    /** @description An EQL filter that has access to the `Current` and `Previous` values along with the `Operation` */
                    filter: string;
                    /** @description An optional field to support scheduling the trigger at a later date based on the object itself */
                    deferred?: {
                      /** @description A time field on the schema which determines when the deferred task will run */
                      fieldName: string;
                      offset:
                        | number
                        | {
                            /** @description The name of a field that has a type of Int, Decimal or Duration */
                            fieldName: string;
                            /**
                             * Format: int64
                             * @description A default value to use as the offset if the field has no value
                             */
                            default?: number;
                          };
                    };
                  })
                | ({
                    /** @enum {string} */
                    type: "object_modified" | "event";
                  } & {
                    /**
                     * @deprecated
                     * @description Legacy event type filter that contains the list of accepted event types.
                     */
                    typesFilter?: string[];
                    /**
                     * @description An EQL-like filter that has access to the top-level fields of the event JSON.
                     *
                     * Only equality checks and `AND` expressions are supported currently (and no parentheses). Left-hand values are names of top-level JSON fields, right-hand values must be valid JSON values, with the difference that strings are enclosed in single-quotes and escaping is not supported.
                     *
                     * Example filter that checks if the top-level `type` and `taskType` fields in the event JSON match the specified values:
                     *
                     * `type == 'async_task_completed' AND taskType == 'apply_schedule_template'`
                     */
                    filter?: string;
                  });
              action:
                | ({
                    /** @enum {string} */
                    type: "call_url" | "send_sms";
                  } & {
                    /**
                     * Format: uri
                     * @description Must be a HTTPS URL
                     */
                    url: string;
                    /**
                     * @description A map of headers that are sent for each request
                     * @example {
                     *   "My-Auth-Header": "my_secret_token"
                     * }
                     */
                    headers: { [key: string]: string };
                    /**
                     * @description A GraphQL query block that contains the structure of the data that will be returned
                     * @example {
                     *   Name
                     *   Contact {
                     *     FullName
                     *   }
                     * }
                     */
                    query: string;
                  })
                | ({
                    /** @enum {string} */
                    type: "call_url" | "send_sms";
                  } & {
                    to: { [key: string]: unknown };
                    /**
                     * @description A mustache template that allows EQL field names as variables. Values can reference fields defined on lookups.
                     * @example For a job: {{ Name }} {{ Job.Contact.FullName }}
                     */
                    template: string;
                  });
              /** Format: date-time */
              created: string;
              /** Format: date-time */
              updated: string;
              /** @description Custom fields as key-value pairs; only set for object_modified triggers. */
              customFields?: { [key: string]: unknown };
              enabled: boolean;
            };
          };
        };
      };
      /** If the changes do not pass validation */
      400: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** If the user is not an administrator */
      403: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          name: string;
          trigger:
            | ({
                /** @enum {string} */
                type: "object_modified" | "event";
              } & {
                schemaName: string;
                /** @description An EQL filter that has access to the `Current` and `Previous` values along with the `Operation` */
                filter: string;
                /** @description An optional field to support scheduling the trigger at a later date based on the object itself */
                deferred?: {
                  /** @description A time field on the schema which determines when the deferred task will run */
                  fieldName: string;
                  offset:
                    | number
                    | {
                        /** @description The name of a field that has a type of Int, Decimal or Duration */
                        fieldName: string;
                        /**
                         * Format: int64
                         * @description A default value to use as the offset if the field has no value
                         */
                        default?: number;
                      };
                };
              })
            | ({
                /** @enum {string} */
                type: "object_modified" | "event";
              } & {
                /**
                 * @deprecated
                 * @description Legacy event type filter that contains the list of accepted event types.
                 */
                typesFilter?: string[];
                /**
                 * @description An EQL-like filter that has access to the top-level fields of the event JSON.
                 *
                 * Only equality checks and `AND` expressions are supported currently (and no parentheses). Left-hand values are names of top-level JSON fields, right-hand values must be valid JSON values, with the difference that strings are enclosed in single-quotes and escaping is not supported.
                 *
                 * Example filter that checks if the top-level `type` and `taskType` fields in the event JSON match the specified values:
                 *
                 * `type == 'async_task_completed' AND taskType == 'apply_schedule_template'`
                 */
                filter?: string;
              });
          action:
            | ({
                /** @enum {string} */
                type: "call_url" | "send_sms";
              } & {
                /**
                 * Format: uri
                 * @description Must be a HTTPS URL
                 */
                url: string;
                /**
                 * @description A map of headers that are sent for each request
                 * @example {
                 *   "My-Auth-Header": "my_secret_token"
                 * }
                 */
                headers: { [key: string]: string };
                /**
                 * @description A GraphQL query block that contains the structure of the data that will be returned
                 * @example {
                 *   Name
                 *   Contact {
                 *     FullName
                 *   }
                 * }
                 */
                query: string;
              })
            | ({
                /** @enum {string} */
                type: "call_url" | "send_sms";
              } & {
                to: { [key: string]: unknown };
                /**
                 * @description A mustache template that allows EQL field names as variables. Values can reference fields defined on lookups.
                 * @example For a job: {{ Name }} {{ Job.Contact.FullName }}
                 */
                template: string;
              });
          enabled?: boolean;
        };
      };
    };
  };
  triggeredActionDelete: {
    parameters: {
      path: {
        /** Identifier of the triggered action to delete */
        id: string;
      };
    };
    responses: {
      /** success */
      200: unknown;
      /** If the user is not an administrator */
      403: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "*/*": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Note that the type of the trigger and the action cannot be changed. */
  triggeredActionUpdate: {
    parameters: {
      path: {
        /** Identifier of the triggered action to update */
        id: string;
      };
    };
    responses: {
      /** success */
      200: {
        content: {
          "application/json": {
            result: {
              /** Format: uuid */
              id: string;
              name: string;
              trigger:
                | ({
                    /** @enum {string} */
                    type: "object_modified" | "event";
                  } & {
                    schemaName: string;
                    /** @description An EQL filter that has access to the `Current` and `Previous` values along with the `Operation` */
                    filter: string;
                    /** @description An optional field to support scheduling the trigger at a later date based on the object itself */
                    deferred?: {
                      /** @description A time field on the schema which determines when the deferred task will run */
                      fieldName: string;
                      offset:
                        | number
                        | {
                            /** @description The name of a field that has a type of Int, Decimal or Duration */
                            fieldName: string;
                            /**
                             * Format: int64
                             * @description A default value to use as the offset if the field has no value
                             */
                            default?: number;
                          };
                    };
                  })
                | ({
                    /** @enum {string} */
                    type: "object_modified" | "event";
                  } & {
                    /**
                     * @deprecated
                     * @description Legacy event type filter that contains the list of accepted event types.
                     */
                    typesFilter?: string[];
                    /**
                     * @description An EQL-like filter that has access to the top-level fields of the event JSON.
                     *
                     * Only equality checks and `AND` expressions are supported currently (and no parentheses). Left-hand values are names of top-level JSON fields, right-hand values must be valid JSON values, with the difference that strings are enclosed in single-quotes and escaping is not supported.
                     *
                     * Example filter that checks if the top-level `type` and `taskType` fields in the event JSON match the specified values:
                     *
                     * `type == 'async_task_completed' AND taskType == 'apply_schedule_template'`
                     */
                    filter?: string;
                  });
              action:
                | ({
                    /** @enum {string} */
                    type: "call_url" | "send_sms";
                  } & {
                    /**
                     * Format: uri
                     * @description Must be a HTTPS URL
                     */
                    url: string;
                    /**
                     * @description A map of headers that are sent for each request
                     * @example {
                     *   "My-Auth-Header": "my_secret_token"
                     * }
                     */
                    headers: { [key: string]: string };
                    /**
                     * @description A GraphQL query block that contains the structure of the data that will be returned
                     * @example {
                     *   Name
                     *   Contact {
                     *     FullName
                     *   }
                     * }
                     */
                    query: string;
                  })
                | ({
                    /** @enum {string} */
                    type: "call_url" | "send_sms";
                  } & {
                    to: { [key: string]: unknown };
                    /**
                     * @description A mustache template that allows EQL field names as variables. Values can reference fields defined on lookups.
                     * @example For a job: {{ Name }} {{ Job.Contact.FullName }}
                     */
                    template: string;
                  });
              /** Format: date-time */
              created: string;
              /** Format: date-time */
              updated: string;
              /** @description Custom fields as key-value pairs; only set for object_modified triggers. */
              customFields?: { [key: string]: unknown };
              enabled: boolean;
            };
          };
        };
      };
      /** If the changes do not pass validation */
      400: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** If the user is not an administrator */
      403: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** If there is no triggered action with the given id */
      404: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          name?: string | null;
          trigger?:
            | ({
                /** @enum {string} */
                type: "object_modified" | "event";
              } & {
                schemaName: string;
                /** @description An EQL filter that has access to the `Current` and `Previous` values along with the `Operation` */
                filter: string;
                /** @description An optional field to support scheduling the trigger at a later date based on the object itself */
                deferred?: {
                  /** @description A time field on the schema which determines when the deferred task will run */
                  fieldName: string;
                  offset:
                    | number
                    | {
                        /** @description The name of a field that has a type of Int, Decimal or Duration */
                        fieldName: string;
                        /**
                         * Format: int64
                         * @description A default value to use as the offset if the field has no value
                         */
                        default?: number;
                      };
                };
              })
            | ({
                /** @enum {string} */
                type: "object_modified" | "event";
              } & {
                /**
                 * @deprecated
                 * @description Legacy event type filter that contains the list of accepted event types.
                 */
                typesFilter?: string[];
                /**
                 * @description An EQL-like filter that has access to the top-level fields of the event JSON.
                 *
                 * Only equality checks and `AND` expressions are supported currently (and no parentheses). Left-hand values are names of top-level JSON fields, right-hand values must be valid JSON values, with the difference that strings are enclosed in single-quotes and escaping is not supported.
                 *
                 * Example filter that checks if the top-level `type` and `taskType` fields in the event JSON match the specified values:
                 *
                 * `type == 'async_task_completed' AND taskType == 'apply_schedule_template'`
                 */
                filter?: string;
              });
          action?:
            | ({
                /** @enum {string} */
                type: "call_url" | "send_sms";
              } & {
                /**
                 * Format: uri
                 * @description Must be a HTTPS URL
                 */
                url: string;
                /**
                 * @description A map of headers that are sent for each request
                 * @example {
                 *   "My-Auth-Header": "my_secret_token"
                 * }
                 */
                headers: { [key: string]: string };
                /**
                 * @description A GraphQL query block that contains the structure of the data that will be returned
                 * @example {
                 *   Name
                 *   Contact {
                 *     FullName
                 *   }
                 * }
                 */
                query: string;
              })
            | ({
                /** @enum {string} */
                type: "call_url" | "send_sms";
              } & {
                to: { [key: string]: unknown };
                /**
                 * @description A mustache template that allows EQL field names as variables. Values can reference fields defined on lookups.
                 * @example For a job: {{ Name }} {{ Job.Contact.FullName }}
                 */
                template: string;
              });
          enabled?: boolean;
        };
      };
    };
  };
  /** Return the status and details of webhooks and triggered actions. Results are ordered by ascending log ID. */
  triggeredActionLogs: {
    parameters: {
      query: {
        /** Resultset offset used for pagination */
        offset?: number;
        /** Max number of results to return. Default: 200 */
        limit?: number;
        /** Filter to logs caused by this Webhook ID or Triggered Action ID */
        sourceId?: string;
        /** If true, includes only webhook logs. If false, includes only triggered action logs. If omitted, includes logs of both types. */
        isWebhook?: boolean;
        /** Filter to logs updated after this datetime (inclusive) */
        updatedFrom?: string;
        /** Filter to logs updated before this datetime (inclusive) */
        updatedTo?: string;
      };
    };
    responses: {
      /** success */
      200: {
        content: {
          "application/json": {
            paging: {
              total: number;
              limit: number;
              offset: number;
            };
            result: ((
              | ({
                  id: number;
                  tenantId: string;
                  /** Format: uuid */
                  sourceId: string;
                  referenceId?: number;
                  data: { [key: string]: unknown };
                  /** Format: date-time */
                  created: string;
                  retry: number;
                  status: string;
                } & {
                  /** @enum {string} */
                  status: "pending";
                  /** Format: date-time */
                  startAfter: string;
                })
              | ({
                  id: number;
                  tenantId: string;
                  /** Format: uuid */
                  sourceId: string;
                  referenceId?: number;
                  data: { [key: string]: unknown };
                  /** Format: date-time */
                  created: string;
                  retry: number;
                  status: string;
                } & {
                  /** @enum {string} */
                  status: "processing";
                  /** Format: date-time */
                  started: string;
                })
              | (({
                  id: number;
                  tenantId: string;
                  /** Format: uuid */
                  sourceId: string;
                  referenceId?: number;
                  data: { [key: string]: unknown };
                  /** Format: date-time */
                  created: string;
                  retry: number;
                  status: string;
                } & {
                  attempts: {
                    /** Format: date-time */
                    attempted: string;
                    error: { [key: string]: unknown };
                  }[];
                }) & {
                  /** @enum {string} */
                  status: "success";
                  /** Format: date-time */
                  started: string;
                  /** Format: date-time */
                  completed: string;
                })
              | (({
                  id: number;
                  tenantId: string;
                  /** Format: uuid */
                  sourceId: string;
                  referenceId?: number;
                  data: { [key: string]: unknown };
                  /** Format: date-time */
                  created: string;
                  retry: number;
                  status: string;
                } & {
                  attempts: {
                    /** Format: date-time */
                    attempted: string;
                    error: { [key: string]: unknown };
                  }[];
                }) & {
                  /** @enum {string} */
                  status: "error";
                  /** Format: date-time */
                  started: string;
                  /** Format: date-time */
                  completed: string;
                  error: { [key: string]: unknown };
                })
            ) & {
              /** @enum {string} */
              status?: "pending" | "processing" | "success" | "error";
            })[];
          };
        };
      };
      /** User is not an administrator */
      403: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Fetch resource availability between a time period. */
  getAvailability: {
    parameters: {
      query: {
        /** Comma-separated string of resource IDs. There must be at least one ID and at most 200. */
        resource_ids: string;
        /** Instant to fetch from. */
        start: string;
        /** Instant to fetch to, must be after start and within 375 days of it. */
        end: string;
        /** Should availability be returned */
        availability?: boolean;
        /** Should unavailability be returned */
        unavailability?: boolean;
      };
    };
    responses: {
      /** Successful operation */
      200: {
        content: {
          "application/json": {
            /** @description Key of resource ID to AvailabilityResult. */
            result?: {
              [key: string]: {
                /** @description A flattened list of intervals when the resource is available to work. This is the inverse of unavailable. This will be constructed from either shifts if they are enabled or availability if they are not. */
                available: {
                  /** Format: date-time */
                  start: string;
                  /** Format: date-time */
                  end: string;
                }[];
                /** @description A flattened list of intervals when the resource is unavailable to work. This is the inverse of available. */
                unavailable: {
                  /** Format: date-time */
                  start: string;
                  /** Format: date-time */
                  end: string;
                }[];
                availability?: {
                  /** @description An array containing an array of availabilities. Subsequent arrays have higher priority. Availabilities may overlap with themselves and with unavailabilities. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  records: (
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      } & {
                        id: string;
                        entryId: string;
                      })
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        name: string;
                        description: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      })
                    | {
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      }
                    | {
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      }
                  )[][];
                  /** @description Contains untouched availability entries grouped by type and ID. Availabilities may overlap with themselves and also may overlap with an unavailability. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  entries: {
                    template?: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date */
                        start?: string;
                        /** Format: date */
                        end?: string;
                        entries: {
                          [key: string]: {
                            /** Format: date-time */
                            start: string;
                            /** Format: date-time */
                            end: string;
                            /**
                             * @description The days of the week
                             * @enum {string}
                             */
                            weekday?:
                              | "MON"
                              | "TUE"
                              | "WED"
                              | "THU"
                              | "FRI"
                              | "SAT"
                              | "SUN";
                          };
                        };
                      };
                    };
                    pattern?: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      };
                    };
                    holiday: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                        global: boolean;
                      };
                    };
                    custom: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        notes: string;
                        status?: string;
                        availabilityType?: string;
                        /** Format: date-time */
                        createdDate: string;
                      };
                    };
                  };
                };
                unavailability?: {
                  /** @description Returns the times when a resource is unavailable due to no explicit availability or unavailability. These times will never intersect with unavailability entries or with availabilities. */
                  defaults: {
                    /** Format: date-time */
                    start: string;
                    /** Format: date-time */
                    end: string;
                  }[];
                  /** @description An array containing an array of unavailabilities. Subsequent arrays have higher priority. Unavailabilities may overlap with themselves but they will never overlap with an availability. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  chunks: (
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                      } & {
                        id: string;
                        entryId: string;
                        name: string;
                      })
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        name: string;
                        description: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      })
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                      } & {
                        id: string;
                      })
                    | (({
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        notes: string;
                        status?: string;
                        availabilityType?: string;
                        /** Format: date-time */
                        createdDate: string;
                      }) & {
                        id: string;
                      })
                  )[][];
                  /** @description An array containing an array of unavailabilities. Subsequent arrays have higher priority. Unavailabilities may overlap with themselves and with availabilities. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  records: (
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      } & {
                        id: string;
                        entryId: string;
                      })
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        name: string;
                        description: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      })
                    | {
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      }
                    | {
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      }
                  )[][];
                  /** @description Contains untouched unavailability entries grouped by type and ID. Unavailabilities may overlap with themselves and also may overlap with an availability. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  entries: {
                    template: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date */
                        start?: string;
                        /** Format: date */
                        end?: string;
                        entries: {
                          [key: string]: {
                            /** Format: date-time */
                            start: string;
                            /** Format: date-time */
                            end: string;
                            /**
                             * @description The days of the week
                             * @enum {string}
                             */
                            weekday?:
                              | "MON"
                              | "TUE"
                              | "WED"
                              | "THU"
                              | "FRI"
                              | "SAT"
                              | "SUN";
                          };
                        };
                      };
                    };
                    pattern: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      };
                    };
                    holiday: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                        global: boolean;
                      };
                    };
                    custom: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        notes: string;
                        status?: string;
                        availabilityType?: string;
                        /** Format: date-time */
                        createdDate: string;
                      };
                    };
                  };
                };
                /** @description A list of shifts for the resource in the requested interval. Draft shifts are excluded. */
                shifts?: {
                  UID: string;
                  /** Format: date-time */
                  start: string;
                  /** Format: date-time */
                  end: string;
                  locationId?: string;
                  regionId?: string;
                  displayName?: string;
                }[];
                /** @description A list of the regions that the resource is available in in the request interval. */
                regions?: {
                  /** Format: date-time */
                  start: string;
                  /** Format: date-time */
                  end: string;
                  regionIds: string[];
                }[];
              };
            };
          };
          result: unknown;
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  /** Fetch resource availability between a time period in a simplified format. */
  getAvailabilitySimple: {
    parameters: {
      query: {
        /** Comma-separated string of resource IDs. There must be at least one ID and at most 200. */
        resource_ids: string;
        /** Instant to fetch from. */
        start: string;
        /** Instant to fetch to, must be after start and within 375 days of it. */
        end: string;
        /** If true, merged availability time intervals are returned with the result. */
        mergedAvailabilities?: boolean;
        /** If true or omitted, the list of availability entries is returned. */
        entries?: boolean;
      };
    };
    responses: {
      /** Successful operation */
      200: {
        content: {
          "application/json": {
            /** @description Array of AvailabilityResultSimple objects, each object corresponds to the availability information of a single resource. */
            result?: ({
              /** @description ID of the resource. */
              resourceId: string;
              /** @description A flattened list of intervals when the resource is available to work. These intervals are calculated by merging all availability entries together in the given time range according to the predefined precedence rules. This key only contains data if the `mergedAvailabilities` query string parameters was set to `true` in the request, otherwise it's set to null. */
              mergedAvailabilties?:
                | {
                    /** Format: date-time */
                    start: string;
                    /** Format: date-time */
                    end: string;
                  }[]
                | null;
              /** @description The list of various availability entries in the given time interval applicable for the resource. Entries are sorted by the start time in ascending order. */
              entries:
                | (
                    | ({
                        /** @description The type of the availability entry. Valid values are `template`, `pattern`, `override`, and `holiday`. */
                        type: string;
                        /**
                         * Format: date-time
                         * @description The UTC datetime at which the availability entry beings applying to the resource (this exact point in time included).
                         */
                        start: string;
                        /**
                         * Format: date-time
                         * @description The UTC datetime at which the availability entry stops applying to the resource (this exact point in time excluded).
                         */
                        end: string;
                        /** @description Flag indicating whether this is an availability or unavailability entry. */
                        available: boolean;
                      } & {
                        /** @description ID of the availability template this template entry is part of. Note that there can be multiple entries in the response belonging to the same template. */
                        templateId: string;
                        /** @description ID of the availability template entry. Template entry IDs are unique. */
                        templateEntryId: string;
                        /** @description Name of the availability template entry. */
                        name: string;
                      })
                    | ({
                        /** @description The type of the availability entry. Valid values are `template`, `pattern`, `override`, and `holiday`. */
                        type: string;
                        /**
                         * Format: date-time
                         * @description The UTC datetime at which the availability entry beings applying to the resource (this exact point in time included).
                         */
                        start: string;
                        /**
                         * Format: date-time
                         * @description The UTC datetime at which the availability entry stops applying to the resource (this exact point in time excluded).
                         */
                        end: string;
                        /** @description Flag indicating whether this is an availability or unavailability entry. */
                        available: boolean;
                      } & {
                        /** @description ID of the availability pattern this pattern entry is part of. Note that there can be multiple entries in the response belonging to the same pattern. */
                        patternId: string;
                        /** @description ID of the availability pattern resource record (which associates a pattern with a given resource). */
                        patternResourceId: string;
                        /** @description Description of the pattern. */
                        description: string;
                        /** @description Type of the pattern, valid values are `weekly` and `custom`. */
                        patternType: string;
                      } & {
                        name: unknown;
                      })
                    | ({
                        /** @description The type of the availability entry. Valid values are `template`, `pattern`, `override`, and `holiday`. */
                        type: string;
                        /**
                         * Format: date-time
                         * @description The UTC datetime at which the availability entry beings applying to the resource (this exact point in time included).
                         */
                        start: string;
                        /**
                         * Format: date-time
                         * @description The UTC datetime at which the availability entry stops applying to the resource (this exact point in time excluded).
                         */
                        end: string;
                        /** @description Flag indicating whether this is an availability or unavailability entry. */
                        available: boolean;
                      } & {
                        /** @description ID of the holiday entry. Holiday IDs are unique. */
                        id: string;
                        name: string;
                        global: boolean;
                      })
                    | ({
                        /** @description The type of the availability entry. Valid values are `template`, `pattern`, `override`, and `holiday`. */
                        type: string;
                        /**
                         * Format: date-time
                         * @description The UTC datetime at which the availability entry beings applying to the resource (this exact point in time included).
                         */
                        start: string;
                        /**
                         * Format: date-time
                         * @description The UTC datetime at which the availability entry stops applying to the resource (this exact point in time excluded).
                         */
                        end: string;
                        /** @description Flag indicating whether this is an availability or unavailability entry. */
                        available: boolean;
                      } & {
                        /** @description ID of the availability override. Override IDs are unique. */
                        id: string;
                        /** @description Type of the override (e.g. `Leave`, `Occupied`, `Overtime`, `Sick`, etc.) */
                        overrideType: string;
                        /** @description User defined notes for this override. */
                        notes: string;
                        /** @description Status of the override, valid values are `Approved`, `Declined` and `Pending`. */
                        status: string;
                      })
                  )[]
                | null;
            } & {
              mergedAvailabilities: unknown;
            })[];
          };
          result: unknown;
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  /** Fetch available resources for given criteria in a time period. Must specify at least one of `resourceIds` or `regionIds`. Note that the `regionIds` filter only restricts the list of resources to query the availabilities for; resource availability is global, there is no concept of per-region availability in the system. */
  postAvailableResources: {
    responses: {
      /** Successful operation */
      200: {
        content: {
          "application/json": {
            /** @description Key of resource ID to AvailabilityResult. */
            result?: {
              [key: string]: {
                /** @description A flattened list of intervals when the resource is available to work. This is the inverse of unavailable. This will be constructed from either shifts if they are enabled or availability if they are not. */
                available: {
                  /** Format: date-time */
                  start: string;
                  /** Format: date-time */
                  end: string;
                }[];
                /** @description A flattened list of intervals when the resource is unavailable to work. This is the inverse of available. */
                unavailable: {
                  /** Format: date-time */
                  start: string;
                  /** Format: date-time */
                  end: string;
                }[];
                availability?: {
                  /** @description An array containing an array of availabilities. Subsequent arrays have higher priority. Availabilities may overlap with themselves and with unavailabilities. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  records: (
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      } & {
                        id: string;
                        entryId: string;
                      })
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        name: string;
                        description: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      })
                    | {
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      }
                    | {
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      }
                  )[][];
                  /** @description Contains untouched availability entries grouped by type and ID. Availabilities may overlap with themselves and also may overlap with an unavailability. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  entries: {
                    template?: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date */
                        start?: string;
                        /** Format: date */
                        end?: string;
                        entries: {
                          [key: string]: {
                            /** Format: date-time */
                            start: string;
                            /** Format: date-time */
                            end: string;
                            /**
                             * @description The days of the week
                             * @enum {string}
                             */
                            weekday?:
                              | "MON"
                              | "TUE"
                              | "WED"
                              | "THU"
                              | "FRI"
                              | "SAT"
                              | "SUN";
                          };
                        };
                      };
                    };
                    pattern?: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      };
                    };
                    holiday: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                        global: boolean;
                      };
                    };
                    custom: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        notes: string;
                        status?: string;
                        availabilityType?: string;
                        /** Format: date-time */
                        createdDate: string;
                      };
                    };
                  };
                };
                unavailability?: {
                  /** @description Returns the times when a resource is unavailable due to no explicit availability or unavailability. These times will never intersect with unavailability entries or with availabilities. */
                  defaults: {
                    /** Format: date-time */
                    start: string;
                    /** Format: date-time */
                    end: string;
                  }[];
                  /** @description An array containing an array of unavailabilities. Subsequent arrays have higher priority. Unavailabilities may overlap with themselves but they will never overlap with an availability. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  chunks: (
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                      } & {
                        id: string;
                        entryId: string;
                        name: string;
                      })
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        name: string;
                        description: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      })
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                      } & {
                        id: string;
                      })
                    | (({
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        notes: string;
                        status?: string;
                        availabilityType?: string;
                        /** Format: date-time */
                        createdDate: string;
                      }) & {
                        id: string;
                      })
                  )[][];
                  /** @description An array containing an array of unavailabilities. Subsequent arrays have higher priority. Unavailabilities may overlap with themselves and with availabilities. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  records: (
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      } & {
                        id: string;
                        entryId: string;
                      })
                    | ({
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        name: string;
                        description: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      })
                    | {
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      }
                    | {
                        /** @enum {string} */
                        type: "template" | "pattern" | "holiday" | "custom";
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                      }
                  )[][];
                  /** @description Contains untouched unavailability entries grouped by type and ID. Unavailabilities may overlap with themselves and also may overlap with an availability. Either templates or patterns are returned (but not both) depending on whether the availabilty patterns feature is enabled. */
                  entries: {
                    template: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date */
                        start?: string;
                        /** Format: date */
                        end?: string;
                        entries: {
                          [key: string]: {
                            /** Format: date-time */
                            start: string;
                            /** Format: date-time */
                            end: string;
                            /**
                             * @description The days of the week
                             * @enum {string}
                             */
                            weekday?:
                              | "MON"
                              | "TUE"
                              | "WED"
                              | "THU"
                              | "FRI"
                              | "SAT"
                              | "SUN";
                          };
                        };
                      };
                    };
                    pattern: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        patternId: string;
                        patternResourceId: string;
                        /** @enum {string} */
                        patternType: "custom" | "weekly";
                      };
                    };
                    holiday: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        name: string;
                        global: boolean;
                      };
                    };
                    custom: {
                      [key: string]: {
                        description?: string;
                        name: string;
                      } & {
                        /** Format: date-time */
                        start: string;
                        /** Format: date-time */
                        end: string;
                        notes: string;
                        status?: string;
                        availabilityType?: string;
                        /** Format: date-time */
                        createdDate: string;
                      };
                    };
                  };
                };
                /** @description A list of shifts for the resource in the requested interval. Draft shifts are excluded. */
                shifts?: {
                  UID: string;
                  /** Format: date-time */
                  start: string;
                  /** Format: date-time */
                  end: string;
                  locationId?: string;
                  regionId?: string;
                  displayName?: string;
                }[];
                /** @description A list of the regions that the resource is available in in the request interval. */
                regions?: {
                  /** Format: date-time */
                  start: string;
                  /** Format: date-time */
                  end: string;
                  regionIds: string[];
                }[];
              };
            };
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: date-time
           * @description Instant to fetch from.
           */
          start: string;
          /**
           * Format: date-time
           * @description Instant to fetch to, must be after start and within 375 days of it.
           */
          end: string;
          /** @description Non-empty array of resource IDs. There is a maximum limit of 200. If provided, we only consider resources with these IDs. */
          resourceIds?: string[];
          /** @description Non-empty array of region IDs. There is a maximum limit of 50. If provided, we only consider resources with their primary, secondary or temporary regions set to these IDs. */
          regionIds?: string[];
          /**
           * @description EQL filter for resources to be included in this list. Must not contain a region criteria!
           * @example EmploymentType == "Full-time"
           */
          resourceFilter?: string;
          /**
           * @description Should availability be returned.
           * @default false
           */
          availability?: boolean;
          /**
           * @description Should unavailability be returned.
           * @default false
           */
          unavailability?: boolean;
        };
      };
    };
  };
  /** Retrieve information about the status of the Availability Template to Pattern migration. The Availability Patterns feature flag must be enabled in the org before calling this endpoint. */
  availabilityMigrationStatus: {
    responses: {
      /** Successful operation */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @description Total number of Availability Template objects in the org. */
              totalTemplates?: number;
              /** @description Total number of Availability Template Resource objects in the org. */
              totalTemplateResources?: number;
              /** @description Total number of Availability Template objects in the org that have not been migrated to Availability Patterns yet. */
              unmigratedTemplates?: number;
              /** @description Total number of Availability Template Resource objects in the org that have not been migrated to Availability Pattern Resources yet. */
              unmigratedTemplateResources?: number;
            };
          };
        };
      };
    };
  };
  /**
   * Migrate all Availability Template and Availability Template Resource objects in the org to Availability Pattern and Availability Pattern Resource objects, respectively.
   *
   * The Availability Patterns feature flag must be enabled in the org before calling this endpoint. No data is deleted by the migration process. The operation is idempotent, meaning that calling the endpoint multiple times will migrate every object only once. If the operation was interrupted or not all objects could be migrated due to some errors, the endpoint should be called again to migrate the rest of the data (perhaps after fixing some problems manually first).
   */
  availabilityMigrationMigrate: {
    responses: {
      /** Successful operation */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @description Total number of Availability Template objects in the org. */
              totalTemplates?: number;
              /** @description Total number of Availability Template Resource objects in the org. */
              totalTemplateResources?: number;
              /** @description Total number of Availability Template objects in the org before the migration that have not been migrated to Availability Patterns yet. */
              unmigratedTemplatesPreMigration?: number;
              /** @description Total number of Availability Template Resource objects in the org before the migration that have not been migrated to Availability Pattern Resources yet. */
              unmigratedTemplateResourcesPreMigration?: number;
              /** @description Total number of Availability Template objects in the org after the migration that have not been migrated to Availability Patterns yet. */
              unmigratedTemplatesPostMigration?: number;
              /** @description Total number of Availability Template Resource objects in the org after the migration that have not been migrated to Availability Pattern Resources yet. */
              unmigratedTemplateResourcesPostMigration?: number;
              /** @description List of errors that occurred during the migration process. */
              errors?: string[];
            };
          };
        };
      };
    };
  };
  /**
   * Allows a Skedulo Platform Administrator to create users (and their associated resource).
   *
   * Each new user created can be sent an invitation email right after they are created, which contains a link allowing them to set a password.
   */
  standaloneUsers: {
    responses: {
      /** Users were created, check the result for any failures. Failures are returned keyed by email address. */
      200: {
        content: {
          "application/json": {
            result?: {
              inserted: number;
              updated: number;
              total: number;
              failures: {
                [key: string]: {
                  code: string;
                  message: string;
                };
              };
            };
          };
        };
      };
      /** If the user is not an administrator. */
      403: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    /** A non-empty array of new users to add. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: email
           * @description This is the unique identifier of the user within this tenant. For standard Skedulo users, the email must be unique across all Skedulo platform tenants. For SSO only users, this email can be used in multiple tenants.
           */
          email: string;
          firstName?: string;
          lastName: string;
          roles?: ("Administrator" | "Scheduler" | "Resource")[];
          /**
           * @description If true, sends the email invitation immediately. Ignored when adding SSO users to the local database.
           * @default true
           */
          sendInvitation?: boolean;
          /** @description Definition of the Resource record to be associated with this user. This object can contain custom fields - note that the case of the field name must match the field definition. If this Resource object is provided, the user's roles must include "Resource". Note that a Resource can also be created at a later date and linked to the user via `/auth/link_resource`. */
          resource?: {
            primaryRegionId: string;
            resourceType?: string;
            employmentType?: string;
            isActive: boolean;
            category?: string;
            homeAddress?: string;
            mobilePhone?: string;
            /**
             * @description The correct country code must be set for each resource so that they can receive SMS.
             * @enum {string}
             */
            countryCode?: "AU" | "NZ" | "US" | "UK";
            /**
             * @description Default notification method of this resource.
             * @enum {string}
             */
            notificationType?: "sms" | "push";
            /**
             * @description Working hour type of this resource.
             * @enum {string}
             */
            workingHourType?: "Availability" | "Shift";
            geoLongitude?: number;
            geoLatitude?: number;
          };
        }[];
      };
    };
  };
  /**
   * This endpoint is deprecated, use the Data Loader in the Skedulo web app instead.
   *
   * This is run as a background task.
   *
   * Each new user created can be sent an invitation email right after they are created, which contains a link allowing them to set a password.
   */
  standaloneUsersBulk: {
    responses: {
      /** The background task has been registered. */
      200: {
        content: {
          "application/json": {
            result?: {
              taskId: number;
              type: string;
              /** Format: date-time */
              createdAt: string;
              /** Format: date-time */
              lastCheckedInAt?: string;
              /** Format: date-time */
              completedAt?: string;
              success: boolean;
              errorMsg?: string;
            };
          };
        };
      };
      /** If the user is not an administrator. */
      403: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    /** A non-empty array of new users to add. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: email
           * @description This is the unique identifier of the user within this tenant. For standard Skedulo users, the email must be unique across all Skedulo platform tenants. For SSO only users, this email can be used in multiple tenants.
           */
          email: string;
          firstName?: string;
          lastName: string;
          roles?: ("Administrator" | "Scheduler" | "Resource")[];
          /**
           * @description If true, sends the email invitation immediately. Ignored when adding SSO users to the local database.
           * @default true
           */
          sendInvitation?: boolean;
          /** @description Definition of the Resource record to be associated with this user. This object can contain custom fields - note that the case of the field name must match the field definition. If this Resource object is provided, the user's roles must include "Resource". Note that a Resource can also be created at a later date and linked to the user via `/auth/link_resource`. */
          resource?: {
            primaryRegionId: string;
            resourceType?: string;
            employmentType?: string;
            isActive: boolean;
            category?: string;
            homeAddress?: string;
            mobilePhone?: string;
            /**
             * @description The correct country code must be set for each resource so that they can receive SMS.
             * @enum {string}
             */
            countryCode?: "AU" | "NZ" | "US" | "UK";
            /**
             * @description Default notification method of this resource.
             * @enum {string}
             */
            notificationType?: "sms" | "push";
            /**
             * @description Working hour type of this resource.
             * @enum {string}
             */
            workingHourType?: "Availability" | "Shift";
            geoLongitude?: number;
            geoLatitude?: number;
          };
        }[];
      };
    };
  };
  /**
   * This endpoint is deprecated, use the Data Loader in the Skedulo web app instead.
   *
   * Import CSV or JSON data that is embedded in a multipart/form-data document. Accepts one file at a time.
   */
  standaloneUsersBulkFromFile: {
    responses: {
      /** The background task has been registered. */
      200: {
        content: {
          "application/json": {
            result?: {
              taskId: number;
              type: string;
              /** Format: date-time */
              createdAt: string;
              /** Format: date-time */
              lastCheckedInAt?: string;
              /** Format: date-time */
              completedAt?: string;
              success: boolean;
              errorMsg?: string;
            };
          };
        };
      };
      /** Data format error or there was not exactly one file attached. */
      400: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Authentication/Authorization failed */
      401: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** If the user is not an administrator. */
      403: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /**
   * Creates users (and their associated resources) in the tenant database but does not create corresponding Auth0 user accounts.
   *
   * This allows the users to log in using linked SSO accounts with the corresponding email addresses. The email addresses can be used in multiple tenants when logging in with SSO.
   */
  standaloneUsersLocal: {
    responses: {
      /** Users were added to the database. Check the result for any failures. Failures are returned keyed by email address. */
      200: {
        content: {
          "application/json": {
            result?: {
              inserted: number;
              updated: number;
              total: number;
              failures: {
                [key: string]: {
                  code: string;
                  message: string;
                };
              };
            };
          };
        };
      };
      /** If the user is not an Administrator. */
      403: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    /** A non-empty array of new users to add. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: email
           * @description This is the unique identifier of the user within this tenant. For standard Skedulo users, the email must be unique across all Skedulo platform tenants. For SSO only users, this email can be used in multiple tenants.
           */
          email: string;
          firstName?: string;
          lastName: string;
          roles?: ("Administrator" | "Scheduler" | "Resource")[];
          /**
           * @description If true, sends the email invitation immediately. Ignored when adding SSO users to the local database.
           * @default true
           */
          sendInvitation?: boolean;
          /** @description Definition of the Resource record to be associated with this user. This object can contain custom fields - note that the case of the field name must match the field definition. If this Resource object is provided, the user's roles must include "Resource". Note that a Resource can also be created at a later date and linked to the user via `/auth/link_resource`. */
          resource?: {
            primaryRegionId: string;
            resourceType?: string;
            employmentType?: string;
            isActive: boolean;
            category?: string;
            homeAddress?: string;
            mobilePhone?: string;
            /**
             * @description The correct country code must be set for each resource so that they can receive SMS.
             * @enum {string}
             */
            countryCode?: "AU" | "NZ" | "US" | "UK";
            /**
             * @description Default notification method of this resource.
             * @enum {string}
             */
            notificationType?: "sms" | "push";
            /**
             * @description Working hour type of this resource.
             * @enum {string}
             */
            workingHourType?: "Availability" | "Shift";
            geoLongitude?: number;
            geoLatitude?: number;
          };
        }[];
      };
    };
  };
  /** See /provision/standalone/users/local. Imports CSV or JSON data that is embedded in a multipart/form-data document. Accepts one file at a time. Import is run as a background task. */
  standaloneUsersBulkFromFileLocal: {
    responses: {
      /** The background task has been registered. */
      200: {
        content: {
          "application/json": {
            result?: {
              taskId: number;
              type: string;
              /** Format: date-time */
              createdAt: string;
              /** Format: date-time */
              lastCheckedInAt?: string;
              /** Format: date-time */
              completedAt?: string;
              success: boolean;
              errorMsg?: string;
            };
          };
        };
      };
      /** Data format error or there was not exactly one file attached. */
      400: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** Authentication/Authorization failed */
      401: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
      /** If the user is not an Administrator. */
      403: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /**
   * This endpoint is deprecated, use the Data Loader in the Skedulo web app instead.
   *
   * Allows a Skedulo Platform Administrator to query the status of a background task that has been submitted earlier.
   */
  getProcessedUsers: {
    parameters: {
      path: {
        /** ID of the background task to be queried. */
        taskId: number;
      };
    };
    responses: {
      /** The background task has been registered. */
      200: {
        content: {
          "application/json": {
            result?: {
              task: {
                taskId: number;
                type: string;
                /** Format: date-time */
                createdAt: string;
                /** Format: date-time */
                lastCheckedInAt?: string;
                /** Format: date-time */
                completedAt?: string;
                success: boolean;
                errorMsg?: string;
              };
              users: {
                /** Format: email */
                email: string;
                taskId: string;
                firstName?: string;
                lastName: string;
                success: boolean;
                errorMsg?: string;
              }[];
            };
          };
        };
      };
      /** If the user is not an administrator. */
      403: unknown;
      /** Task with taskId not found. */
      404: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Internal endpoint used to check if a tenant has been initialized. */
  internalCheckTenantInitialized: {
    responses: {
      /** Tenant is initialized. */
      200: unknown;
      /** Tenant is not initialized. */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The tenant ID to create the schema for existing tenantId's will return success but will not be updated.
           * @example sk_ba70ac7072fd4df3a179cce2e2c4e483
           */
          tenantId: string;
          /**
           * @description The vendor that will serve the tenant's data either skedulo or salesforce
           * @enum {string}
           */
          vendor: "skedulo" | "salesforce";
        };
      };
    };
  };
  /** Fetch all templates for a given schema. */
  getTemplates: {
    parameters: {
      path: {
        /** Schema to retrieve templates for. */
        schemaName: string;
      };
    };
    responses: {
      /** Successful operation */
      200: {
        content: {
          "application/json": {
            result?: {
              /** Format: uuid */
              id: string;
              name: string;
              schemaName: string;
            }[];
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Create a new template. */
  createTemplate: {
    responses: {
      /** The template was created. */
      200: {
        content: {
          "application/json": {
            result?: {
              /** Format: uuid */
              id: string;
              name: string;
              schemaName: string;
            }[];
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    /** New template details. */
    requestBody: {
      content: {
        "application/json": {
          name: string;
          schemaName: string;
        };
      };
    };
  };
  /** Update an existing template. */
  updateTemplate: {
    parameters: {
      path: {
        /** Identifier of the template to update. */
        template_id: string;
      };
    };
    responses: {
      /** The template was updated. */
      200: unknown;
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    /** Updated template details. */
    requestBody: {
      content: {
        "application/json": {
          name: string;
        };
      };
    };
  };
  /** Delete a template. */
  deleteTemplate: {
    parameters: {
      path: {
        /** Identifier of the template to delete. */
        template_id: string;
      };
    };
    responses: {
      /** The template was deleted. */
      200: {
        content: {
          "application/json": {
            /** Format: uuid */
            deleted?: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** Return template values for a template. */
  getValuePairs: {
    parameters: {
      path: {
        /** Identifier of the template to retrieve values for. */
        template_id: string;
      };
    };
    responses: {
      /** Successful operation */
      200: {
        content: {
          "application/json": {
            result?: {
              /** Format: uuid */
              id: string;
              /** Format: uuid */
              templateId: string;
              rel: string;
              field: string;
              value: string;
            }[];
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  /** All existing values will removed and the values provided will be inserted. */
  overrideTemplateValues: {
    parameters: {
      path: {
        /** Identifier of the template to add values for. */
        template_id: string;
      };
    };
    responses: {
      /** The values were updated. */
      200: {
        content: {
          "application/json": {
            result?: {
              /** Format: uuid */
              id: string;
              /** Format: uuid */
              templateId: string;
              rel: string;
              field: string;
              value: string;
            }[];
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
    /** Values to use for the template. */
    requestBody: {
      content: {
        "application/json": {
          rel: string;
          field: string;
          value: string;
        }[];
      };
    };
  };
  /** Returns the default layout for the given object. */
  layoutObjectDefault: {
    parameters: {
      path: {
        /** the name of the object */
        object: string;
      };
    };
    responses: {
      /** Successful operation */
      200: {
        content: {
          "application/json": {
            result: {
              object: string;
              layout: {
                relatedData: {
                  /** @enum {string} */
                  type: "relatedObjects";
                  reference?: string;
                  object: string;
                  label?: string;
                  listFields?: {
                    fieldName: string;
                  }[];
                }[];
              };
            };
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
            errorId?: string;
          };
        };
      };
    };
  };
  fetchVocabularies: {
    parameters: {
      query: {
        /** Names of schemas to fetch vocabularies for in comma separated format. If not provided all vocabularies are returned. */
        names?: string;
        /** If set to true the cache is replaced with a new value. Has no effect if 'names' are provided as they are not cached. */
        force?: boolean;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            result: {
              [key: string]: {
                [key: string]: {
                  value: string;
                  label: string;
                  active: boolean;
                  defaultValue: boolean;
                  controller?: string;
                  controllingField?: string;
                  validFor: string[];
                }[];
              };
            };
          };
        };
      };
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  vocabularyFetch: {
    parameters: {
      path: {
        /** Name of the schema that the vocabulary field belongs to */
        schemaName: string;
        /** Name of a vocabulary field */
        fieldName: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": {
            result?: {
              label: string;
              value: string;
              active: boolean;
              defaultValue: boolean;
              controllingField?: string;
              validFor: string[];
            }[];
          };
        };
      };
      /** If the field does not exist or is not a vocabulary field */
      400: unknown;
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  /** You must be an administrator in order to use this endpoint */
  vocabularyCreate: {
    parameters: {
      path: {
        /** Name of the schema that the vocabulary field belongs to */
        schemaName: string;
        /** Name of a vocabulary field */
        fieldName: string;
      };
    };
    responses: {
      /** The item was added */
      200: unknown;
      /** If the field does not exist or is not a vocabulary field */
      400: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** An item with that value already exists */
      409: unknown;
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    /** The item to add */
    requestBody: {
      content: {
        "application/json": {
          label: string;
          value: string;
          active: boolean;
          defaultValue: boolean;
          controllingField?: string;
          validFor: string[];
        };
      };
    };
  };
  /** You must be an administrator in order to use this endpoint */
  vocabularyUpdate: {
    parameters: {
      path: {
        /** Name of the schema that the vocabulary field belongs to */
        schemaName: string;
        /** Name of a vocabulary field */
        fieldName: string;
        /** Value of the vocabulary item to modify */
        value: string;
      };
    };
    responses: {
      /** The item was updated */
      200: unknown;
      /** If the field does not exist or is not a vocabulary field */
      400: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    /** The item to modify */
    requestBody: {
      content: {
        "application/json": {
          label?: string;
          value?: string;
          active?: boolean;
          defaultValue?: boolean;
        };
      };
    };
  };
  /** You must be an administrator in order to use this endpoint */
  vocabularyDeactivate: {
    parameters: {
      path: {
        /** Name of the schema that the vocabulary field belongs to */
        schemaName: string;
        /** Name of a vocabulary field */
        fieldName: string;
        /** Vocabulary item value to deactivate */
        value: string;
      };
    };
    responses: {
      /** The item was deactivated */
      200: unknown;
      /** If the field does not exist or is not a vocabulary field */
      400: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  /** You must be an administrator in order to use this endpoint */
  upsertFieldDependency: {
    responses: {
      /** The dependency relationship was created or updated */
      200: unknown;
      /** If fields or entries provided were invalid */
      400: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    /** The dependency relationship to be created or updated */
    requestBody: {
      content: {
        "application/json": {
          schemaName: string;
          dependentField: string;
          controllingField: string;
          entries: {
            dependentValue: string;
            controllingValue: string;
          }[];
        };
      };
    };
  };
  /** You must be an administrator in order to use this endpoint */
  deleteFieldDependency: {
    responses: {
      /** The dependency relationship was removed */
      200: unknown;
      /** If fields provided were invalid */
      400: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    /** The dependency relationship to be removed */
    requestBody: {
      content: {
        "application/json": {
          schemaName: string;
          dependentField: string;
          controllingField: string;
        };
      };
    };
  };
  /** You must be an administrator in order to use this endpoint */
  addFieldDependencyEntry: {
    responses: {
      /** The dependency relationship was created or updated */
      200: unknown;
      /** If fields or entry provided were invalid */
      400: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    /** The dependency relationship to be created or updated */
    requestBody: {
      content: {
        "application/json": {
          schemaName: string;
          dependentField: string;
          controllingField: string;
          entry: {
            dependentValue: string;
            controllingValue: string;
          };
        };
      };
    };
  };
  /** You must be an administrator in order to use this endpoint */
  deleteFieldDependencyEntry: {
    responses: {
      /** The dependency relationship was removed */
      200: unknown;
      /** If fields or entry provided were invalid */
      400: unknown;
      /** If the user is not an administrator */
      403: unknown;
      /** Unexpected error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
    /** The dependency relationship to be removed */
    requestBody: {
      content: {
        "application/json": {
          schemaName: string;
          dependentField: string;
          controllingField: string;
        };
      };
    };
  };
  /** Deprecated: use the /auth/metadata/user endpoint instead */
  userMetadata: {
    responses: {
      /** The current users metadata */
      200: {
        content: {
          "application/json": {
            result?: {
              id: string;
              email: string;
              username: string;
              fullName: string;
              profileId: string;
              roleId: string;
              orgName: string;
              orgId: string;
              sfdcDomain: string;
              isSkeduloScheduler: boolean;
              isSkeduloUser: boolean;
              isSkeduloAdmin: boolean;
              userroles: string;
              smallPhotoUrl?: string;
              category?: string;
              resourceId?: string;
              latitude?: number;
              longitude?: number;
              address?: string;
              timezone?: string;
              country?: string;
              teamMetadata?: {
                id: string;
                /** @description Primary name of the team. This is always the subdomain part of the team's custom Skedulo domain */
                name: string;
                description: string;
                /** @enum {string} */
                vendor: "salesforce" | "servicenow" | "skedulo";
                orgId: string;
                /** @description The customer name. */
                customer?: string;
              };
            };
          };
        };
      };
    };
  };
  downloadFile: {
    parameters: {
      path: {
        /** Identifier of the file to retrieve */
        fileId: string;
      };
      query: {
        /** True to force the browser to download the file, false to inline the content */
        attach?: boolean;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
      /** Invalid data supplied */
      400: unknown;
      /** Attachment with the given identifier is not found */
      404: unknown;
    };
  };
  renameFile: {
    parameters: {
      path: {
        /** Identifier of the file to rename */
        fileId: string;
      };
      query: {
        /** The new name of the file */
        name: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            id: string;
            success: boolean;
          };
        };
      };
      /** Invalid data supplied */
      400: unknown;
      /** Attachment with the given identifier is not found */
      404: unknown;
    };
  };
  deleteFile: {
    parameters: {
      path: {
        /** Identifier of the attachment to delete */
        fileId: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            deleted: string;
          };
        };
      };
      /** Invalid data supplied */
      400: unknown;
      /** Attachment with the given identifier is not found */
      404: unknown;
    };
  };
  getFiles: {
    parameters: {
      query: {
        /** Comma-separated identifiers of the parents to retrieve attachments for */
        parent_ids: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            [key: string]: {
              filePtr: string;
              size?: string;
              contentType?: string;
              fileName: string;
              /** Format: date-time */
              uploadDate: string;
              parentId: string;
              createdBy?: string;
              createdById?: string;
              description?: string;
              downloadUrl?: string;
            }[];
          };
        };
      };
      /** Resource with parent identifier not found */
      404: unknown;
    };
  };
  getFilesSingle: {
    parameters: {
      path: {
        /** Identifier of the parent to retrieve attachments for */
        parentId: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            result?: {
              filePtr: string;
              size?: string;
              contentType?: string;
              fileName: string;
              /** Format: date-time */
              uploadDate: string;
              parentId: string;
              createdBy?: string;
              createdById?: string;
              description?: string;
              downloadUrl?: string;
            }[];
          };
        };
      };
      /** Resource with parent identifier not found */
      404: unknown;
    };
  };
  uploadReturnOldMeta: {
    parameters: {
      path: {
        /** Identifier of the parent to add the attachment to */
        parentId: string;
      };
      header: {
        /** The name of the attachment */
        "X-Skedulo-Name": string;
        /** An optional description of the attachment */
        "X-Skedulo-Description"?: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            result?: {
              filePtr: string;
              size?: string;
              contentType?: string;
              fileName: string;
              /** Format: date-time */
              uploadDate: string;
              parentId: string;
              createdBy?: string;
              createdById?: string;
              description?: string;
              downloadUrl?: string;
            };
          };
        };
      };
      /** Invalid data supplied */
      400: unknown;
    };
  };
  uploadReturnNewMeta: {
    parameters: {
      path: {
        /** Identifier of the parent to add the attachment to */
        parentId: string;
      };
      header: {
        /** The name of the attachment */
        "X-Skedulo-Name": string;
        /** An optional description of the attachment */
        "X-Skedulo-Description"?: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            result?: {
              id: string;
              parentId: string;
              contentType?: string;
              name: string;
              /** Format: date-time */
              createdDate: string;
              contentLength?: string;
              createdById: string;
              description?: string;
              downloadUrl?: string;
            };
          };
        };
      };
      /** Invalid data supplied */
      400: unknown;
    };
  };
  getAvatarFor: {
    parameters: {
      query: {
        /** Comma-separated identifiers of the users to get the avatar urls for */
        user_ids: string;
        /** Requested image size. Return thumbnail image for 'small' or 'thumbnail' input, full image otherwise */
        size_hint?: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": {
            result?: { [key: string]: string };
            errors?: {
              [key: string]: {
                errorType: string;
                errorMsg: string;
              };
            };
            extra?: {
              [key: string]: {
                signature: string;
                expiry: string;
              };
            };
          };
        };
      };
      /** User with the given identifier not found */
      404: unknown;
    };
  };
  getToken: {
    responses: {
      /** Returns the token */
      200: {
        content: {
          "application/json": {
            result: {
              value: string;
            };
          };
        };
      };
      /** If the user does not have a resource id attached */
      400: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "application/json": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  getICal: {
    parameters: {
      path: {
        /** The token */
        token: string;
      };
    };
    responses: {
      /** Returns the iCal */
      200: {
        content: {
          "text/icalendar": string;
        };
      };
      /** If the token is invalid */
      400: {
        content: {
          "text/icalendar": {
            errorType: string;
            message: string;
          };
        };
      };
      /** Error */
      default: {
        content: {
          "text/icalendar": {
            errorType: string;
            message: string;
          };
        };
      };
    };
  };
  /**
   * This endpoint is deprecated, use `/schedule/copy` instead.
   *
   * Jobs, shifts and activities can be copied with their attached allocations/resources and other attachments (e.g. tags). EQL filters must be provided to specify the jobs, shifts and/or activities to be copied. The start and end times of the copied work items will be offset (incremented or decremented) by the provided number of days. Executed in the background as an asynchronous task.
   */
  copyScheduleAsync: {
    responses: {
      /** An asynchronous 'copy schedule' task has been scheduled. */
      200: {
        content: {
          "application/json": {
            result: {
              /** @description The ID of the asynchronous task. This ID can be used to retrieve the status and results of the task. */
              taskId: number;
              /** @description The number of jobs that will be created. */
              totalJobs: number;
              /** @description The number of shifts that will be created. */
              totalShifts: number;
              /** @description The number of activities that will be created. */
              totalActivities: number;
            };
          };
        };
      };
      /** The request was badly formed, a copied work item would start in the past, or the work items to be copied couldn't be retrieved. */
      400: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          jobs?: {
            /** @description An EQL filter for the relevant schema that defines the work items to be copied. To copy specific work items by UID, use a filter like "UID IN ['UID1', 'UID2']". */
            filter: string;
            /** @description Set to true to copy the allocations or resource assignments on each work item. The start and end times of copied allocations will also be offset. Copied job allocations will be in the Pending Dispatch status. Declined and Deleted allocations will not be copied. */
            copyAllocations: boolean;
          };
          shifts?: {
            /** @description An EQL filter for the relevant schema that defines the work items to be copied. To copy specific work items by UID, use a filter like "UID IN ['UID1', 'UID2']". */
            filter: string;
            /** @description Set to true to copy the allocations or resource assignments on each work item. The start and end times of copied allocations will also be offset. Copied job allocations will be in the Pending Dispatch status. Declined and Deleted allocations will not be copied. */
            copyAllocations: boolean;
          };
          activities?: {
            /** @description An EQL filter for the relevant schema that defines the work items to be copied. To copy specific work items by UID, use a filter like "UID IN ['UID1', 'UID2']". */
            filter: string;
            /** @description Set to true to copy the allocations or resource assignments on each work item. The start and end times of copied allocations will also be offset. Copied job allocations will be in the Pending Dispatch status. Declined and Deleted allocations will not be copied. */
            copyAllocations: boolean;
          };
          /** @description The number of days to offset the start and end times of work items and associated objects. The offset can be positive, zero or negative. If any work item would be offset to start in the past, the request will fail. If the offset is non-zero, all work items must have a start time. */
          offsetDays: number;
        };
      };
    };
  };
  /** Jobs, shifts and activities can be copied with their attached allocations/resources and other attachments (e.g. tags). EQL filters must be provided to specify the jobs, shifts and/or activities to be copied. The start and end times of the copied work items will be offset (incremented or decremented) by the provided number of days. Executed in the background as an asynchronous task. */
  copySchedule: {
    responses: {
      /** An asynchronous 'copy schedule' task has been scheduled. */
      200: {
        content: {
          "application/json": {
            result: {
              /** @description The ID of the asynchronous task. This ID can be used to retrieve the status and results of the task. */
              taskId: number;
              /** @description The number of jobs that will be created. */
              totalJobs: number;
              /** @description The number of shifts that will be created. */
              totalShifts: number;
              /** @description The number of activities that will be created. */
              totalActivities: number;
            };
          };
        };
      };
      /** The request was badly formed, a copied work item would start in the past, or the work items to be copied couldn't be retrieved. */
      400: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          jobs?: {
            /** @description An EQL filter for the relevant schema that defines the work items to be copied. To copy specific work items by UID, use a filter like "UID IN ['UID1', 'UID2']". */
            filter: string;
            /** @description Set to true to copy the allocations or resource assignments on each work item. The start and end times of copied allocations will also be offset. Copied job allocations will be in the Pending Dispatch status. Declined and Deleted allocations will not be copied. */
            copyAllocations: boolean;
          };
          shifts?: {
            /** @description An EQL filter for the relevant schema that defines the work items to be copied. To copy specific work items by UID, use a filter like "UID IN ['UID1', 'UID2']". */
            filter: string;
            /** @description Set to true to copy the allocations or resource assignments on each work item. The start and end times of copied allocations will also be offset. Copied job allocations will be in the Pending Dispatch status. Declined and Deleted allocations will not be copied. */
            copyAllocations: boolean;
          };
          activities?: {
            /** @description An EQL filter for the relevant schema that defines the work items to be copied. To copy specific work items by UID, use a filter like "UID IN ['UID1', 'UID2']". */
            filter: string;
            /** @description Set to true to copy the allocations or resource assignments on each work item. The start and end times of copied allocations will also be offset. Copied job allocations will be in the Pending Dispatch status. Declined and Deleted allocations will not be copied. */
            copyAllocations: boolean;
          };
          /** @description The number of days to offset the start and end times of work items and associated objects. The offset can be positive, zero or negative. If any work item would be offset to start in the past, the request will fail. If the offset is non-zero, all work items must have a start time. */
          offsetDays: number;
        };
      };
    };
  };
  /**
   * This endpoint is deprecated, use `/schedule/copy/{taskId}` instead.
   *
   * This endpoint can be polled to get the status of the task and the results of the operation, if any.
   */
  copyScheduleAsyncResults: {
    parameters: {
      path: {
        /** ID of the asynchronous task to be queried. */
        taskId: number;
      };
    };
    responses: {
      /** The status and results of the copy schedule task. Failed tasks will result in a 200 OK with status Failed. */
      200: {
        content: {
          "application/json": {
            /** @description The status of the asynchronous copy operation and optionally the IDs and counts of work items that have been created. */
            result: {
              taskId: number;
              /** @description The time at which the operation was requested. */
              requestedTime: string;
              /** @description The time at which the operation completed. Present if the status is not Pending, InProgress or Stalled. */
              completedTime?: string;
              /**
               * @description The status of an asychronous task.
               * @enum {string}
               */
              status:
                | "Pending"
                | "InProgress"
                | "Completed"
                | "CompletedWithErrors"
                | "Stalled"
                | "Failed";
              jobs?: {
                /** @description The ID of the original work item. */
                original: string;
                /** @description The ID of the copied work item. */
                copy: string;
              }[];
              shifts?: {
                /** @description The ID of the original work item. */
                original: string;
                /** @description The ID of the copied work item. */
                copy: string;
              }[];
              activities?: {
                /** @description The ID of the original work item. */
                original: string;
                /** @description The ID of the copied work item. */
                copy: string;
              }[];
              errors?: {
                item: {
                  /**
                   * @description The type of object that was being modified.
                   * @example JobAllocations
                   */
                  schema: string;
                  /**
                   * @description The operation that was being performed.
                   * @example Insert
                   */
                  operation: string;
                  /** @description The ID of the source object for this particular item (e.g. the original object for copy schedule, or the template object for apply template). */
                  sourceUID?: string;
                };
                /** @description The errors that occurred when executing the operation. */
                errors: string[];
              };
            };
          };
        };
      };
      /** The task was not found. */
      404: unknown;
    };
  };
  /** This endpoint can be polled to get the status of the task and the results of the operation, if any. */
  copyScheduleResults: {
    parameters: {
      path: {
        /** ID of the asynchronous task to be queried. */
        taskId: number;
      };
    };
    responses: {
      /** The status and results of the copy schedule task. Failed tasks will result in a 200 OK with status Failed. */
      200: {
        content: {
          "application/json": {
            /** @description The status of the asynchronous copy operation and optionally the IDs and counts of work items that have been created. */
            result: {
              taskId: number;
              /** @description The time at which the operation was requested. */
              requestedTime: string;
              /** @description The time at which the operation completed. Present if the status is not Pending, InProgress or Stalled. */
              completedTime?: string;
              /**
               * @description The status of an asychronous task.
               * @enum {string}
               */
              status:
                | "Pending"
                | "InProgress"
                | "Completed"
                | "CompletedWithErrors"
                | "Stalled"
                | "Failed";
              jobs?: {
                /** @description The ID of the original work item. */
                original: string;
                /** @description The ID of the copied work item. */
                copy: string;
              }[];
              shifts?: {
                /** @description The ID of the original work item. */
                original: string;
                /** @description The ID of the copied work item. */
                copy: string;
              }[];
              activities?: {
                /** @description The ID of the original work item. */
                original: string;
                /** @description The ID of the copied work item. */
                copy: string;
              }[];
              errors?: {
                item: {
                  /**
                   * @description The type of object that was being modified.
                   * @example JobAllocations
                   */
                  schema: string;
                  /**
                   * @description The operation that was being performed.
                   * @example Insert
                   */
                  operation: string;
                  /** @description The ID of the source object for this particular item (e.g. the original object for copy schedule, or the template object for apply template). */
                  sourceUID?: string;
                };
                /** @description The errors that occurred when executing the operation. */
                errors: string[];
              };
            };
          };
        };
      };
      /** The task was not found. */
      404: unknown;
    };
  };
  /** Multiple jobs and shifts can be dispatched/published in one request. EQL filters must be provided to specify the jobs and shifts to be dispatched. Summary notifications can optionally be sent to each resource. Individual notifications will not be sent for each job/shift. */
  dispatchSchedule: {
    responses: {
      /** The operation has completed. */
      200: {
        content: {
          "application/json": {
            result: {
              /** @description The number of jobs that had allocations dispatched. */
              jobs: number;
              /** @description The number of shifts that were published. */
              shifts: number;
              /**
               * @deprecated
               * @description The number of resources that received a dispatched job or shift. This is deprecated. Use the length of resourceIds instead.
               */
              resources: number;
              /** @description The IDs of resources that had work items updated. */
              resourceIds: string[];
              /** @description Details of any errors that occurred when updating work items. */
              dispatchErrorDetails: {
                /** @description The ID of the job that could not be updated. */
                jobId?: string;
                /** @description The ID of the shift that could not be updated. */
                shiftId?: string;
                /**
                 * Format: uuid
                 * @description Identifies the type of error that occurred.
                 */
                errorType: string;
                /**
                 * Format: uuid
                 * @description A description of the error.
                 */
                message: string;
              }[];
              /**
               * @deprecated
               * @description The number of resources that had an error when attempting to send a notification. This is deprecated. Use the length of notificationErrorDetails instead.
               */
              notificationErrors: number;
              /** @description Details of any errors that occurred when notifying resources about dispatched work items. */
              notificationErrorDetails: {
                /** @description The ID of the resource that could not be notified. */
                resourceId: string;
                /** @description Identifies the type of error that occurred. */
                errorType: string;
                /** @description A description of the error. */
                message: string;
              }[];
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An EQL filter for the jobs to be dispatched. */
          jobsFilter?: string;
          /** @description An EQL filter for the shifts to be dispatched. */
          shifts?: string;
          /** @description If set to true, a notification will be sent to each resource summarizing the number of jobs and/or shifts that were dispatched. */
          notifySummary: boolean;
        };
      };
    };
  };
  /** A schedule template is converted to real jobs, shifts and activities, starting at the given date. Executed in the background as an asynchronous task. */
  applyScheduleTemplate: {
    responses: {
      /** An asynchronous 'apply template' task has been scheduled. */
      200: {
        content: {
          "application/json": {
            result: {
              /** @description The ID of the asynchronous task. This ID can be used to retrieve the status and results of the task. */
              taskId: number;
              /** @description The number of jobs that will be created. */
              totalJobs: number;
              /** @description The number of shifts that will be created. */
              totalShifts: number;
              /** @description The number of activities that will be created. */
              totalActivities: number;
            };
          };
        };
      };
      /** The request was badly formed. */
      400: unknown;
      /** The schedule template was not found. */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The ID of the schedule template to be applied. */
          templateId: string;
          /**
           * Format: date
           * @description The date from which the template should be applied.
           * @example 2020-06-14
           */
          startDate: string;
        };
      };
    };
  };
  /** This endpoint can be polled to get the status of the task and the results of the operation, if any. */
  applyScheduleTemplateResults: {
    parameters: {
      path: {
        /** ID of the asynchronous task to be queried. */
        taskId: number;
      };
    };
    responses: {
      /** The status and results of the task. Failed tasks will result in a 200 OK with status Failed. */
      200: {
        content: {
          "application/json": {
            /** @description The status of the asynchronous 'apply template' task and optionally the IDs of work items that have been created. */
            result: {
              taskId: number;
              /**
               * @description The status of an asychronous task.
               * @enum {string}
               */
              status:
                | "Pending"
                | "InProgress"
                | "Completed"
                | "CompletedWithErrors"
                | "Stalled"
                | "Failed";
              /** @description The name of the scheduled template. */
              templateName?: string;
              /**
               * Format: date
               * @description The start date that was requested.
               */
              startDate?: string;
              /**
               * Format: date
               * @description Not currently supported. The requested end date that the applied template should cover.
               */
              endDate?: string;
              /**
               * Format: date
               * @description The last date that a work item was scheduled. This may be before `endDate` if there are empty days at the end of the template.
               */
              lastWorkItemDate?: string;
              /** @description The period of the template in days. */
              periodDays?: number;
              newWorkItems?: {
                /** @description The IDs of jobs that have been created. */
                jobs: string[];
                /** @description The IDs of shifts that have been created. */
                shifts: string[];
                /** @description The IDs of activities that have been created. */
                activities: string[];
                /** @description Details of any errors that occurred when creating new work items. */
                errors: {
                  item: {
                    /**
                     * @description The type of object that was being modified.
                     * @example JobAllocations
                     */
                    schema: string;
                    /**
                     * @description The operation that was being performed.
                     * @example Insert
                     */
                    operation: string;
                    /** @description The ID of the source object for this particular item (e.g. the original object for copy schedule, or the template object for apply template). */
                    sourceUID?: string;
                  };
                  /** @description The errors that occurred when executing the operation. */
                  errors: string[];
                }[];
              };
              /** @description The time at which the operation was requested. */
              requestedTime: string;
              /** @description The time at which the operation completed. Present if the status is not Pending, InProgress or Stalled. */
              completedTime?: string;
            };
          };
        };
      };
      /** The task was not found. */
      404: unknown;
    };
  };
  /** Get a list of recurring schedules summaries */
  listRecurringSchedules: {
    parameters: {
      query: {
        /** page number to fetch. Defaults to 1 if not provided. */
        page?: number;
        /** number of items to fetch per page. Defaults to 20 if not provided. Maximum allowed is 50. */
        per_page?: number;
      };
    };
    responses: {
      /** Successful */
      200: {
        content: {
          "application/json": {
            /** @description List of recurring schedule summaries */
            result: {
              /** @description current page. Starts from 1 */
              currentPage: number;
              /** @description total number of pages */
              numPages: number;
              /** @description total number of recurring schedules */
              totalCount: number;
              scheduleSummaries: {
                id: string;
                name: string;
                description?: string;
                /** @description Number of jobs in this recurring schedule that have been completed */
                completedJobCount: number;
                /** @description total number of jobs in this recurring schedule (excluding cancelled jobs) */
                allJobCount: number;
                summary?: string;
                /** @description Account ID assigned to jobs of this recurring schedule. Note that this is obtained from the first job that has an Account ID */
                accountId?: string;
                /** @description Contact ID assigned to jobs of this recurring schedule. Note that this is obtained from the first job that has a Contact ID */
                contactId?: string;
                /**
                 * Format: date-time
                 * @description First occurence of this recurring schedule (first job)
                 */
                start?: string;
                /**
                 * Format: date-time
                 * @description Last occurence of this recurring schedule (last job)
                 */
                end?: string;
              }[];
            };
          };
        };
      };
    };
  };
  /** Fields and Child relationships can be specified (e.g. Giving created jobs the same job tags or allocations). By default, required Job fields like Region ID and duration will be propagated even if not specified */
  createRecurringScheduleFromExistingJob: {
    responses: {
      /** Recurring jobs created */
      200: {
        content: {
          "application/json": {
            /** @description ID of the created Recurring Schedule */
            result: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          jobId: string;
          pattern: {
            /**
             * @description If the type is 'dates_only', Only 'includeDates' will be used to generate job times
             * @enum {string}
             */
            type: "dates_only" | "rule";
            /**
             * Format: date
             * @description Date the pattern should end on. If using this, do not provide endAfterNumberOccurrences
             * @example 2020-05-13
             */
            endOn?: string;
            /**
             * @description Number of occurrence to generate. If using this, do not provide endOn.
             * Note: when repeatMode is 'weekly', this value means the number of week periods to generate the intervals from,
             * So when endAfterNumberOccurrences = 4, only the next 4 weeks will be checked (some weeks may not generated an interval due
             * to other rules, leading to less than 4 intervals being generated in total)
             *
             * @example 5
             */
            endAfterNumberOccurrences?: number;
            /**
             * @description How occurences are repeated
             * @enum {string}
             */
            repeatMode?: "daily" | "weekly" | "monthly_nth_day" | "yearly";
            /** @description How many days/months/years between each generated interval. For example, with repeatMode = 'daily' and step = 1, an interval will be generated every day */
            step: number;
            /**
             * @description days of the week to skip. If an interval falls on this day of the week, it will be skipped
             * @example [
             *   "mon",
             *   "tue"
             * ]
             */
            skipOnWeekDays?: (
              | "mon"
              | "tue"
              | "wed"
              | "thu"
              | "fri"
              | "sat"
              | "sun"
            )[];
            /** @description The days of week intervals can occur on. Only applies when repeatMode = 'weekly'. */
            repeatOnWeekDays?: (
              | "mon"
              | "tue"
              | "wed"
              | "thu"
              | "fri"
              | "sat"
              | "sun"
            )[];
            /**
             * @description Whether to skip holidays when generating future jobs (Considers both regional and global holidays)
             * @default false
             */
            skipHolidays?: boolean;
            /** @description If true, job allocations for each job will need to be acknowledged by the resource */
            ackAllJobs: boolean;
            /** @description A list of dates a recurring job cannot occur on */
            excludeDates?: string[];
            /** @description A list of dates the job will occur on. This is in addition to all dates generated by the rule and ignores any dates listed in excludeDates */
            includeDates?: string[];
          };
          fieldsToPropagate: unknown;
          /**
           * Format: date-time
           * @description Overrides the start time used to generate the jobs. This value is required if the base job does not have a start/end time, and the base job will be updated to have start/end of the first generated interval. If the base job already has a start/end time, its start/end will not be modified.
           * @example 2017-05-17T03:30:00Z
           */
          recurFrom?: string;
        };
      };
    };
  };
  /** Get summary of a recurring schedule */
  getSingleRecurringSchedules: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** Successful */
      200: {
        content: {
          "application/json": {
            /** @description Detailed summary of a recurring schedule, containing information about the jobs in this schedule. Cancelled job are excluded. */
            result: {
              id: string;
              name: string;
              description?: string;
              /** @description Number of jobs in this recurring schedule that have been completed */
              completedJobCount: number;
              /** @description total number of jobs in this recurring schedule (excluding cancelled jobs) */
              allJobCount: number;
              summary?: string;
              /** @description Account ID assigned to jobs of this recurring schedule. Note that this is obtained from the first job that has an Account ID */
              accountId?: string;
              /** @description Contact ID assigned to jobs of this recurring schedule. Note that this is obtained from the first job that has a Contact ID */
              contactId?: string;
              /**
               * Format: date-time
               * @description First occurence of this recurring schedule (first job)
               */
              start?: string;
              /**
               * Format: date-time
               * @description Last occurence of this recurring schedule (last job)
               */
              end?: string;
            } & {
              jobs: {
                UID: string;
                /** @enum {string} */
                status:
                  | "Queued"
                  | "Pending Allocation"
                  | "Pending Dispatch"
                  | "Dispatched"
                  | "Ready"
                  | "En Route"
                  | "On Site"
                  | "In Progress"
                  | "Complete";
                /** Format: date-time */
                start?: string;
                /** Format: date-time */
                end?: string;
                account?: {
                  UID: string;
                  name: string;
                };
                contact?: {
                  UID: string;
                  fullName: string;
                  phone?: string;
                  email?: string;
                };
                region: {
                  UID: string;
                  name: string;
                };
              }[];
              /** @description ID of the next job */
              nextJob?: string;
            };
          };
        };
      };
      /** Recurring schedule with given ID cannot be found */
      404: unknown;
    };
  };
  /** Preview the intervals that will be generated for a given recurrence pattern and job details */
  preview: {
    responses: {
      /** Successful result */
      200: {
        content: {
          "application/json": {
            /** @description An array of intervals (start/end) in ISO-8061 format (without millisecond part) */
            result: {
              /**
               * Format: date-time
               * @example 2017-05-17T03:30:00Z
               */
              start: string;
              /**
               * Format: date-time
               * @example 2017-05-17T04:30:00Z
               */
              end: string;
            }[];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          pattern: {
            /**
             * @description If the type is 'dates_only', Only 'includeDates' will be used to generate job times
             * @enum {string}
             */
            type: "dates_only" | "rule";
            /**
             * Format: date
             * @description Date the pattern should end on. If using this, do not provide endAfterNumberOccurrences
             * @example 2020-05-13
             */
            endOn?: string;
            /**
             * @description Number of occurrence to generate. If using this, do not provide endOn.
             * Note: when repeatMode is 'weekly', this value means the number of week periods to generate the intervals from,
             * So when endAfterNumberOccurrences = 4, only the next 4 weeks will be checked (some weeks may not generated an interval due
             * to other rules, leading to less than 4 intervals being generated in total)
             *
             * @example 5
             */
            endAfterNumberOccurrences?: number;
            /**
             * @description How occurences are repeated
             * @enum {string}
             */
            repeatMode?: "daily" | "weekly" | "monthly_nth_day" | "yearly";
            /** @description How many days/months/years between each generated interval. For example, with repeatMode = 'daily' and step = 1, an interval will be generated every day */
            step: number;
            /**
             * @description days of the week to skip. If an interval falls on this day of the week, it will be skipped
             * @example [
             *   "mon",
             *   "tue"
             * ]
             */
            skipOnWeekDays?: (
              | "mon"
              | "tue"
              | "wed"
              | "thu"
              | "fri"
              | "sat"
              | "sun"
            )[];
            /** @description The days of week intervals can occur on. Only applies when repeatMode = 'weekly'. */
            repeatOnWeekDays?: (
              | "mon"
              | "tue"
              | "wed"
              | "thu"
              | "fri"
              | "sat"
              | "sun"
            )[];
            /**
             * @description Whether to skip holidays when generating future jobs (Considers both regional and global holidays)
             * @default false
             */
            skipHolidays?: boolean;
            /** @description If true, job allocations for each job will need to be acknowledged by the resource */
            ackAllJobs: boolean;
            /** @description A list of dates a recurring job cannot occur on */
            excludeDates?: string[];
            /** @description A list of dates the job will occur on. This is in addition to all dates generated by the rule and ignores any dates listed in excludeDates */
            includeDates?: string[];
          };
          /**
           * @description The base job field that will be used to create the recurring schedule. Child objects (e.g. has-many relationship such as JobTags) can also be included -- they will be create and linked with their parent job.
           * Only certain default job fields (see example) are be replicated across the created jobs.
           * To replicate a custom field, lookup or child objects, they need to specified in the baseJob object too (see example).
           *
           * @example {
           *   "Start": "2017-12-23T00:00:00Z",
           *   "RegionId": "a0J28000000TXd3EAG",
           *   "Duration": 30,
           *   "AccountId": "0051I000000hycRQAQ",
           *   "Address": "170 Smith Road",
           *   "CanBeDeclined": true,
           *   "ContactId": "0051I000000hhcRQAQ",
           *   "Description": "description of the job",
           *   "GeoLatitude": 100,
           *   "GeoLongitude": 100,
           *   "LocationId": "0051I000000hycRQAQ",
           *   "Locked": false,
           *   "NotesComments": "a comment on the job",
           *   "Type": "Installation",
           *   "Urgency": "Urgent",
           *   "Quantity": 2,
           *   "MyCustomText": "hello world",
           *   "JobTags": [
           *     {
           *       "TagId": "a0B0K00000XR5bPUAT",
           *       "Required": true
           *     }
           *   ]
           * }
           */
          baseJob: {
            /**
             * Format: date-time
             * @description Start time of the job which is also the base time / date where the pattern starts generating new jobs from. All generated jobs will have the same clock time as the base job (For example if the first job is at 3pm, all future jobs will occur at 3pm as well)
             */
            Start: string;
            Duration: number;
            /** @description RegionId is used to obtain holidays associated with the region, which are used to avoid creating jobs on regional or global holidays */
            RegionId: string;
          };
        };
      };
    };
  };
  /** Updates the fields and attached objects of jobs in a recurring schedule, where the jobs start at or after the provided timestamp. Arrays of attached 'HasMany' objects can be provided along with the fields to be updated. In this case, all existing attached objects of the same type on future jobs will be deleted and replaced with the provided objects. Job IDs may be explicitly excluded - this allows the caller to prevent modifying the job that they are currently displaying. Jobs that are Locked, In Progress, Completed or Cancelled will not be updated. */
  updateJobs: {
    responses: {
      /** jobs successfully updated */
      200: {
        content: {
          "application/json": {
            /** @description A list of the jobs that were updated with their fields and 'HasMany' object lists. May be an empty array if no jobs were updated due to filtering. */
            result: { [key: string]: unknown }[];
          };
        };
      };
    };
    /** Information about how the jobs will be updated. */
    requestBody: {
      content: {
        "application/json": {
          recurringScheduleId: string;
          /**
           * Format: date-time
           * @description Only apply changes to jobs that start at or after this instant in time.
           * @example 2017-05-17T03:30:00Z
           */
          from: string;
          /**
           * Format: time
           * @description Start time for the jobs. For each job the clock time will be adjusted to match this time. The job date will remain the same as before. If this parameter is not provided, job schedules will not be updated.
           * @example 15:00
           */
          start?: string;
          /** @description A list of job IDs that should not be updated. */
          excludeJobIds?: string[];
          /**
           * @description The new duration for each job in minutes. Must be provided along with "start" if updating job schedule.
           * @example 15
           */
          duration?: number;
          /**
           * @description The fields and values that should be updated on the jobs. Lists of attached 'HasMany' objects can be provided as arrays (e.g. 'JobTasks'). All existing attached objects on future jobs will be deleted and replaced with the provided objects. Any unsupported fields provided (e.g. notifyBy) will not be modified. All custom fields given in this object will be updated.
           * @example {
           *   "Description": "new description",
           *   "JobTasks": [
           *     {
           *       "Seq": 1,
           *       "Name": "Task 1",
           *       "Completed": false
           *     },
           *     {
           *       "Seq": 2,
           *       "Name": "Task 2",
           *       "Completed": false
           *     }
           *   ]
           * }
           */
          jobFields: { [key: string]: unknown };
        };
      };
    };
  };
  /** Create a recurring schedule from a base job and pattern */
  createRecurringSchedule: {
    responses: {
      /** Successful */
      200: {
        content: {
          "application/json": {
            /** @description ID of the created recurring schedule */
            result: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The base job field that will be used to create the recurring schedule. Child objects (e.g. has-many relationship such as JobTags) can also be included -- they will be create and linked with their parent job.
           * Only certain default job fields (see example) are be replicated across the created jobs.
           * To replicate a custom field, lookup or child objects, they need to specified in the baseJob object too (see example).
           *
           * @example {
           *   "Start": "2017-12-23T00:00:00Z",
           *   "RegionId": "a0J28000000TXd3EAG",
           *   "Duration": 30,
           *   "AccountId": "0051I000000hycRQAQ",
           *   "Address": "170 Smith Road",
           *   "CanBeDeclined": true,
           *   "ContactId": "0051I000000hhcRQAQ",
           *   "Description": "description of the job",
           *   "GeoLatitude": 100,
           *   "GeoLongitude": 100,
           *   "LocationId": "0051I000000hycRQAQ",
           *   "Locked": false,
           *   "NotesComments": "a comment on the job",
           *   "Type": "Installation",
           *   "Urgency": "Urgent",
           *   "Quantity": 2,
           *   "MyCustomText": "hello world",
           *   "JobTags": [
           *     {
           *       "TagId": "a0B0K00000XR5bPUAT",
           *       "Required": true
           *     }
           *   ]
           * }
           */
          baseJob: {
            /**
             * Format: date-time
             * @description Start time of the job which is also the base time / date where the pattern starts generating new jobs from. All generated jobs will have the same clock time as the base job (For example if the first job is at 3pm, all future jobs will occur at 3pm as well)
             */
            Start: string;
            Duration: number;
            /** @description RegionId is used to obtain holidays associated with the region, which are used to avoid creating jobs on regional or global holidays */
            RegionId: string;
          };
          pattern: {
            /**
             * @description If the type is 'dates_only', Only 'includeDates' will be used to generate job times
             * @enum {string}
             */
            type: "dates_only" | "rule";
            /**
             * Format: date
             * @description Date the pattern should end on. If using this, do not provide endAfterNumberOccurrences
             * @example 2020-05-13
             */
            endOn?: string;
            /**
             * @description Number of occurrence to generate. If using this, do not provide endOn.
             * Note: when repeatMode is 'weekly', this value means the number of week periods to generate the intervals from,
             * So when endAfterNumberOccurrences = 4, only the next 4 weeks will be checked (some weeks may not generated an interval due
             * to other rules, leading to less than 4 intervals being generated in total)
             *
             * @example 5
             */
            endAfterNumberOccurrences?: number;
            /**
             * @description How occurences are repeated
             * @enum {string}
             */
            repeatMode?: "daily" | "weekly" | "monthly_nth_day" | "yearly";
            /** @description How many days/months/years between each generated interval. For example, with repeatMode = 'daily' and step = 1, an interval will be generated every day */
            step: number;
            /**
             * @description days of the week to skip. If an interval falls on this day of the week, it will be skipped
             * @example [
             *   "mon",
             *   "tue"
             * ]
             */
            skipOnWeekDays?: (
              | "mon"
              | "tue"
              | "wed"
              | "thu"
              | "fri"
              | "sat"
              | "sun"
            )[];
            /** @description The days of week intervals can occur on. Only applies when repeatMode = 'weekly'. */
            repeatOnWeekDays?: (
              | "mon"
              | "tue"
              | "wed"
              | "thu"
              | "fri"
              | "sat"
              | "sun"
            )[];
            /**
             * @description Whether to skip holidays when generating future jobs (Considers both regional and global holidays)
             * @default false
             */
            skipHolidays?: boolean;
            /** @description If true, job allocations for each job will need to be acknowledged by the resource */
            ackAllJobs: boolean;
            /** @description A list of dates a recurring job cannot occur on */
            excludeDates?: string[];
            /** @description A list of dates the job will occur on. This is in addition to all dates generated by the rule and ignores any dates listed in excludeDates */
            includeDates?: string[];
          };
        };
      };
    };
  };
  /** Create or update job allocations for certain resources */
  upsertJobAllocations: {
    responses: {
      /** Jobs allocations has been successfully created or updated. */
      200: {
        content: {
          "application/json": {
            /** @description A list of job allocation IDs that were created or updated. */
            result: {
              inserted: string[];
              updated: string[];
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: date-time
           * @description Only create/update job allocations for jobs that start after this instant in time.
           * @example 2017-05-17T03:30:00Z
           */
          from: string;
          recurringScheduleId: string;
          /** @description Skip updating any job allocations that are attached to these job identifiers. */
          excludeJobIds?: string[];
          /**
           * @description ID of the resources of which job allocations will be created or updated for. Any existing job allocations not belonging to these resources will not be modified.
           * @example [
           *   "res_1",
           *   "res_2"
           * ]
           */
          resourceIds: string[];
          /**
           * @description A JSON object containing fields for the job allocation to create. Existing job allocations will be updated too.
           * @example {
           *   "Hours": 5,
           *   "NotificationType": "push"
           * }
           */
          jobAllocBase: { [key: string]: unknown };
        };
      };
    };
  };
  /** Delete job allocations for certain resources */
  deleteJobAllocations: {
    responses: {
      /** Job allocations deleted */
      200: {
        content: {
          "application/json": {
            /**
             * @description A list of jobs and their job allocations that were deleted
             * @example {
             *   "job_1": [
             *     "job_alloc_1",
             *     "job_alloc_2"
             *   ],
             *   "job_2": [
             *     "job_alloc_3"
             *   ]
             * }
             */
            result: { [key: string]: unknown };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: date-time
           * @description Only delete job allocations for jobs that start after this instant
           * @example 2017-05-17T03:30:00Z
           */
          from: string;
          recurringScheduleId: string;
          /**
           * @description ID of the resources of which job allocations will be deleted.
           * @example [
           *   "res_1",
           *   "res_2"
           * ]
           */
          resourceIds: string[];
        };
      };
    };
  };
  createMeeting: {
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: uri
               * @description URL for the host to join and start the meeting
               */
              hostUrl: string;
              /**
               * Format: uri
               * @description URL for an invitee to join the meeting
               */
              inviteeUrl: string;
              /** @description Unique Id of the virtual meeting */
              id: string;
              /** @description Password of the virtual meeting */
              password?: string;
              /** @description Zoom specific information about the virtual meeting (when Zoom is the meeting provider) */
              zoom?: { [key: string]: unknown };
              /** @description MS Teams specific information about the virtual meeting (when Teams is the meeting provider) */
              teams?: { [key: string]: unknown };
            };
          };
        };
      };
      /** The hosting resource has no email specified */
      400: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Topic of the virtual meeting */
          topic: string;
          /** @description Agenda of the virtual meeting */
          agenda: string;
          /**
           * Format: date-time
           * @description Start time of the virtual meeting in ISO8601 format
           */
          startTime: string;
          /** @description Duration (in minutes) of the virtual meeting */
          duration: number;
          /** @description Password of the virtual meeting */
          password?: string;
          /** @description Optional Zoom specific information about the virtual meeting (when Zoom is the meeting provider). Most Zoom meetings can be created without this. */
          zoom?: { [key: string]: unknown };
          /** @description Optional MS Teams specific information about the virtual meeting (when Teams is the meeting provider). Most Teams meetings can be created without this. */
          teams?: { [key: string]: unknown };
        } & {
          /** @description Resource Id of the resource that hosts the virtual meeting */
          hostResourceId: string;
        };
      };
    };
  };
  getMeeting: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: uri
               * @description URL for the host to join and start the meeting
               */
              hostUrl: string;
              /**
               * Format: uri
               * @description URL for an invitee to join the meeting
               */
              inviteeUrl: string;
              /** @description Unique Id of the virtual meeting */
              id: string;
              /** @description Password of the virtual meeting */
              password?: string;
              /** @description Zoom specific information about the virtual meeting (when Zoom is the meeting provider) */
              zoom?: { [key: string]: unknown };
              /** @description MS Teams specific information about the virtual meeting (when Teams is the meeting provider) */
              teams?: { [key: string]: unknown };
            };
          };
        };
      };
    };
  };
  updateMeeting: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            result: {
              /**
               * Format: uri
               * @description URL for the host to join and start the meeting
               */
              hostUrl: string;
              /**
               * Format: uri
               * @description URL for an invitee to join the meeting
               */
              inviteeUrl: string;
              /** @description Unique Id of the virtual meeting */
              id: string;
              /** @description Password of the virtual meeting */
              password?: string;
              /** @description Zoom specific information about the virtual meeting (when Zoom is the meeting provider) */
              zoom?: { [key: string]: unknown };
              /** @description MS Teams specific information about the virtual meeting (when Teams is the meeting provider) */
              teams?: { [key: string]: unknown };
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Topic of the virtual meeting */
          topic: string;
          /** @description Agenda of the virtual meeting */
          agenda: string;
          /**
           * Format: date-time
           * @description Start time of the virtual meeting in ISO8601 format
           */
          startTime: string;
          /** @description Duration (in minutes) of the virtual meeting */
          duration: number;
          /** @description Password of the virtual meeting */
          password?: string;
          /** @description Optional Zoom specific information about the virtual meeting (when Zoom is the meeting provider). Most Zoom meetings can be created without this. */
          zoom?: { [key: string]: unknown };
          /** @description Optional MS Teams specific information about the virtual meeting (when Teams is the meeting provider). Most Teams meetings can be created without this. */
          teams?: { [key: string]: unknown };
        };
      };
    };
  };
  deleteMeeting: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** Success */
      204: never;
    };
  };
  QueryService_GetDataSchema: {
    parameters: {
      path: {
        /** The ID of the resource to get the data schema for. */
        resourceId: unknown;
      };
      query: {
        /** How deep to recurse when resolving relationships. */
        depth?: unknown;
        /** True to force regeneration of the data schema. */
        generate?: unknown;
        /** Allowed paths we want to resolve from relationships */
        "relationshipResolution.allow"?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  QueryService_DeleteDataSchema: {
    parameters: {
      path: {
        /** The ID of the resource to delete the data schema for. */
        resourceId: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  QueryService_GetObjects: {
    parameters: {
      path: {
        /** resource_id is the id of the resource to query. */
        resourceId: unknown;
      };
      query: {
        /** query is the query string we should use to filter the results. */
        query?: unknown;
        /** limit is the number of records to fetch. */
        limit?: unknown;
        /** sorting is a comma separated list of sorting options. */
        sorting?: unknown;
        /** cursor is the cursor to use for scrolling purposes. */
        cursor?: unknown;
        /** tz is the timezone that will be used for date math within the query. */
        tz?: unknown;
        /** depth is the depth we should iterate to when fetching related data. */
        depth?: unknown;
        /** Allowed paths we want to resolve from relationships */
        "relationshipResolution.allow"?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  QueryService_CreateObject: {
    parameters: {
      path: {
        /** The ID of the resource to create. */
        resourceId: unknown;
      };
      body: {
        body: {
          /** @description The data. */
          data?: string;
          /** @description Optional, otherwise use the default validation schema. */
          validation?: string;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  QueryService_GetObject: {
    parameters: {
      path: {
        /** resource_id is the id of the resource to query. */
        resourceId: unknown;
        /** the id that identifies the single object. */
        objectId: unknown;
      };
      query: {
        /** depth is the depth we should iterate to when fetching related data. */
        depth?: unknown;
        /** Allowed paths we want to resolve from relationships */
        "relationshipResolution.allow"?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  QueryService_UpdateObject: {
    parameters: {
      path: {
        /** The ID of the resource. */
        resourceId: unknown;
        /** The ID of the object to delete. */
        objectId: unknown;
      };
      body: {
        body: {
          /** @description The update data. */
          data?: string;
          /** @description Optional, otherwise use the default validation schema. */
          validation?: string;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  QueryService_DeleteObject: {
    parameters: {
      path: {
        /** The ID of the resource. */
        resourceId: unknown;
        /** The ID of the object to delete. */
        objectId: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  /** Returns schema for a single field in the given resources schema. */
  QueryService_GetFieldSchema: {
    parameters: {
      path: {
        /** The ID of the resource */
        resourceId: unknown;
        /** A dot seperated path to a field. */
        accessor: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_ExecuteBulkAction: {
    parameters: {
      body: {
        body: {
          action?: string;
          resourceId?: string;
          objectIds?: string[];
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_CleanUpTenant: {
    parameters: {
      body: {
        body: {
          uid?: string;
          only?: (
            | "RECORD_TYPE_UNSPECIFIED"
            | "RESOURCE"
            | "LIST"
            | "FILTER"
            | "VIEW_OVERRIDE"
            | "NAV"
            | "TEMPLATE"
            | "VALIDATION"
            | "SCHEMA"
            | "DATA_SCHEMA"
          )[];
          tenantRange?: {
            inRegion?: string[];
            /** Format: int32 */
            limit?: number;
            /** Format: int32 */
            offset?: number;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewDataRelationshipOverlay: {
    parameters: {
      body: {
        body: {
          overlay?: {
            /** uid is the unique id */
            uid?: string;
            /** userId is the user scoped uid */
            userId?: string;
            /** tenantId is the tenant scoped uid */
            tenantId?: string;
            /** The name of the resource this overrides */
            resourceName?: string;
            /**
             * @description Kind is the type of data this field contains.
             * @default RELATIONSHIP_KIND_UNSPECIFIED
             * @enum {string}
             */
            kind?:
              | "RELATIONSHIP_KIND_UNSPECIFIED"
              | "ONE_TO_MANY"
              | "MANY_TO_ONE"
              | "ONE_TO_ONE"
              | "MANY_TO_MANY";
            /** the name of the field within the resource this overrides */
            fieldName?: string;
            /** @description Label is the field label. */
            fieldLabel?: string;
            /**
             * The local field reference
             * @description DataFieldReference allows you to make reference to a given field within a resources DataSchema.
             */
            localField?: {
              /**
               * @description The ID of the resource this field references.
               * If this is empty you should use the resource name to fetch the most appropriate resource.
               */
              resourceId?: string;
              /** @description The name of the resource this field references. */
              resourceName?: string;
              /** @description The name of the field in the given resources DataSchema. */
              fieldName?: string;
              /** @description An optional template that can be used to extract a modified value when resolving the relationship. */
              valueTemplate?: string;
            };
            /**
             * The foreign field reference
             * @description DataFieldReference allows you to make reference to a given field within a resources DataSchema.
             */
            foreignField?: {
              /**
               * @description The ID of the resource this field references.
               * If this is empty you should use the resource name to fetch the most appropriate resource.
               */
              resourceId?: string;
              /** @description The name of the resource this field references. */
              resourceName?: string;
              /** @description The name of the field in the given resources DataSchema. */
              fieldName?: string;
              /** @description An optional template that can be used to extract a modified value when resolving the relationship. */
              valueTemplate?: string;
            };
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /**
             * createdAt UTC timestamp in rfc3339
             * Format: date-time
             */
            createdAt?: string;
            /** createdBy user uid */
            createdBy?: string;
            /**
             * updatedAt UTC timestamp in rfc3339
             * Format: date-time
             */
            updatedAt?: string;
            /** updatedBy user uid */
            updatedBy?: string;
            /**
             * deletedAt UTC timestamp in rfc3339
             * Format: date-time
             */
            deletedAt?: string;
            /** deletedBy user uid */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutDataRelationshipOverlay: {
    parameters: {
      path: {
        /** uid is the unique id */
        "overlay.uid": unknown;
      };
      body: {
        body: {
          overlay?: {
            /** userId is the user scoped uid */
            userId?: string;
            /** tenantId is the tenant scoped uid */
            tenantId?: string;
            /** The name of the resource this overrides */
            resourceName?: string;
            /**
             * @description Kind is the type of data this field contains.
             * @default RELATIONSHIP_KIND_UNSPECIFIED
             * @enum {string}
             */
            kind?:
              | "RELATIONSHIP_KIND_UNSPECIFIED"
              | "ONE_TO_MANY"
              | "MANY_TO_ONE"
              | "ONE_TO_ONE"
              | "MANY_TO_MANY";
            /** the name of the field within the resource this overrides */
            fieldName?: string;
            /** @description Label is the field label. */
            fieldLabel?: string;
            /**
             * The local field reference
             * @description DataFieldReference allows you to make reference to a given field within a resources DataSchema.
             */
            localField?: {
              /**
               * @description The ID of the resource this field references.
               * If this is empty you should use the resource name to fetch the most appropriate resource.
               */
              resourceId?: string;
              /** @description The name of the resource this field references. */
              resourceName?: string;
              /** @description The name of the field in the given resources DataSchema. */
              fieldName?: string;
              /** @description An optional template that can be used to extract a modified value when resolving the relationship. */
              valueTemplate?: string;
            };
            /**
             * The foreign field reference
             * @description DataFieldReference allows you to make reference to a given field within a resources DataSchema.
             */
            foreignField?: {
              /**
               * @description The ID of the resource this field references.
               * If this is empty you should use the resource name to fetch the most appropriate resource.
               */
              resourceId?: string;
              /** @description The name of the resource this field references. */
              resourceName?: string;
              /** @description The name of the field in the given resources DataSchema. */
              fieldName?: string;
              /** @description An optional template that can be used to extract a modified value when resolving the relationship. */
              valueTemplate?: string;
            };
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /**
             * createdAt UTC timestamp in rfc3339
             * Format: date-time
             */
            createdAt?: string;
            /** createdBy user uid */
            createdBy?: string;
            /**
             * updatedAt UTC timestamp in rfc3339
             * Format: date-time
             */
            updatedAt?: string;
            /** updatedBy user uid */
            updatedBy?: string;
            /**
             * deletedAt UTC timestamp in rfc3339
             * Format: date-time
             */
            deletedAt?: string;
            /** deletedBy user uid */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetDataRelationshipOverlay: {
    parameters: {
      path: {
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelDataRelationshipOverlay: {
    parameters: {
      path: {
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewDataSchemaFieldOverlay: {
    parameters: {
      body: {
        body: {
          /**
           * @description DataSchemaFieldOverlay is a overlay to the data schema object where multiple DataSchemas can be overridden on
           * a system, tenant or user basis. Each item overlays one specific field in the DataSchema.
           */
          overlay?: {
            /** uid is the unique id */
            uid?: string;
            /** userId is the user scoped uid */
            userId?: string;
            /** tenantId is the tenant scoped uid */
            tenantId?: string;
            /** The name of the resource this overrides */
            resourceName?: string;
            /** the name of the field within the resource this overrides */
            fieldName?: string;
            /** @description Label is the field label. */
            fieldLabel?: string;
            /** @description Is list is true if this field contains a list of the given kind. */
            fieldIsList?: boolean;
            /** @description Is nullable is true if this field can be null. */
            fieldIsNullable?: boolean;
            /** @description Is sortable is true if you are able to sort on this field. */
            fieldIsSortable?: boolean;
            /** @description Is filterable is true if you are able to filter on this field. */
            fieldIsFilterable?: boolean;
            /**
             * @description Kind is the type of data this field contains.
             * @default DATA_FIELD_KIND_UNSPECIFIED
             * @enum {string}
             */
            fieldKind?:
              | "DATA_FIELD_KIND_UNSPECIFIED"
              | "STRING"
              | "BOOL"
              | "INT"
              | "ENUM"
              | "RELATED_OBJECT"
              | "DATETIME"
              | "TIMESTAMP"
              | "DECIMAL"
              | "DATE"
              | "OBJECT";
            /** @description KindDataEnum contains information about the enum. */
            enum?: {
              values?: {
                stringValue?: string;
                boolValue?: boolean;
                /** Format: int64 */
                intValue?: string;
                isDefault?: boolean;
                label?: string;
              }[];
            };
            /** @description KindDataDecimal contains information about the decimal. */
            decimal?: {
              /**
               * Format: int32
               * @description The number of numbers within the decimal.
               */
              precision?: number;
              /**
               * Format: int32
               * @description The number of numbers to the right of the decimal point in the decimal.
               */
              scale?: number;
            };
            /** @description KindDataString contains information about the string. */
            string?: {
              /**
               * Format: int32
               * @description The max length of the string.
               */
              maxLength?: number;
            };
            /** @description KindDataString contains information about the string. */
            int?: {
              /**
               * Format: int32
               * @description The precision of the int. Either 32 or 64.
               */
              precision?: number;
              /**
               * @description Defines whether or not this int represents a duration.
               * This is important for Skedulo GraphQL datasources since duration types need to be filtered differently.
               */
              isDuration?: boolean;
            };
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /**
             * createdAt UTC timestamp in rfc3339
             * Format: date-time
             */
            createdAt?: string;
            /** createdBy user uid */
            createdBy?: string;
            /**
             * updatedAt UTC timestamp in rfc3339
             * Format: date-time
             */
            updatedAt?: string;
            /** updatedBy user uid */
            updatedBy?: string;
            /**
             * deletedAt UTC timestamp in rfc3339
             * Format: date-time
             */
            deletedAt?: string;
            /** deletedBy user uid */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutDataSchemaFieldOverlay: {
    parameters: {
      path: {
        /** uid is the unique id */
        "overlay.uid": unknown;
      };
      body: {
        body: {
          /**
           * @description DataSchemaFieldOverlay is a overlay to the data schema object where multiple DataSchemas can be overridden on
           * a system, tenant or user basis. Each item overlays one specific field in the DataSchema.
           */
          overlay?: {
            /** userId is the user scoped uid */
            userId?: string;
            /** tenantId is the tenant scoped uid */
            tenantId?: string;
            /** The name of the resource this overrides */
            resourceName?: string;
            /** the name of the field within the resource this overrides */
            fieldName?: string;
            /** @description Label is the field label. */
            fieldLabel?: string;
            /** @description Is list is true if this field contains a list of the given kind. */
            fieldIsList?: boolean;
            /** @description Is nullable is true if this field can be null. */
            fieldIsNullable?: boolean;
            /** @description Is sortable is true if you are able to sort on this field. */
            fieldIsSortable?: boolean;
            /** @description Is filterable is true if you are able to filter on this field. */
            fieldIsFilterable?: boolean;
            /**
             * @description Kind is the type of data this field contains.
             * @default DATA_FIELD_KIND_UNSPECIFIED
             * @enum {string}
             */
            fieldKind?:
              | "DATA_FIELD_KIND_UNSPECIFIED"
              | "STRING"
              | "BOOL"
              | "INT"
              | "ENUM"
              | "RELATED_OBJECT"
              | "DATETIME"
              | "TIMESTAMP"
              | "DECIMAL"
              | "DATE"
              | "OBJECT";
            /** @description KindDataEnum contains information about the enum. */
            enum?: {
              values?: {
                stringValue?: string;
                boolValue?: boolean;
                /** Format: int64 */
                intValue?: string;
                isDefault?: boolean;
                label?: string;
              }[];
            };
            /** @description KindDataDecimal contains information about the decimal. */
            decimal?: {
              /**
               * Format: int32
               * @description The number of numbers within the decimal.
               */
              precision?: number;
              /**
               * Format: int32
               * @description The number of numbers to the right of the decimal point in the decimal.
               */
              scale?: number;
            };
            /** @description KindDataString contains information about the string. */
            string?: {
              /**
               * Format: int32
               * @description The max length of the string.
               */
              maxLength?: number;
            };
            /** @description KindDataString contains information about the string. */
            int?: {
              /**
               * Format: int32
               * @description The precision of the int. Either 32 or 64.
               */
              precision?: number;
              /**
               * @description Defines whether or not this int represents a duration.
               * This is important for Skedulo GraphQL datasources since duration types need to be filtered differently.
               */
              isDuration?: boolean;
            };
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /**
             * createdAt UTC timestamp in rfc3339
             * Format: date-time
             */
            createdAt?: string;
            /** createdBy user uid */
            createdBy?: string;
            /**
             * updatedAt UTC timestamp in rfc3339
             * Format: date-time
             */
            updatedAt?: string;
            /** updatedBy user uid */
            updatedBy?: string;
            /**
             * deletedAt UTC timestamp in rfc3339
             * Format: date-time
             */
            deletedAt?: string;
            /** deletedBy user uid */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetDataSchemaFieldOverlay: {
    parameters: {
      path: {
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelDataSchemaFieldOverlay: {
    parameters: {
      path: {
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetDataSchemaOverlays: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        resourceName?: unknown;
        limit?: unknown;
        page?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetDestinations: {
    parameters: {
      query: {
        /**
         * - DESTINATION_UNSPECIFIED: Not specified. This value should be never used.
         *  - NOOP: Does nothing.
         *  - PLATFORM: Links to a Platform Page slug.
         *  - LINK: Links to a URI. The path can be absolute or relative.
         *  - PAGE: Links to a Phoenix page. The path should be relative.
         *  - WEBX: Links to a WebExtension. The path should be relative.
         */
        destination?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetFilters: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "resourceId.strategy"?: unknown;
        /** The value to be matched. */
        "resourceId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        /** The maximum number of items to return. Zero returns everything. */
        limit?: unknown;
        /** Filter results which match name. */
        name?: unknown;
        /** The page number to fetch. Used with limit. */
        page?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewFilter: {
    parameters: {
      body: {
        body: {
          /**
           * Filter to represent a registered Filter component configuration
           * {
           *   "uid": "1111",
           *   "name": "Jobs Filter Config A",
           *   "resource_id": "0101",
           *   "user_id": "some-user",
           *   "tenant_id": "some-tenant",
           *   "domain_id": "some-domain",
           *   "query": "status: completed",
           *   "sorting": ["name", "-resource_id"]
           * }
           * @description Required. The Filter to create.
           */
          filter?: {
            /** @description Output only. The unique ID of the filter. */
            uid?: string;
            /** @description Required. The human readable name of the filter. */
            name: string;
            resourceId?: string;
            /** @description The ID of the user this filter is used for. */
            userId?: string;
            /** @description The ID of the tenant this filter is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            query?: string;
            sorting?: string[];
            /**
             * Format: int32
             * @description The maximum depth used when querying relational structures.
             */
            depth?: number;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetRelevantFilter: {
    parameters: {
      path: {
        resourceId: unknown;
      };
      query: {
        userId?: unknown;
        tenantId?: unknown;
        domainId?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutFilter: {
    parameters: {
      path: {
        /** Output only. The unique ID of the filter. */
        "filter.uid": unknown;
      };
      body: {
        body: {
          /**
           * The Filter to update.
           * @description The Filter to update.
           */
          filter?: {
            /** @description Required. The human readable name of the filter. */
            name: string;
            resourceId?: string;
            /** @description The ID of the user this filter is used for. */
            userId?: string;
            /** @description The ID of the tenant this filter is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            query?: string;
            sorting?: string[];
            /**
             * Format: int32
             * @description The maximum depth used when querying relational structures.
             */
            depth?: number;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        } & {
          name: unknown;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetFilter: {
    parameters: {
      path: {
        /** The UID of the Filter. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelFilter: {
    parameters: {
      path: {
        /** The UID of the Filter. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetLists: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "resourceId.strategy"?: unknown;
        /** The value to be matched. */
        "resourceId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        /** The maximum number of items to return. Zero returns everything. */
        limit?: unknown;
        /** Filter results which match name. */
        name?: unknown;
        /** The page number to fetch. Used with limit. */
        page?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewList: {
    parameters: {
      body: {
        body: {
          /**
           * List to represent a registered List component configuration
           * {
           *   "uid": "1111",
           *   "name": "Jobs List Config A",
           *   "resource_id": "0101",
           *   "user_id": "some-user",
           *   "tenant_id": "some-tenant",
           *   "domain_id": "some-domain",
           *   "columns": {
           *     "0": {
           *       "title": "Job name",
           *       "template": "{{ .name }} {{ .description }}"
           *     },
           *     "1": {
           *       "title": "Manage",
           *       "template": "<a href=\"skedulo.com/manage/job/{{ .id }}\">Manage</a>"
           *     }
           *   },
           *   "ordering": ["0", "1"]
           * }
           * @description Required. The list to create.
           */
          list?: {
            /** @description Output only. The unique ID of the list. */
            uid?: string;
            /** @description Required. The human readable name of the list. */
            name: string;
            /** @description The ID of the resource this list is associated with. */
            resourceId?: string;
            /** @description The ID of the user this list belongs to. */
            userId?: string;
            /** @description The ID of the tenant this list belongs to. */
            tenantId?: string;
            /** @description Deprecated. The ID of the domain this list belongs to. */
            domainId?: string;
            /** @description The columns in the list. */
            columns?: {
              [key: string]: {
                /** @description Required. The column header shown to the user. */
                title: string;
                /** @description Required. The template for the column entries. */
                template: string;
              };
            };
            /** @description The order in which to display the columns in this list. The entries in this list must match the keys in `columns`. */
            ordering?: string[];
            /**
             * Format: int32
             * @description The maximum depth used when querying relational structures.
             */
            depth?: number;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Indicates the relationships or partial relationships that should be resolved. */
            relationshipResolution?: {
              /** Allowed paths we want to resolve from relationships */
              allow?: string[];
            };
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetRelevantList: {
    parameters: {
      path: {
        resourceId: unknown;
      };
      query: {
        userId?: unknown;
        tenantId?: unknown;
        domainId?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutList: {
    parameters: {
      path: {
        /** Output only. The unique ID of the list. */
        "list.uid": unknown;
      };
      body: {
        body: {
          /**
           * Required. The list to update.
           * @description Required. The list to update.
           */
          list?: {
            /** @description Required. The human readable name of the list. */
            name: string;
            /** @description The ID of the resource this list is associated with. */
            resourceId?: string;
            /** @description The ID of the user this list belongs to. */
            userId?: string;
            /** @description The ID of the tenant this list belongs to. */
            tenantId?: string;
            /** @description Deprecated. The ID of the domain this list belongs to. */
            domainId?: string;
            /** @description The columns in the list. */
            columns?: {
              [key: string]: {
                /** @description Required. The column header shown to the user. */
                title: string;
                /** @description Required. The template for the column entries. */
                template: string;
              };
            };
            /** @description The order in which to display the columns in this list. The entries in this list must match the keys in `columns`. */
            ordering?: string[];
            /**
             * Format: int32
             * @description The maximum depth used when querying relational structures.
             */
            depth?: number;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Indicates the relationships or partial relationships that should be resolved. */
            relationshipResolution?: {
              /** Allowed paths we want to resolve from relationships */
              allow?: string[];
            };
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        } & {
          name: unknown;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetList: {
    parameters: {
      path: {
        /** Required. The UID of the List. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelList: {
    parameters: {
      path: {
        /** Required. The UID of the List. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetNavs: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        /** Filter results which matching name. */
        name?: unknown;
        /** The maximum number of items to return. Zero returns everything. */
        limit?: unknown;
        /** The page number to fetch. Used with limit. */
        page?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewNav: {
    parameters: {
      body: {
        body: {
          /**
           * Nav type definition
           * A typical 3 sections nav can be constructed as below, ignoring metadata:
           * +-------+-----------+----------+
           * | List  | Manage    | More     |
           * +-------+-----------+----------+--------+
           * | Jobs  | Accounts  | External | Google |
           * +-------+-----------+----------+--------+
           * | Wines |
           * +-------+
           * In JSON representation:
           * {
           *   "nav" : {
           *     "name": "Main",
           *     "nodes" : [
           *       { "ref": "List", "label": "List", "destination": "NOOP",
           *         "nodes": [
           *           {"ref": "jobs-list", "label": "Jobs", "destination": "PLATFORM"},
           *           {"ref": "wines-list", "label": "Wines", "destination": "PLATFORM"}
           *         ]
           *       },
           *       {
           *         "ref": "/manage-page-path", "label": "Manage", "destination": "PAGE",
           *         "nodes": [
           *           {"ref": "accounts-list", "label": "Accounts", "destination": "PLATFORM"}
           *         ]
           *       },
           *       {
           *         "ref": "More", "label": "More", "destination": "NOOP",
           *         "nodes": [
           *           { "ref": "Externals", "label": "Externals", "destination": "NOOP",
           *             "nodes": [
           *               {"ref": "https://google.co.uk", "label": "Google", "destination": "LINK",
           *             ]
           *           }
           *         ]
           *       }
           *     ]
           *   }
           * }
           * @description Required. The Nav to create.
           */
          nav?: {
            /** @description Output only. The unique ID of the nav. */
            uid?: string;
            /** @description Required. The human readable name of the nav. */
            name: string;
            /** @description The ID of the user this nav is used for. */
            userId?: string;
            /** @description The ID of the tenant this nav is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** @description A list of child NavNodes. */
            nodes?: {
              /**
               * @description The destination this NavNode links to.
               * @default DESTINATION_UNSPECIFIED
               * @enum {string}
               */
              destination?:
                | "DESTINATION_UNSPECIFIED"
                | "NOOP"
                | "PLATFORM"
                | "LINK"
                | "PAGE"
                | "WEBX";
              /** @description The link for this NavNode. The format depends on the value in `destination`. */
              ref?: string;
              /** @description The label to display in the frontend for this NavNode. */
              label?: string;
              /** @description A list of child NavNodes. */
              nodes?: unknown[];
              /** @description A list of the Role IDs that are able to view this NavNode. */
              grantToRoleIds?: string[];
            }[];
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetNavsUnrestricted: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        /** Filter results which matching name. */
        name?: unknown;
        /** The maximum number of items to return. Zero returns everything. */
        limit?: unknown;
        /** The page number to fetch. Used with limit. */
        page?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetNavUnrestricted: {
    parameters: {
      path: {
        /** The UID of the Nav. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutNav: {
    parameters: {
      path: {
        /** Output only. The unique ID of the nav. */
        "nav.uid": unknown;
      };
      body: {
        body: {
          /**
           * Required. The Nav to update.
           * @description Required. The Nav to update.
           */
          nav?: {
            /** @description Required. The human readable name of the nav. */
            name: string;
            /** @description The ID of the user this nav is used for. */
            userId?: string;
            /** @description The ID of the tenant this nav is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** @description A list of child NavNodes. */
            nodes?: {
              /**
               * @description The destination this NavNode links to.
               * @default DESTINATION_UNSPECIFIED
               * @enum {string}
               */
              destination?:
                | "DESTINATION_UNSPECIFIED"
                | "NOOP"
                | "PLATFORM"
                | "LINK"
                | "PAGE"
                | "WEBX";
              /** @description The link for this NavNode. The format depends on the value in `destination`. */
              ref?: string;
              /** @description The label to display in the frontend for this NavNode. */
              label?: string;
              /** @description A list of child NavNodes. */
              nodes?: unknown[];
              /** @description A list of the Role IDs that are able to view this NavNode. */
              grantToRoleIds?: string[];
            }[];
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        } & {
          name: unknown;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetNav: {
    parameters: {
      path: {
        /** The UID of the Nav. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelNav: {
    parameters: {
      path: {
        /** The UID of the Nav. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetResources: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        resource?: unknown;
        /** The maximum number of items to return. Zero returns everything. */
        limit?: unknown;
        /**
         * - DATASOURCE_UNSPECIFIED: Not specified. This value should be never used.
         *  - ELASTICSEARCH: The data is stored in ElasticSearch.
         *  - GRAPHQL: The data is stored behind a GraphQL endpoint.
         *  - CUSTOM: The data is stored using a custom endpoint(s).
         */
        datasource?: unknown;
        /**
         * URL is the URL the request will be sent to.
         * It is evaluated as a template.
         */
        "datasourceParamsCustom.getObjects.request.request.url"?: unknown;
        /** Method is the request method that will be used. */
        "datasourceParamsCustom.getObjects.request.request.method"?: unknown;
        /**
         * Body is a template string that will be parsed and sent in the request body.
         * If it is blank, no body will be sent.
         */
        "datasourceParamsCustom.getObjects.request.request.body"?: unknown;
        /**
         * Headers is a list of strings that will be sent as headers in the request.
         * The first colon (:) will be used as a separator between the key and value of the header.
         * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
         */
        "datasourceParamsCustom.getObjects.request.request.headers"?: unknown;
        /**
         * luceneQueryKey is the name of a query string key that will be used to send the lucene query.
         * If it is blank, the lucene query will not be sent.
         */
        "datasourceParamsCustom.getObjects.request.luceneQueryKey"?: unknown;
        "datasourceParamsCustom.getObjects.request.cursorQueryKey"?: unknown;
        "datasourceParamsCustom.getObjects.request.order"?: unknown;
        /** A jsonpath selector. The result from the selector is expected to be an array of objects. */
        "datasourceParamsCustom.getObjects.jsonpathResponse.results"?: unknown;
        /**
         * A jsonpath selector. The result is expected to be an int indicating the total number of records
         * found with the given selectors.
         */
        "datasourceParamsCustom.getObjects.jsonpathResponse.total"?: unknown;
        /** A jsonpath selector. The result is expected to be a cursor that can be used with cursor based pagination. */
        "datasourceParamsCustom.getObjects.jsonpathResponse.cursor"?: unknown;
        "datasourceParamsCustom.getObjects.jsonpathResponse.cursorTemplate"?: unknown;
        /**
         * URL is the URL the request will be sent to.
         * It is evaluated as a template.
         */
        "datasourceParamsCustom.deleteObject.request.request.url"?: unknown;
        /** Method is the request method that will be used. */
        "datasourceParamsCustom.deleteObject.request.request.method"?: unknown;
        /**
         * Body is a template string that will be parsed and sent in the request body.
         * If it is blank, no body will be sent.
         */
        "datasourceParamsCustom.deleteObject.request.request.body"?: unknown;
        /**
         * Headers is a list of strings that will be sent as headers in the request.
         * The first colon (:) will be used as a separator between the key and value of the header.
         * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
         */
        "datasourceParamsCustom.deleteObject.request.request.headers"?: unknown;
        /**
         * URL is the URL the request will be sent to.
         * It is evaluated as a template.
         */
        "datasourceParamsCustom.updateObject.request.request.url"?: unknown;
        /** Method is the request method that will be used. */
        "datasourceParamsCustom.updateObject.request.request.method"?: unknown;
        /**
         * Body is a template string that will be parsed and sent in the request body.
         * If it is blank, no body will be sent.
         */
        "datasourceParamsCustom.updateObject.request.request.body"?: unknown;
        /**
         * Headers is a list of strings that will be sent as headers in the request.
         * The first colon (:) will be used as a separator between the key and value of the header.
         * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
         */
        "datasourceParamsCustom.updateObject.request.request.headers"?: unknown;
        /**
         * URL is the URL the request will be sent to.
         * It is evaluated as a template.
         */
        "datasourceParamsCustom.createObject.request.request.url"?: unknown;
        /** Method is the request method that will be used. */
        "datasourceParamsCustom.createObject.request.request.method"?: unknown;
        /**
         * Body is a template string that will be parsed and sent in the request body.
         * If it is blank, no body will be sent.
         */
        "datasourceParamsCustom.createObject.request.request.body"?: unknown;
        /**
         * Headers is a list of strings that will be sent as headers in the request.
         * The first colon (:) will be used as a separator between the key and value of the header.
         * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
         */
        "datasourceParamsCustom.createObject.request.request.headers"?: unknown;
        /**
         * A jsonpath selector. The result from the selector is expected to be a string identifying
         * the newly created record.
         */
        "datasourceParamsCustom.createObject.response.stringId"?: unknown;
        /**
         * A jsonpath selector. The result from the selector is expected to be an int identifying
         * the newly created record.
         */
        "datasourceParamsCustom.createObject.response.intId"?: unknown;
        /** Resource ID is the ID of the resource that this schema belongs to. */
        "datasourceParamsCustom.getDataSchema.static.resourceId"?: unknown;
        /**
         * URL is the URL the request will be sent to.
         * It is evaluated as a template.
         */
        "datasourceParamsCustom.getObject.request.request.url"?: unknown;
        /** Method is the request method that will be used. */
        "datasourceParamsCustom.getObject.request.request.method"?: unknown;
        /**
         * Body is a template string that will be parsed and sent in the request body.
         * If it is blank, no body will be sent.
         */
        "datasourceParamsCustom.getObject.request.request.body"?: unknown;
        /**
         * Headers is a list of strings that will be sent as headers in the request.
         * The first colon (:) will be used as a separator between the key and value of the header.
         * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
         */
        "datasourceParamsCustom.getObject.request.request.headers"?: unknown;
        /** A jsonpath selector. The result from the selector is expected to be an object. */
        "datasourceParamsCustom.getObject.jsonpathResponse.result"?: unknown;
        /** Required. The index to use when searching ElasticSearch. */
        "datasourceParamsElasticsearch.index": unknown;
        /** Required. The schema to use when querying. */
        "datasourceParamsGraphql.schema": unknown;
        /** Required. The properties to query. */
        "datasourceParamsGraphql.properties": unknown;
        /** The maximum depth to search to when detecting properties. */
        "datasourceParamsGraphql.depth"?: unknown;
        /**
         * The accessors that should be excluded from the schema.
         * Matches accessors in the format of SomeProperty, SomeParent.SomeChild and *.SomePropertyToBeMatchedInAnyParent.
         */
        "datasourceParamsGraphql.exclusions"?: unknown;
        /** Filter results which match name. */
        name?: unknown;
        /** The page number to fetch. Used with limit. */
        page?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewResource: {
    parameters: {
      body: {
        body: {
          /** @description Required. The Resource to create. */
          resource?: {
            /** @description Output only. The unique ID of the resource. */
            uid?: string;
            /** @description Required. The human readable name of the resource. */
            name: string;
            /** @description The ID of the user this resource is used for. */
            userId?: string;
            /** @description The ID of the tenant this resource is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** Required. TODO: ??? */
            resource: string;
            /**
             * @description Required. Defines where data will be queried from for this resource.
             * @default DATASOURCE_UNSPECIFIED
             * @enum {string}
             */
            datasource?:
              | "DATASOURCE_UNSPECIFIED"
              | "ELASTICSEARCH"
              | "GRAPHQL"
              | "CUSTOM";
            datasourceParamsCustom?: unknown;
            /** @description The parameters for an ElasticSearch DataSource. */
            datasourceParamsElasticsearch?: {
              /** @description Required. The index to use when searching ElasticSearch. */
              index: string;
            };
            /** @description The parameters for a GraphQL DataSource. */
            datasourceParamsGraphql?: {
              /** @description Required. The schema to use when querying. */
              schema: string;
              /** @description Required. The properties to query. */
              properties: string;
              /**
               * Format: int32
               * @description The maximum depth to search to when detecting properties.
               */
              depth?: number;
              /**
               * @description The accessors that should be excluded from the schema.
               * Matches accessors in the format of SomeProperty, SomeParent.SomeChild and *.SomePropertyToBeMatchedInAnyParent.
               */
              exclusions?: string[];
            };
            /** @description datasourceCapabilities allow you configure, enable, disable different capabilities that some functionality may rely on. */
            datasourceCapabilities?: {
              /** @description Paging allows you to configure the paging capabilities of your resource. */
              paging?: {
                /**
                 * @description Method allows you to change the paging method for your resource.
                 * @default PAGING_METHOD_UNSPECIFIED
                 * @enum {string}
                 */
                method?: "PAGING_METHOD_UNSPECIFIED" | "CURSOR" | "PAGE";
              };
              /** @description The template to use to render the definer for this resource. */
              definer?: string;
            };
            /** @description Used as a template when rendering a generic display for a record for this resource. */
            definer?: string;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** created_at UTC timestamp in rfc3339 */
            createdAt?: string;
            /** created_by user uid */
            createdBy?: string;
            /** updated_at UTC timestamp in rfc3339 */
            updatedAt?: string;
            /** updated_by user uid */
            updatedBy?: string;
            /** deleted_at UTC timestamp in rfc3339 */
            deletedAt?: string;
            /** deleted_by user uid */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutResource: {
    parameters: {
      path: {
        /** Output only. The unique ID of the resource. */
        "resource.uid": unknown;
      };
      body: {
        body: {
          /**
           * Required. The Resource to update.
           * @description Required. The Resource to update.
           */
          resource: {
            /** @description Required. The human readable name of the resource. */
            name: string;
            /** @description The ID of the user this resource is used for. */
            userId?: string;
            /** @description The ID of the tenant this resource is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** Required. TODO: ??? */
            resource: string;
            /**
             * @description Required. Defines where data will be queried from for this resource.
             * @default DATASOURCE_UNSPECIFIED
             * @enum {string}
             */
            datasource?:
              | "DATASOURCE_UNSPECIFIED"
              | "ELASTICSEARCH"
              | "GRAPHQL"
              | "CUSTOM";
            /**
             * DatasourceParamsCustom type definition
             * @description The parameters for a Custom DataSource.
             */
            datasourceParamsCustom?: {
              /** @description GetObjectsCustom provides the values required to perform a custom get-objects request. */
              getObjects?: {
                /**
                 * @description GetObjectsCustomRequest is the definition of a custom http request
                 * that is used to return a list of records for a resource.
                 */
                request?: {
                  /** @description Request is the base request. */
                  request?: {
                    /**
                     * @description URL is the URL the request will be sent to.
                     * It is evaluated as a template.
                     */
                    url?: string;
                    /**
                     * Method enum for HTTP verb
                     * @description Method is the request method that will be used.
                     * @default REQUEST_METHOD_UNSPECIFIED
                     * @enum {string}
                     */
                    method?:
                      | "REQUEST_METHOD_UNSPECIFIED"
                      | "GET"
                      | "POST"
                      | "PUT"
                      | "PATCH"
                      | "DELETE";
                    /**
                     * @description Body is a template string that will be parsed and sent in the request body.
                     * If it is blank, no body will be sent.
                     */
                    body?: string;
                    /**
                     * @description Headers is a list of strings that will be sent as headers in the request.
                     * The first colon (:) will be used as a separator between the key and value of the header.
                     * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
                     */
                    headers?: string[];
                  };
                  /**
                   * @description luceneQueryKey is the name of a query string key that will be used to send the lucene query.
                   * If it is blank, the lucene query will not be sent.
                   */
                  luceneQueryKey?: string;
                  cursorQueryKey?: string;
                  order?: string[];
                  filterMapping?: {
                    /** @description A set of mappings that can be used to add query parameters. */
                    mappings?: {
                      field?: string;
                      /**
                       * @description  - COMPARISON_UNSPECIFIED: Not specified. This value should be never used.
                       * @default COMPARISON_UNSPECIFIED
                       * @enum {string}
                       */
                      comparison?:
                        | "COMPARISON_UNSPECIFIED"
                        | "EQUAL"
                        | "MORE_THAN"
                        | "MORE_THAN_EQUAL"
                        | "LESS_THAN"
                        | "LESS_THAN_EQUAL"
                        | "CONTAINS"
                        | "STARTS_WITH"
                        | "ENDS_WITH"
                        | "LIKE";
                      not?: boolean;
                      /**
                       * @description A template that should result in a `key=value` output.
                       * Can result in multiple parameters being set: `a=1&b=2`.
                       */
                      queryParamTemplate?: string;
                    }[];
                  };
                };
                /** @description GetObjectsJsonpathResponse is used to format a JSON result into the expected format. */
                jsonpathResponse?: {
                  /** @description A jsonpath selector. The result from the selector is expected to be an array of objects. */
                  results?: string;
                  /**
                   * @description A jsonpath selector. The result is expected to be an int indicating the total number of records
                   * found with the given selectors.
                   */
                  total?: string;
                  /** @description A jsonpath selector. The result is expected to be a cursor that can be used with cursor based pagination. */
                  cursor?: string;
                  cursorTemplate?: string;
                };
                /**
                 * @description RecordMappings contains information on how a record should be mapped when it's coming in/out
                 * of the system.
                 */
                recordMappings?: {
                  outgoing?: {
                    /** @description schema_field is the name of the field as it appears in the schema. */
                    schemaField?: string;
                    /** @description outputPath is a jsonpath pointing to a location the data should be added. */
                    outputPath?: string;
                  }[];
                  incoming?: {
                    /** @description schema_field is the name of the field as it appears in the schema. */
                    schemaField?: string;
                    /** @description input_path is a jsonpath pointing to a location in the incoming data. */
                    inputPath?: string;
                  }[];
                };
              };
              /** @description DeleteObjectCustom provides the values required to perform a custom delete-object request. */
              deleteObject?: {
                /**
                 * @description DeleteObjectCustomRequest is the definition of a custom http request
                 * that is used to delete a single record.
                 */
                request?: {
                  /** @description Request is the base request. */
                  request?: {
                    /**
                     * @description URL is the URL the request will be sent to.
                     * It is evaluated as a template.
                     */
                    url?: string;
                    /**
                     * Method enum for HTTP verb
                     * @description Method is the request method that will be used.
                     * @default REQUEST_METHOD_UNSPECIFIED
                     * @enum {string}
                     */
                    method?:
                      | "REQUEST_METHOD_UNSPECIFIED"
                      | "GET"
                      | "POST"
                      | "PUT"
                      | "PATCH"
                      | "DELETE";
                    /**
                     * @description Body is a template string that will be parsed and sent in the request body.
                     * If it is blank, no body will be sent.
                     */
                    body?: string;
                    /**
                     * @description Headers is a list of strings that will be sent as headers in the request.
                     * The first colon (:) will be used as a separator between the key and value of the header.
                     * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
                     */
                    headers?: string[];
                  };
                };
              };
              /** @description UpdateObjectCustom provides the values required to perform a custom update-object request. */
              updateObject?: {
                /**
                 * @description UpdateObjectCustomRequest is the definition of a custom http request
                 * that is used to delete a update record.
                 */
                request?: {
                  /** @description Request is the base request. */
                  request?: {
                    /**
                     * @description URL is the URL the request will be sent to.
                     * It is evaluated as a template.
                     */
                    url?: string;
                    /**
                     * Method enum for HTTP verb
                     * @description Method is the request method that will be used.
                     * @default REQUEST_METHOD_UNSPECIFIED
                     * @enum {string}
                     */
                    method?:
                      | "REQUEST_METHOD_UNSPECIFIED"
                      | "GET"
                      | "POST"
                      | "PUT"
                      | "PATCH"
                      | "DELETE";
                    /**
                     * @description Body is a template string that will be parsed and sent in the request body.
                     * If it is blank, no body will be sent.
                     */
                    body?: string;
                    /**
                     * @description Headers is a list of strings that will be sent as headers in the request.
                     * The first colon (:) will be used as a separator between the key and value of the header.
                     * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
                     */
                    headers?: string[];
                  };
                };
                /**
                 * @description RecordMappings contains information on how a record should be mapped when it's coming in/out
                 * of the system.
                 */
                recordMappings?: {
                  outgoing?: {
                    /** @description schema_field is the name of the field as it appears in the schema. */
                    schemaField?: string;
                    /** @description outputPath is a jsonpath pointing to a location the data should be added. */
                    outputPath?: string;
                  }[];
                  incoming?: {
                    /** @description schema_field is the name of the field as it appears in the schema. */
                    schemaField?: string;
                    /** @description input_path is a jsonpath pointing to a location in the incoming data. */
                    inputPath?: string;
                  }[];
                };
              };
              /** @description CreateObjectCustom provides the values required to perform a custom create-object request. */
              createObject?: {
                /**
                 * @description CreateObjectCustomRequest is the definition of a custom http request
                 * that is used to create a single record.
                 */
                request?: {
                  /** @description Request is the base request. */
                  request?: {
                    /**
                     * @description URL is the URL the request will be sent to.
                     * It is evaluated as a template.
                     */
                    url?: string;
                    /**
                     * Method enum for HTTP verb
                     * @description Method is the request method that will be used.
                     * @default REQUEST_METHOD_UNSPECIFIED
                     * @enum {string}
                     */
                    method?:
                      | "REQUEST_METHOD_UNSPECIFIED"
                      | "GET"
                      | "POST"
                      | "PUT"
                      | "PATCH"
                      | "DELETE";
                    /**
                     * @description Body is a template string that will be parsed and sent in the request body.
                     * If it is blank, no body will be sent.
                     */
                    body?: string;
                    /**
                     * @description Headers is a list of strings that will be sent as headers in the request.
                     * The first colon (:) will be used as a separator between the key and value of the header.
                     * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
                     */
                    headers?: string[];
                  };
                };
                /** @description CreateObjectCustomJsonpathResponse is used to format a JSON result into the expected format. */
                response?: {
                  /**
                   * @description A jsonpath selector. The result from the selector is expected to be a string identifying
                   * the newly created record.
                   */
                  stringId?: string;
                  /**
                   * @description A jsonpath selector. The result from the selector is expected to be an int identifying
                   * the newly created record.
                   */
                  intId?: string;
                };
                /**
                 * @description RecordMappings contains information on how a record should be mapped when it's coming in/out
                 * of the system.
                 */
                recordMappings?: {
                  outgoing?: {
                    /** @description schema_field is the name of the field as it appears in the schema. */
                    schemaField?: string;
                    /** @description outputPath is a jsonpath pointing to a location the data should be added. */
                    outputPath?: string;
                  }[];
                  incoming?: {
                    /** @description schema_field is the name of the field as it appears in the schema. */
                    schemaField?: string;
                    /** @description input_path is a jsonpath pointing to a location in the incoming data. */
                    inputPath?: string;
                  }[];
                };
              };
              getDataSchema?: unknown;
              /** @description GetObjectCustom provides the values required to perform a custom get-object request. */
              getObject?: {
                /**
                 * @description GetObjectCustomRequest is the definition of a custom http request
                 * that is used to return a single resource record by it's primary key.
                 */
                request?: {
                  /** @description Request is the base request. */
                  request?: {
                    /**
                     * @description URL is the URL the request will be sent to.
                     * It is evaluated as a template.
                     */
                    url?: string;
                    /**
                     * Method enum for HTTP verb
                     * @description Method is the request method that will be used.
                     * @default REQUEST_METHOD_UNSPECIFIED
                     * @enum {string}
                     */
                    method?:
                      | "REQUEST_METHOD_UNSPECIFIED"
                      | "GET"
                      | "POST"
                      | "PUT"
                      | "PATCH"
                      | "DELETE";
                    /**
                     * @description Body is a template string that will be parsed and sent in the request body.
                     * If it is blank, no body will be sent.
                     */
                    body?: string;
                    /**
                     * @description Headers is a list of strings that will be sent as headers in the request.
                     * The first colon (:) will be used as a separator between the key and value of the header.
                     * Each header string will be evaluated as a template allowing you to pass through auth tokens etc.
                     */
                    headers?: string[];
                  };
                };
                /** @description GetObjectJsonpathResponse is used to format a JSON result into the expected format. */
                jsonpathResponse?: {
                  /** @description A jsonpath selector. The result from the selector is expected to be an object. */
                  result?: string;
                };
                /**
                 * @description RecordMappings contains information on how a record should be mapped when it's coming in/out
                 * of the system.
                 */
                recordMappings?: {
                  outgoing?: {
                    /** @description schema_field is the name of the field as it appears in the schema. */
                    schemaField?: string;
                    /** @description outputPath is a jsonpath pointing to a location the data should be added. */
                    outputPath?: string;
                  }[];
                  incoming?: {
                    /** @description schema_field is the name of the field as it appears in the schema. */
                    schemaField?: string;
                    /** @description input_path is a jsonpath pointing to a location in the incoming data. */
                    inputPath?: string;
                  }[];
                };
              };
            };
            /** @description The parameters for an ElasticSearch DataSource. */
            datasourceParamsElasticsearch?: {
              /** @description Required. The index to use when searching ElasticSearch. */
              index: string;
            };
            /** @description The parameters for a GraphQL DataSource. */
            datasourceParamsGraphql?: {
              /** @description Required. The schema to use when querying. */
              schema: string;
              /** @description Required. The properties to query. */
              properties: string;
              /**
               * Format: int32
               * @description The maximum depth to search to when detecting properties.
               */
              depth?: number;
              /**
               * @description The accessors that should be excluded from the schema.
               * Matches accessors in the format of SomeProperty, SomeParent.SomeChild and *.SomePropertyToBeMatchedInAnyParent.
               */
              exclusions?: string[];
            };
            /** @description datasourceCapabilities allow you configure, enable, disable different capabilities that some functionality may rely on. */
            datasourceCapabilities?: {
              /** @description Paging allows you to configure the paging capabilities of your resource. */
              paging?: {
                /**
                 * @description Method allows you to change the paging method for your resource.
                 * @default PAGING_METHOD_UNSPECIFIED
                 * @enum {string}
                 */
                method?: "PAGING_METHOD_UNSPECIFIED" | "CURSOR" | "PAGE";
              };
              /** @description The template to use to render the definer for this resource. */
              definer?: string;
            };
            /** @description Used as a template when rendering a generic display for a record for this resource. */
            definer?: string;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** created_at UTC timestamp in rfc3339 */
            createdAt?: string;
            /** created_by user uid */
            createdBy?: string;
            /** updated_at UTC timestamp in rfc3339 */
            updatedAt?: string;
            /** updated_by user uid */
            updatedBy?: string;
            /** deleted_at UTC timestamp in rfc3339 */
            deletedAt?: string;
            /** deleted_by user uid */
            deletedBy?: string;
          };
        } & {
          name: unknown;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetResource: {
    parameters: {
      path: {
        /** The UID of the Resource. */
        uid: unknown;
      };
      query: {
        /** The name of the Resource. */
        name?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelResource: {
    parameters: {
      path: {
        /** Required. The UID of the Resource. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_InitiateSchemaSync: {
    parameters: {
      body: {
        body: {
          /**
           * The schema change type
           * @default SCHEMA_CHANGE_TYPE_UNSPECIFIED
           * @enum {string}
           */
          change?: "SCHEMA_CHANGE_TYPE_UNSPECIFIED" | "UPSERT" | "DELETE";
          /** The GraphQL schema name */
          schema?: string;
          /** Optional. Indicates if system admin requests on a tenant behalf */
          tenantId?: string;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetTemplates: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        /** Deprecated: Use filter instead. */
        name?: unknown;
        /** The maximum number of items to return. Zero returns everything. */
        limit?: unknown;
        /** The page number to fetch. Used with limit. */
        page?: unknown;
        filter?: unknown;
        sorting?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewTemplate: {
    parameters: {
      body: {
        body: {
          /** @description The Template to create. */
          template?: {
            /** @description Output only. The unique ID of the template. */
            uid?: string;
            /** @description Required. The human readable name of the template. */
            name: string;
            /** @description The ID of the user this template is used for. */
            userId?: string;
            /** @description The ID of the tenant this template is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** @description The template content. */
            content?: string;
            /**
             * The kind of template
             * @description  - KIND_UNSPECIFIED: Not specified. This value should be never used.
             * @default KIND_UNSPECIFIED
             * @enum {string}
             */
            kind?: "KIND_UNSPECIFIED" | "PAGE_LAYOUT" | "PAGE_EXTEND";
            /** @description An optional description of the template. */
            description?: string;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutTemplate: {
    parameters: {
      path: {
        /** Output only. The unique ID of the template. */
        "template.uid": unknown;
      };
      body: {
        body: {
          /**
           * The Template to update.
           * @description The Template to update.
           */
          template?: {
            /** @description Required. The human readable name of the template. */
            name: string;
            /** @description The ID of the user this template is used for. */
            userId?: string;
            /** @description The ID of the tenant this template is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** @description The template content. */
            content?: string;
            /**
             * The kind of template
             * @description  - KIND_UNSPECIFIED: Not specified. This value should be never used.
             * @default KIND_UNSPECIFIED
             * @enum {string}
             */
            kind?: "KIND_UNSPECIFIED" | "PAGE_LAYOUT" | "PAGE_EXTEND";
            /** @description An optional description of the template. */
            description?: string;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        } & {
          name: unknown;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetTemplate: {
    parameters: {
      path: {
        /** The UID of the Template. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelTemplate: {
    parameters: {
      path: {
        /** The UID of the Template. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetValidations: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        /** Match Validations by name. */
        name?: unknown;
        /** The maximum number of items to return. Zero returns everything. */
        limit?: unknown;
        /** The page number to fetch. Used with limit. */
        page?: unknown;
        uncomposed?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewValidation: {
    parameters: {
      body: {
        body: {
          /** @description The Validation to create. */
          validation?: {
            /** @description Output only. The unique ID of the validation. */
            uid?: string;
            /** @description Required. The human readable name of the validation. */
            name: string;
            /** @description The ID of the user this validation is used for. */
            userId?: string;
            /** @description The ID of the tenant this validation is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** @description The JSON Schema used for validation. */
            jsonSchema?: string;
            composeOf?: string[];
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_ValidateData: {
    parameters: {
      path: {
        /** The name of the validation to use. */
        name: unknown;
      };
      body: {
        body: {
          /** @description The data to be validated against the schema as a JSON serialized string. */
          data?: string;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetValidation: {
    parameters: {
      path: {
        /** The UID of the Validation. */
        uid: unknown;
      };
      query: {
        uncomposed?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelValidation: {
    parameters: {
      path: {
        /** The UID of the Validation. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutValidation: {
    parameters: {
      path: {
        /** Output only. The unique ID of the validation. */
        "validation.uid": unknown;
      };
      body: {
        body: {
          /**
           * The Validation to update.
           * @description The Validation to update.
           */
          validation?: {
            /** @description Required. The human readable name of the validation. */
            name: string;
            /** @description The ID of the user this validation is used for. */
            userId?: string;
            /** @description The ID of the tenant this validation is used for. */
            tenantId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** @description The JSON Schema used for validation. */
            jsonSchema?: string;
            composeOf?: string[];
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        } & {
          name: unknown;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetViewOverrides: {
    parameters: {
      query: {
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "userId.strategy"?: unknown;
        /** The value to be matched. */
        "userId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "tenantId.strategy"?: unknown;
        /** The value to be matched. */
        "tenantId.value"?: unknown;
        /**
         * Required. The strategy to use when matching the value.
         *
         *  - MATCH_STRATEGY_UNSPECIFIED: Not specified. This value should be never used.
         *  - MATCH_EXACT: Match the value exactly.
         *  - MATCH_EXACT_AND_NULL: Match the value exactly, or where the value is null or empty.
         *  - MATCH_NULL_ONLY: Match null or empty only.
         *  - MATCH_ANY: Match any value.
         */
        "domainId.strategy"?: unknown;
        /** The value to be matched. */
        "domainId.value"?: unknown;
        /** Filter results based on view_id. */
        viewId?: unknown;
        /** The maximum number of items to return. Zero returns everything. */
        limit?: unknown;
        /** Filter results which match name. */
        name?: unknown;
        /** The page number to fetch. Used with limit. */
        page?: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_NewViewOverride: {
    parameters: {
      body: {
        body: {
          /** @description Required. The ViewOverride to create. */
          viewOverride?: {
            /** @description Output only. The unique ID of the view override. */
            uid?: string;
            /** @description The ID of the user this override is used for. */
            userId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** @description The ID of the tenant this override is used for. */
            tenantId?: string;
            /** Required. TODO: ??? */
            viewId: string;
            data?: string;
            /** @description Required. The human readable name of the filter. */
            name: string;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_GetViewOverride: {
    parameters: {
      path: {
        /** The UID of the ViewOverride. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_DelViewOverride: {
    parameters: {
      path: {
        /** The UID of the ViewOverride. */
        uid: unknown;
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
  UIService_PutViewOverride: {
    parameters: {
      path: {
        /** Output only. The unique ID of the view override. */
        "viewOverride.uid": unknown;
      };
      body: {
        body: {
          /**
           * Required. The ViewOverride to update.
           * @description Required. The ViewOverride to update.
           */
          viewOverride?: {
            /** @description The ID of the user this override is used for. */
            userId?: string;
            /** @description Deprecated. */
            domainId?: string;
            /** @description The ID of the tenant this override is used for. */
            tenantId?: string;
            /** Required. TODO: ??? */
            viewId: string;
            data?: string;
            /** @description Required. The human readable name of the filter. */
            name: string;
            /** @description The flag defines the creation type, which is permission controlled. */
            isSystemGenerated?: boolean;
            /** @description Creation timestamp in RFC3339 text format. */
            createdAt?: string;
            /** @description The UID of the User who created this configuration. */
            createdBy?: string;
            /** @description Updated timestamp in RFC3339 text format. */
            updatedAt?: string;
            /** @description The UID of the User who last updated this configuration. */
            updatedBy?: string;
            /** @description Deletion timestamp in RFC3339 text format. */
            deletedAt?: string;
            /** @description The UID of the User who deleted this configuration. */
            deletedBy?: string;
          };
        } & {
          viewId: unknown;
          name: unknown;
        };
      };
    };
    responses: {
      /** A successful response. */
      200: {
        content: {};
      };
      /** An unexpected error response. */
      default: {
        content: {};
      };
    };
  };
}

export interface external {}
